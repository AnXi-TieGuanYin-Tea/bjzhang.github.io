
drivers/base/core.o:     file format elf64-littleaarch64
drivers/base/core.o
architecture: aarch64, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x0000000000000000
private flags = 0:

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00002ea8  0000000000000000  0000000000000000  00000040  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000100  0000000000000000  0000000000000000  00002ee8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000038  0000000000000000  0000000000000000  00002fe8  2**3
                  ALLOC
  3 __bug_table   0000003c  0000000000000000  0000000000000000  00002fe8  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .rodata.str   00000064  0000000000000000  0000000000000000  00003024  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .init.text    000000bc  0000000000000000  0000000000000000  00003088  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .rodata       000000e8  0000000000000000  0000000000000000  00003148  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  7 ___ksymtab+dev_driver_string 00000010  0000000000000000  0000000000000000  00003230  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  8 ___ksymtab_gpl+device_rename 00000010  0000000000000000  0000000000000000  00003240  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  9 ___ksymtab_gpl+device_del 00000010  0000000000000000  0000000000000000  00003250  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 10 ___ksymtab_gpl+device_remove_file_self 00000010  0000000000000000  0000000000000000  00003260  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 11 ___ksymtab_gpl+device_create 00000010  0000000000000000  0000000000000000  00003270  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 12 ___ksymtab_gpl+device_find_child 00000010  0000000000000000  0000000000000000  00003280  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 13 __ksymtab_strings 000002af  0000000000000000  0000000000000000  00003290  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 14 ___ksymtab_gpl+device_add 00000010  0000000000000000  0000000000000000  00003540  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 15 ___ksymtab_gpl+device_move 00000010  0000000000000000  0000000000000000  00003550  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 16 ___ksymtab_gpl+device_for_each_child_reverse 00000010  0000000000000000  0000000000000000  00003560  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 17 ___ksymtab_gpl+device_show_int 00000010  0000000000000000  0000000000000000  00003570  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 18 .rodata.str1.8 000004c0  0000000000000000  0000000000000000  00003580  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 19 ___ksymtab_gpl+set_primary_fwnode 00000010  0000000000000000  0000000000000000  00003a40  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 20 ___ksymtab_gpl+device_remove_file 00000010  0000000000000000  0000000000000000  00003a50  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 21 ___ksymtab+dev_crit 00000010  0000000000000000  0000000000000000  00003a60  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 22 ___ksymtab+dev_printk 00000010  0000000000000000  0000000000000000  00003a70  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 23 ___ksymtab+dev_warn 00000010  0000000000000000  0000000000000000  00003a80  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 24 ___ksymtab_gpl+device_create_file 00000010  0000000000000000  0000000000000000  00003a90  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 25 __verbose     000001b8  0000000000000000  0000000000000000  00003aa0  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
 26 ___ksymtab_gpl+root_device_unregister 00000010  0000000000000000  0000000000000000  00003c58  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 27 ___ksymtab+_dev_info 00000010  0000000000000000  0000000000000000  00003c68  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 28 ___ksymtab_gpl+device_show_bool 00000010  0000000000000000  0000000000000000  00003c78  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 29 ___ksymtab_gpl+device_register 00000010  0000000000000000  0000000000000000  00003c88  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 30 ___ksymtab_gpl+device_for_each_child 00000010  0000000000000000  0000000000000000  00003c98  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 31 ___ksymtab_gpl+dev_set_name 00000010  0000000000000000  0000000000000000  00003ca8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 32 ___ksymtab_gpl+device_create_bin_file 00000010  0000000000000000  0000000000000000  00003cb8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 33 ___ksymtab_gpl+device_create_vargs 00000010  0000000000000000  0000000000000000  00003cc8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 34 ___ksymtab_gpl+device_remove_bin_file 00000010  0000000000000000  0000000000000000  00003cd8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 35 ___ksymtab_gpl+__root_device_register 00000010  0000000000000000  0000000000000000  00003ce8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 36 ___ksymtab_gpl+device_store_ulong 00000010  0000000000000000  0000000000000000  00003cf8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 37 ___ksymtab_gpl+get_device 00000010  0000000000000000  0000000000000000  00003d08  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 38 ___ksymtab_gpl+put_device 00000010  0000000000000000  0000000000000000  00003d18  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 39 ___ksymtab+dev_err 00000010  0000000000000000  0000000000000000  00003d28  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 40 ___ksymtab+dev_printk_emit 00000010  0000000000000000  0000000000000000  00003d38  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 41 ___ksymtab_gpl+device_show_ulong 00000010  0000000000000000  0000000000000000  00003d48  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 42 ___ksymtab_gpl+device_unregister 00000010  0000000000000000  0000000000000000  00003d58  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 43 ___ksymtab_gpl+device_destroy 00000010  0000000000000000  0000000000000000  00003d68  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 44 ___ksymtab+dev_vprintk_emit 00000010  0000000000000000  0000000000000000  00003d78  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 45 ___ksymtab+dev_alert 00000010  0000000000000000  0000000000000000  00003d88  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 46 ___ksymtab_gpl+device_initialize 00000010  0000000000000000  0000000000000000  00003d98  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 47 ___ksymtab_gpl+device_store_bool 00000010  0000000000000000  0000000000000000  00003da8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 48 ___ksymtab_gpl+device_create_with_groups 00000010  0000000000000000  0000000000000000  00003db8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 49 ___ksymtab+dev_emerg 00000010  0000000000000000  0000000000000000  00003dc8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 50 ___ksymtab_gpl+device_store_int 00000010  0000000000000000  0000000000000000  00003dd8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 51 ___ksymtab+dev_notice 00000010  0000000000000000  0000000000000000  00003de8  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 52 .debug_info   00017ca1  0000000000000000  0000000000000000  00003df8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 53 .debug_abbrev 00000883  0000000000000000  0000000000000000  0001ba99  2**0
                  CONTENTS, READONLY, DEBUGGING
 54 .debug_loc    0000365f  0000000000000000  0000000000000000  0001c31c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 55 .debug_aranges 00000040  0000000000000000  0000000000000000  0001f97b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 56 .debug_ranges 00000fa0  0000000000000000  0000000000000000  0001f9bb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 57 .debug_line   00001a1f  0000000000000000  0000000000000000  0002095b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 58 .debug_str    0000b440  0000000000000000  0000000000000000  0002237a  2**0
                  CONTENTS, READONLY, DEBUGGING
 59 .comment      00000037  0000000000000000  0000000000000000  0002d7ba  2**0
                  CONTENTS, READONLY
 60 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0002d7f1  2**0
                  CONTENTS, READONLY
 61 .debug_frame  00001080  0000000000000000  0000000000000000  0002d7f8  2**3
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
0000000000000000 l    df *ABS*	0000000000000000 core.c
0000000000000000 l    d  .text	0000000000000000 .text
0000000000000000 l    d  .data	0000000000000000 .data
0000000000000000 l    d  .bss	0000000000000000 .bss
0000000000000000 l       *ABS*	0000000000000000 __reg_num_x0
0000000000000001 l       *ABS*	0000000000000000 __reg_num_x1
0000000000000002 l       *ABS*	0000000000000000 __reg_num_x2
0000000000000003 l       *ABS*	0000000000000000 __reg_num_x3
0000000000000004 l       *ABS*	0000000000000000 __reg_num_x4
0000000000000005 l       *ABS*	0000000000000000 __reg_num_x5
0000000000000006 l       *ABS*	0000000000000000 __reg_num_x6
0000000000000007 l       *ABS*	0000000000000000 __reg_num_x7
0000000000000008 l       *ABS*	0000000000000000 __reg_num_x8
0000000000000009 l       *ABS*	0000000000000000 __reg_num_x9
000000000000000a l       *ABS*	0000000000000000 __reg_num_x10
000000000000000b l       *ABS*	0000000000000000 __reg_num_x11
000000000000000c l       *ABS*	0000000000000000 __reg_num_x12
000000000000000d l       *ABS*	0000000000000000 __reg_num_x13
000000000000000e l       *ABS*	0000000000000000 __reg_num_x14
000000000000000f l       *ABS*	0000000000000000 __reg_num_x15
0000000000000010 l       *ABS*	0000000000000000 __reg_num_x16
0000000000000011 l       *ABS*	0000000000000000 __reg_num_x17
0000000000000012 l       *ABS*	0000000000000000 __reg_num_x18
0000000000000013 l       *ABS*	0000000000000000 __reg_num_x19
0000000000000014 l       *ABS*	0000000000000000 __reg_num_x20
0000000000000015 l       *ABS*	0000000000000000 __reg_num_x21
0000000000000016 l       *ABS*	0000000000000000 __reg_num_x22
0000000000000017 l       *ABS*	0000000000000000 __reg_num_x23
0000000000000018 l       *ABS*	0000000000000000 __reg_num_x24
0000000000000019 l       *ABS*	0000000000000000 __reg_num_x25
000000000000001a l       *ABS*	0000000000000000 __reg_num_x26
000000000000001b l       *ABS*	0000000000000000 __reg_num_x27
000000000000001c l       *ABS*	0000000000000000 __reg_num_x28
000000000000001d l       *ABS*	0000000000000000 __reg_num_x29
000000000000001e l       *ABS*	0000000000000000 __reg_num_x30
000000000000001f l       *ABS*	0000000000000000 __reg_num_xzr
0000000000000000 l     F .text	0000000000000028 dev_attr_store
0000000000000028 l     F .text	0000000000000034 device_namespace
000000000000005c l     F .text	000000000000003c dev_uevent_filter
0000000000000098 l     F .text	000000000000000c class_dir_child_ns_type
00000000000000a4 l     F .text	0000000000000014 __match_devt
0000000000000000 l    d  __bug_table	0000000000000000 __bug_table
0000000000000000 l    d  .rodata.str	0000000000000000 .rodata.str
0000000000000300 l     F .text	000000000000007c device_remove_attrs
00000000000003e8 l     F .text	0000000000000090 device_release
0000000000000478 l     F .text	0000000000000014 class_dir_release
000000000000048c l     F .text	0000000000000014 root_device_release
00000000000004a0 l     F .text	0000000000000070 device_create_release
000000000000061c l     F .text	0000000000000030 dev_show
000000000000064c l     F .text	000000000000010c uevent_show
0000000000000758 l     F .text	0000000000000064 online_show
00000000000007e4 l     F .text	0000000000000020 klist_children_get
0000000000000820 l     F .text	0000000000000020 klist_children_put
0000000000000840 l     F .text	00000000000000a0 device_remove_class_symlinks
0000000000000b98 l     F .text	000000000000002c dev_driver_string.part.12
0000000000000bec l     F .text	0000000000000054 dev_attr_show
0000000000000c40 l     F .text	0000000000000024 dev_uevent_name
0000000000000cc0 l     F .text	0000000000000064 cleanup_glue_dir.isra.17
0000000000001024 l     F .text	000000000000005c device_check_offline
00000000000012b0 l     F .text	0000000000000088 __dev_printk
0000000000001530 l     F .text	0000000000000068 uevent_store
0000000000001880 l     F .text	0000000000000194 get_device_parent
0000000000002524 l     F .text	0000000000000130 device_create_groups_vargs
0000000000002844 l     F .text	0000000000000294 dev_uevent
0000000000000000 l    d  .init.text	0000000000000000 .init.text
0000000000002c48 l     F .text	0000000000000088 online_store
0000000000000000 l    d  .rodata	0000000000000000 .rodata
0000000000000000 l     O .rodata	0000000000000016 __func__.42634
0000000000000018 l     O .rodata	0000000000000012 __func__.42489
0000000000000030 l     O .rodata	000000000000000c __func__.42750
0000000000000040 l     O .rodata	000000000000000b __func__.42423
0000000000000050 l     O .rodata	000000000000000b __func__.42114
0000000000000060 l     O .rodata	0000000000000018 device_uevent_ops
0000000000000078 l     O .rodata	0000000000000019 __func__.42229
0000000000000098 l     O .rodata	0000000000000018 __func__.42235
00000000000000b0 l     O .rodata	000000000000000e __func__.42727
00000000000000c0 l     O .rodata	0000000000000017 __func__.42240
00000000000000d8 l     O .rodata	0000000000000010 dev_sysfs_ops
0000000000000000 l    d  ___ksymtab+dev_driver_string	0000000000000000 ___ksymtab+dev_driver_string
000000000000029d l     O __ksymtab_strings	0000000000000012 __kstrtab_dev_driver_string
0000000000000000 l    d  ___ksymtab_gpl+device_rename	0000000000000000 ___ksymtab_gpl+device_rename
000000000000008e l     O __ksymtab_strings	000000000000000e __kstrtab_device_rename
0000000000000000 l    d  ___ksymtab_gpl+device_del	0000000000000000 ___ksymtab_gpl+device_del
000000000000016d l     O __ksymtab_strings	000000000000000b __kstrtab_device_del
0000000000000000 l    d  ___ksymtab_gpl+device_remove_file_self	0000000000000000 ___ksymtab_gpl+device_remove_file_self
00000000000001f6 l     O __ksymtab_strings	0000000000000018 __kstrtab_device_remove_file_self
0000000000000000 l    d  ___ksymtab_gpl+device_create	0000000000000000 ___ksymtab_gpl+device_create
00000000000000c5 l     O __ksymtab_strings	000000000000000e __kstrtab_device_create
0000000000000000 l    d  ___ksymtab_gpl+device_find_child	0000000000000000 ___ksymtab_gpl+device_find_child
0000000000000115 l     O __ksymtab_strings	0000000000000012 __kstrtab_device_find_child
0000000000000000 l    d  __ksymtab_strings	0000000000000000 __ksymtab_strings
0000000000000000 l     O __ksymtab_strings	0000000000000013 __kstrtab_set_primary_fwnode
0000000000000013 l     O __ksymtab_strings	000000000000000a __kstrtab__dev_info
000000000000001d l     O __ksymtab_strings	000000000000000b __kstrtab_dev_notice
0000000000000028 l     O __ksymtab_strings	0000000000000009 __kstrtab_dev_warn
0000000000000031 l     O __ksymtab_strings	0000000000000008 __kstrtab_dev_err
0000000000000039 l     O __ksymtab_strings	0000000000000009 __kstrtab_dev_crit
0000000000000042 l     O __ksymtab_strings	000000000000000a __kstrtab_dev_alert
000000000000004c l     O __ksymtab_strings	000000000000000a __kstrtab_dev_emerg
0000000000000056 l     O __ksymtab_strings	000000000000000b __kstrtab_dev_printk
0000000000000061 l     O __ksymtab_strings	0000000000000010 __kstrtab_dev_printk_emit
0000000000000071 l     O __ksymtab_strings	0000000000000011 __kstrtab_dev_vprintk_emit
0000000000000082 l     O __ksymtab_strings	000000000000000c __kstrtab_device_move
000000000000009c l     O __ksymtab_strings	000000000000000f __kstrtab_device_destroy
00000000000000ab l     O __ksymtab_strings	000000000000001a __kstrtab_device_create_with_groups
00000000000000d3 l     O __ksymtab_strings	0000000000000014 __kstrtab_device_create_vargs
00000000000000e7 l     O __ksymtab_strings	0000000000000017 __kstrtab_root_device_unregister
00000000000000fe l     O __ksymtab_strings	0000000000000017 __kstrtab___root_device_register
0000000000000127 l     O __ksymtab_strings	000000000000001e __kstrtab_device_for_each_child_reverse
0000000000000145 l     O __ksymtab_strings	0000000000000016 __kstrtab_device_for_each_child
000000000000015b l     O __ksymtab_strings	0000000000000012 __kstrtab_device_unregister
0000000000000178 l     O __ksymtab_strings	000000000000000b __kstrtab_put_device
0000000000000183 l     O __ksymtab_strings	000000000000000b __kstrtab_get_device
000000000000018e l     O __ksymtab_strings	0000000000000010 __kstrtab_device_register
000000000000019e l     O __ksymtab_strings	000000000000000b __kstrtab_device_add
00000000000001a9 l     O __ksymtab_strings	000000000000000d __kstrtab_dev_set_name
00000000000001b6 l     O __ksymtab_strings	0000000000000012 __kstrtab_device_initialize
00000000000001c8 l     O __ksymtab_strings	0000000000000017 __kstrtab_device_remove_bin_file
00000000000001df l     O __ksymtab_strings	0000000000000017 __kstrtab_device_create_bin_file
000000000000020e l     O __ksymtab_strings	0000000000000013 __kstrtab_device_remove_file
0000000000000221 l     O __ksymtab_strings	0000000000000013 __kstrtab_device_create_file
0000000000000234 l     O __ksymtab_strings	0000000000000011 __kstrtab_device_show_bool
0000000000000245 l     O __ksymtab_strings	0000000000000012 __kstrtab_device_store_bool
0000000000000257 l     O __ksymtab_strings	0000000000000010 __kstrtab_device_show_int
0000000000000267 l     O __ksymtab_strings	0000000000000011 __kstrtab_device_store_int
0000000000000278 l     O __ksymtab_strings	0000000000000012 __kstrtab_device_show_ulong
000000000000028a l     O __ksymtab_strings	0000000000000013 __kstrtab_device_store_ulong
0000000000000000 l    d  ___ksymtab_gpl+device_add	0000000000000000 ___ksymtab_gpl+device_add
0000000000000000 l    d  ___ksymtab_gpl+device_move	0000000000000000 ___ksymtab_gpl+device_move
0000000000000000 l    d  ___ksymtab_gpl+device_for_each_child_reverse	0000000000000000 ___ksymtab_gpl+device_for_each_child_reverse
0000000000000000 l     O .data	0000000000000028 device_ktype
0000000000000028 l     O .data	0000000000000020 dev_attr_online
0000000000000048 l     O .data	0000000000000028 gdp_mutex
0000000000000070 l     O .data	0000000000000020 dev_attr_dev
0000000000000090 l     O .data	0000000000000020 dev_attr_uevent
00000000000000b0 l     O .data	0000000000000028 device_hotplug_lock
00000000000000d8 l     O .data	0000000000000028 class_dir_ktype
0000000000000000 l    d  ___ksymtab_gpl+device_show_int	0000000000000000 ___ksymtab_gpl+device_show_int
0000000000000000 l    d  .rodata.str1.8	0000000000000000 .rodata.str1.8
0000000000000000 l    d  ___ksymtab_gpl+set_primary_fwnode	0000000000000000 ___ksymtab_gpl+set_primary_fwnode
0000000000000000 l    d  ___ksymtab_gpl+device_remove_file	0000000000000000 ___ksymtab_gpl+device_remove_file
0000000000000000 l    d  ___ksymtab+dev_crit	0000000000000000 ___ksymtab+dev_crit
0000000000000000 l    d  ___ksymtab+dev_printk	0000000000000000 ___ksymtab+dev_printk
0000000000000000 l    d  ___ksymtab+dev_warn	0000000000000000 ___ksymtab+dev_warn
0000000000000000 l    d  ___ksymtab_gpl+device_create_file	0000000000000000 ___ksymtab_gpl+device_create_file
0000000000000000 l    d  __verbose	0000000000000000 __verbose
0000000000000000 l     O __verbose	0000000000000028 descriptor.42633
0000000000000028 l     O __verbose	0000000000000028 descriptor.42726
0000000000000050 l     O __verbose	0000000000000028 descriptor.42488
0000000000000078 l     O __verbose	0000000000000028 descriptor.42239
00000000000000a0 l     O __verbose	0000000000000028 descriptor.42749
00000000000000c8 l     O __verbose	0000000000000028 descriptor.42234
00000000000000f0 l     O __verbose	0000000000000028 descriptor.42228
0000000000000118 l     O __verbose	0000000000000028 descriptor.42422
0000000000000140 l     O __verbose	0000000000000028 descriptor.42113
0000000000000168 l     O __verbose	0000000000000028 descriptor.42115
0000000000000190 l     O __verbose	0000000000000028 descriptor.42116
0000000000000000 l    d  ___ksymtab_gpl+root_device_unregister	0000000000000000 ___ksymtab_gpl+root_device_unregister
0000000000000000 l    d  ___ksymtab+_dev_info	0000000000000000 ___ksymtab+_dev_info
0000000000000000 l    d  ___ksymtab_gpl+device_show_bool	0000000000000000 ___ksymtab_gpl+device_show_bool
0000000000000008 l     O .bss	0000000000000000 __key.42314
0000000000000018 l     O .bss	0000000000000008 virtual_dir.42324
0000000000000028 l     O .bss	0000000000000008 dev_kobj
0000000000000000 l    d  ___ksymtab_gpl+device_register	0000000000000000 ___ksymtab_gpl+device_register
0000000000000000 l    d  ___ksymtab_gpl+device_for_each_child	0000000000000000 ___ksymtab_gpl+device_for_each_child
0000000000000000 l    d  ___ksymtab_gpl+dev_set_name	0000000000000000 ___ksymtab_gpl+dev_set_name
0000000000000000 l    d  ___ksymtab_gpl+device_create_bin_file	0000000000000000 ___ksymtab_gpl+device_create_bin_file
0000000000000000 l    d  ___ksymtab_gpl+device_create_vargs	0000000000000000 ___ksymtab_gpl+device_create_vargs
0000000000000000 l    d  ___ksymtab_gpl+device_remove_bin_file	0000000000000000 ___ksymtab_gpl+device_remove_bin_file
0000000000000000 l    d  ___ksymtab_gpl+__root_device_register	0000000000000000 ___ksymtab_gpl+__root_device_register
0000000000000000 l    d  ___ksymtab_gpl+device_store_ulong	0000000000000000 ___ksymtab_gpl+device_store_ulong
0000000000000000 l    d  ___ksymtab_gpl+get_device	0000000000000000 ___ksymtab_gpl+get_device
0000000000000000 l    d  ___ksymtab_gpl+put_device	0000000000000000 ___ksymtab_gpl+put_device
0000000000000000 l    d  ___ksymtab+dev_err	0000000000000000 ___ksymtab+dev_err
0000000000000000 l    d  ___ksymtab+dev_printk_emit	0000000000000000 ___ksymtab+dev_printk_emit
0000000000000000 l    d  ___ksymtab_gpl+device_show_ulong	0000000000000000 ___ksymtab_gpl+device_show_ulong
0000000000000000 l    d  ___ksymtab_gpl+device_unregister	0000000000000000 ___ksymtab_gpl+device_unregister
0000000000000000 l    d  ___ksymtab_gpl+device_destroy	0000000000000000 ___ksymtab_gpl+device_destroy
0000000000000000 l    d  ___ksymtab+dev_vprintk_emit	0000000000000000 ___ksymtab+dev_vprintk_emit
0000000000000000 l    d  ___ksymtab+dev_alert	0000000000000000 ___ksymtab+dev_alert
0000000000000000 l    d  ___ksymtab_gpl+device_initialize	0000000000000000 ___ksymtab_gpl+device_initialize
0000000000000000 l    d  ___ksymtab_gpl+device_store_bool	0000000000000000 ___ksymtab_gpl+device_store_bool
0000000000000000 l    d  ___ksymtab_gpl+device_create_with_groups	0000000000000000 ___ksymtab_gpl+device_create_with_groups
0000000000000000 l    d  ___ksymtab+dev_emerg	0000000000000000 ___ksymtab+dev_emerg
0000000000000000 l    d  ___ksymtab_gpl+device_store_int	0000000000000000 ___ksymtab_gpl+device_store_int
0000000000000000 l    d  ___ksymtab+dev_notice	0000000000000000 ___ksymtab+dev_notice
0000000000000000 l    d  .debug_info	0000000000000000 .debug_info
0000000000000000 l    d  .debug_abbrev	0000000000000000 .debug_abbrev
0000000000000000 l    d  .debug_loc	0000000000000000 .debug_loc
0000000000000000 l    d  .debug_aranges	0000000000000000 .debug_aranges
0000000000000000 l    d  .debug_ranges	0000000000000000 .debug_ranges
0000000000000000 l    d  .debug_line	0000000000000000 .debug_line
0000000000000000 l    d  .debug_str	0000000000000000 .debug_str
0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack
0000000000000000 l    d  .debug_frame	0000000000000000 .debug_frame
0000000000000000 l       .rodata.str	0000000000000000 .L21
0000000000000014 l       .rodata.str	0000000000000000 .L22
0000000000000028 l       .rodata.str	0000000000000000 .L23
000000000000003c l       .rodata.str	0000000000000000 .L24
0000000000000050 l       .rodata.str	0000000000000000 .L25
0000000000000000 l    d  .comment	0000000000000000 .comment
00000000000000b8 g     F .text	0000000000000058 device_store_ulong
0000000000000000         *UND*	0000000000000000 simple_strtoul
0000000000000110 g     F .text	0000000000000030 device_show_ulong
0000000000000000         *UND*	0000000000000000 snprintf
0000000000000140 g     F .text	0000000000000030 device_show_int
0000000000000170 g     F .text	0000000000000030 device_show_bool
00000000000001a0 g     F .text	000000000000006c device_store_int
0000000000000000         *UND*	0000000000000000 simple_strtol
000000000000020c g     F .text	0000000000000030 device_store_bool
0000000000000000         *UND*	0000000000000000 strtobool
000000000000023c g     F .text	00000000000000a4 device_create_file
0000000000000000         *UND*	0000000000000000 sysfs_create_file_ns
0000000000000000         *UND*	0000000000000000 printk
00000000000002e0 g     F .text	0000000000000020 device_remove_file
0000000000000000         *UND*	0000000000000000 sysfs_remove_file_ns
0000000000000000         *UND*	0000000000000000 sysfs_remove_groups
000000000000037c g     F .text	000000000000002c device_remove_file_self
0000000000000000         *UND*	0000000000000000 sysfs_remove_file_self
00000000000003a8 g     F .text	0000000000000024 device_create_bin_file
0000000000000000         *UND*	0000000000000000 sysfs_create_bin_file
00000000000003cc g     F .text	000000000000001c device_remove_bin_file
0000000000000000         *UND*	0000000000000000 sysfs_remove_bin_file
0000000000000000         *UND*	0000000000000000 devres_release_all
0000000000000000         *UND*	0000000000000000 kfree
0000000000000000         *UND*	0000000000000000 __dynamic_pr_debug
0000000000000510 g     F .text	00000000000000a8 device_initialize
0000000000000000         *UND*	0000000000000000 kobject_init
0000000000000000         *UND*	0000000000000000 __mutex_init
0000000000000000         *UND*	0000000000000000 device_pm_sleep_init
0000000000000000         *UND*	0000000000000000 pm_runtime_init
00000000000005b8 g     F .text	0000000000000064 dev_set_name
0000000000000000         *UND*	0000000000000000 kobject_set_name_vargs
0000000000000000         *UND*	0000000000000000 sprintf
0000000000000000         *UND*	0000000000000000 kmalloc_caches
0000000000000000         *UND*	0000000000000000 kmem_cache_alloc
0000000000000000         *UND*	0000000000000000 mutex_lock
0000000000000000         *UND*	0000000000000000 mutex_unlock
00000000000007bc g     F .text	0000000000000028 get_device
0000000000000000         *UND*	0000000000000000 kobject_get
0000000000000804 g     F .text	000000000000001c put_device
0000000000000000         *UND*	0000000000000000 kobject_put
0000000000000000         *UND*	0000000000000000 sysfs_remove_link
0000000000000000         *UND*	0000000000000000 part_type
0000000000000000         *UND*	0000000000000000 sysfs_delete_link
00000000000008e0 g     F .text	0000000000000088 device_for_each_child
0000000000000000         *UND*	0000000000000000 klist_iter_init
0000000000000000         *UND*	0000000000000000 klist_next
0000000000000000         *UND*	0000000000000000 klist_iter_exit
0000000000000968 g     F .text	000000000000008c device_find_child
00000000000009f4 g     F .text	0000000000000088 device_for_each_child_reverse
0000000000000000         *UND*	0000000000000000 klist_prev
0000000000000a7c g     F .text	000000000000011c device_rename
0000000000000000         *UND*	0000000000000000 kstrdup
0000000000000000         *UND*	0000000000000000 kobject_namespace
0000000000000000         *UND*	0000000000000000 sysfs_rename_link_ns
0000000000000000         *UND*	0000000000000000 kobject_rename
0000000000000000         *UND*	0000000000000000 __dynamic_dev_dbg
0000000000000bc4 g     F .text	0000000000000028 dev_driver_string
0000000000000000         *UND*	0000000000000000 __print_symbol
0000000000000c64 g     F .text	000000000000005c set_primary_fwnode
0000000000000d24 g     F .text	0000000000000208 device_del
0000000000000000         *UND*	0000000000000000 blocking_notifier_call_chain
0000000000000000         *UND*	0000000000000000 dpm_sysfs_remove
0000000000000000         *UND*	0000000000000000 klist_del
0000000000000000         *UND*	0000000000000000 bus_remove_device
0000000000000000         *UND*	0000000000000000 device_pm_remove
0000000000000000         *UND*	0000000000000000 driver_deferred_probe_del
0000000000000000         *UND*	0000000000000000 kobject_uevent
0000000000000000         *UND*	0000000000000000 kobject_del
0000000000000000         *UND*	0000000000000000 devtmpfs_delete_node
0000000000000f2c g     F .text	0000000000000074 device_unregister
0000000000000fa0 g     F .text	000000000000003c root_device_unregister
0000000000000fdc g     F .text	0000000000000048 device_destroy
0000000000000000         *UND*	0000000000000000 class_find_device
0000000000001080 g     F .text	00000000000001d4 dev_vprintk_emit
0000000000000000         *UND*	0000000000000000 strcmp
0000000000000000         *UND*	0000000000000000 vprintk_emit
0000000000001254 g     F .text	000000000000005c dev_printk_emit
0000000000001338 g     F .text	0000000000000058 dev_printk
0000000000001390 g     F .text	0000000000000068 dev_emerg
00000000000013f8 g     F .text	0000000000000068 dev_alert
0000000000001460 g     F .text	0000000000000068 dev_crit
00000000000014c8 g     F .text	0000000000000068 dev_err
0000000000000000         *UND*	0000000000000000 kobject_action_type
0000000000001598 g     F .text	0000000000000068 dev_warn
0000000000001600 g     F .text	0000000000000068 dev_notice
0000000000001668 g     F .text	0000000000000068 _dev_info
00000000000016d0 g     F .text	0000000000000020 lock_device_hotplug
00000000000016f0 g     F .text	0000000000000020 unlock_device_hotplug
0000000000001710 g     F .text	0000000000000050 lock_device_hotplug_sysfs
0000000000000000         *UND*	0000000000000000 mutex_trylock
0000000000000000         *UND*	0000000000000000 msleep
0000000000000000         *UND*	0000000000000000 set_bit
0000000000001760 g     F .text	0000000000000018 device_add_groups
0000000000000000         *UND*	0000000000000000 sysfs_create_groups
0000000000001778 g     F .text	0000000000000018 device_remove_groups
0000000000001790 g     F .text	00000000000000a4 devices_kset_move_last
0000000000000000         *UND*	0000000000000000 _raw_spin_lock
0000000000000000         *UND*	0000000000000000 _raw_spin_unlock
0000000000001834 g     F .text	000000000000004c virtual_device_parent
0000000000000000         *UND*	0000000000000000 kobject_create_and_add
0000000000000000         *UND*	0000000000000000 kobject_add
0000000000001a14 g     F .text	00000000000003f4 device_move
0000000000000000         *UND*	0000000000000000 device_pm_lock
0000000000000000         *UND*	0000000000000000 kobject_move
0000000000000000         *UND*	0000000000000000 klist_remove
0000000000000000         *UND*	0000000000000000 klist_add_tail
0000000000000000         *UND*	0000000000000000 sysfs_create_link
0000000000000000         *UND*	0000000000000000 device_pm_unlock
0000000000000000         *UND*	0000000000000000 device_pm_move_before
0000000000000000         *UND*	0000000000000000 device_pm_move_after
0000000000000000         *UND*	0000000000000000 device_pm_move_last
0000000000001e08 g     F .text	0000000000000070 device_private_init
0000000000000000         *UND*	0000000000000000 klist_init
0000000000001e78 g     F .text	0000000000000574 device_add
0000000000000000         *UND*	0000000000000000 bus_add_device
0000000000000000         *UND*	0000000000000000 dpm_sysfs_add
0000000000000000         *UND*	0000000000000000 device_pm_add
0000000000000000         *UND*	0000000000000000 bus_probe_device
0000000000000000         *UND*	0000000000000000 devtmpfs_create_node
00000000000023ec g     F .text	0000000000000028 device_register
0000000000002414 g     F .text	0000000000000110 __root_device_register
0000000000002654 g     F .text	0000000000000034 device_create_vargs
0000000000002688 g     F .text	0000000000000064 device_create
00000000000026ec g     F .text	0000000000000050 device_create_with_groups
000000000000273c g     F .text	0000000000000108 device_get_devnode
0000000000000000         *UND*	0000000000000000 strchr
0000000000000000         *UND*	0000000000000000 strreplace
0000000000000000         *UND*	0000000000000000 add_uevent_var
0000000000000000         *UND*	0000000000000000 of_device_uevent
0000000000000000 g     F .init.text	00000000000000bc devices_init
0000000000000000         *UND*	0000000000000000 kset_create_and_add
0000000000000000         *UND*	0000000000000000 kset_unregister
0000000000002ad8 g     F .text	00000000000000c4 device_offline
0000000000002b9c g     F .text	00000000000000ac device_online
0000000000002cd0 g     F .text	00000000000001a8 device_shutdown
0000000000000000         *UND*	0000000000000000 initcall_debug
0000000000000000         *UND*	0000000000000000 pm_runtime_barrier
0000000000002e78 g     F .text	0000000000000030 set_secondary_fwnode
0000000000000000 g     O ___ksymtab_gpl+set_primary_fwnode	0000000000000010 __ksymtab_set_primary_fwnode
0000000000000000 g     O ___ksymtab+_dev_info	0000000000000010 __ksymtab__dev_info
0000000000000000 g     O ___ksymtab+dev_notice	0000000000000010 __ksymtab_dev_notice
0000000000000000 g     O ___ksymtab+dev_warn	0000000000000010 __ksymtab_dev_warn
0000000000000000 g     O ___ksymtab+dev_err	0000000000000010 __ksymtab_dev_err
0000000000000000 g     O ___ksymtab+dev_crit	0000000000000010 __ksymtab_dev_crit
0000000000000000 g     O ___ksymtab+dev_alert	0000000000000010 __ksymtab_dev_alert
0000000000000000 g     O ___ksymtab+dev_emerg	0000000000000010 __ksymtab_dev_emerg
0000000000000000 g     O ___ksymtab+dev_printk	0000000000000010 __ksymtab_dev_printk
0000000000000000 g     O ___ksymtab+dev_printk_emit	0000000000000010 __ksymtab_dev_printk_emit
0000000000000000 g     O ___ksymtab+dev_vprintk_emit	0000000000000010 __ksymtab_dev_vprintk_emit
0000000000000000 g     O ___ksymtab_gpl+device_move	0000000000000010 __ksymtab_device_move
0000000000000000 g     O ___ksymtab_gpl+device_rename	0000000000000010 __ksymtab_device_rename
0000000000000000 g     O ___ksymtab_gpl+device_destroy	0000000000000010 __ksymtab_device_destroy
0000000000000000 g     O ___ksymtab_gpl+device_create_with_groups	0000000000000010 __ksymtab_device_create_with_groups
0000000000000000 g     O ___ksymtab_gpl+device_create	0000000000000010 __ksymtab_device_create
0000000000000000 g     O ___ksymtab_gpl+device_create_vargs	0000000000000010 __ksymtab_device_create_vargs
0000000000000000 g     O ___ksymtab_gpl+root_device_unregister	0000000000000010 __ksymtab_root_device_unregister
0000000000000000 g     O ___ksymtab_gpl+__root_device_register	0000000000000010 __ksymtab___root_device_register
0000000000000000 g     O ___ksymtab_gpl+device_find_child	0000000000000010 __ksymtab_device_find_child
0000000000000000 g     O ___ksymtab_gpl+device_for_each_child_reverse	0000000000000010 __ksymtab_device_for_each_child_reverse
0000000000000000 g     O ___ksymtab_gpl+device_for_each_child	0000000000000010 __ksymtab_device_for_each_child
0000000000000000 g     O ___ksymtab_gpl+device_unregister	0000000000000010 __ksymtab_device_unregister
0000000000000000 g     O ___ksymtab_gpl+device_del	0000000000000010 __ksymtab_device_del
0000000000000000 g     O ___ksymtab_gpl+put_device	0000000000000010 __ksymtab_put_device
0000000000000000 g     O ___ksymtab_gpl+get_device	0000000000000010 __ksymtab_get_device
0000000000000000 g     O ___ksymtab_gpl+device_register	0000000000000010 __ksymtab_device_register
0000000000000000 g     O ___ksymtab_gpl+device_add	0000000000000010 __ksymtab_device_add
0000000000000000 g     O ___ksymtab_gpl+dev_set_name	0000000000000010 __ksymtab_dev_set_name
0000000000000000 g     O ___ksymtab_gpl+device_initialize	0000000000000010 __ksymtab_device_initialize
0000000000000000 g     O ___ksymtab_gpl+device_remove_bin_file	0000000000000010 __ksymtab_device_remove_bin_file
0000000000000000 g     O ___ksymtab_gpl+device_create_bin_file	0000000000000010 __ksymtab_device_create_bin_file
0000000000000000 g     O ___ksymtab_gpl+device_remove_file_self	0000000000000010 __ksymtab_device_remove_file_self
0000000000000000 g     O ___ksymtab_gpl+device_remove_file	0000000000000010 __ksymtab_device_remove_file
0000000000000000 g     O ___ksymtab_gpl+device_create_file	0000000000000010 __ksymtab_device_create_file
0000000000000000 g     O .bss	0000000000000008 devices_kset
0000000000000000 g     O ___ksymtab_gpl+device_show_bool	0000000000000010 __ksymtab_device_show_bool
0000000000000000 g     O ___ksymtab_gpl+device_store_bool	0000000000000010 __ksymtab_device_store_bool
0000000000000000 g     O ___ksymtab_gpl+device_show_int	0000000000000010 __ksymtab_device_show_int
0000000000000000 g     O ___ksymtab_gpl+device_store_int	0000000000000010 __ksymtab_device_store_int
0000000000000000 g     O ___ksymtab_gpl+device_show_ulong	0000000000000010 __ksymtab_device_show_ulong
0000000000000000 g     O ___ksymtab_gpl+device_store_ulong	0000000000000010 __ksymtab_device_store_ulong
0000000000000000 g     O ___ksymtab+dev_driver_string	0000000000000010 __ksymtab_dev_driver_string
0000000000000030 g     O .bss	0000000000000008 sysfs_dev_block_kobj
0000000000000008 g     O .bss	0000000000000008 sysfs_dev_char_kobj
0000000000000010 g     O .bss	0000000000000008 platform_notify_remove
0000000000000020 g     O .bss	0000000000000008 platform_notify
0000000000000000         *UND*	0000000000000000 kobj_sysfs_ops



Disassembly of section .text:

0000000000000000 <dev_attr_store>:
	return ret;
}

static ssize_t dev_attr_store(struct kobject *kobj, struct attribute *attr,
			      const char *buf, size_t count)
{
       0:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
	bool			offline:1;
};

static inline struct device *kobj_to_dev(struct kobject *kobj)
{
	return container_of(kobj, struct device, kobj);
       4:	d1004000 	sub	x0, x0, #0x10
       8:	910003fd 	mov	x29, sp
	struct device_attribute *dev_attr = to_dev_attr(attr);
	struct device *dev = kobj_to_dev(kobj);
	ssize_t ret = -EIO;

	if (dev_attr->store)
       c:	f9400c24 	ldr	x4, [x1,#24]
      10:	b4000084 	cbz	x4, 20 <dev_attr_store+0x20>
		ret = dev_attr->store(dev, dev_attr, buf, count);
      14:	d63f0080 	blr	x4
	return ret;
}
      18:	a8c17bfd 	ldp	x29, x30, [sp],#16
      1c:	d65f03c0 	ret
static ssize_t dev_attr_store(struct kobject *kobj, struct attribute *attr,
			      const char *buf, size_t count)
{
	struct device_attribute *dev_attr = to_dev_attr(attr);
	struct device *dev = kobj_to_dev(kobj);
	ssize_t ret = -EIO;
      20:	92800080 	mov	x0, #0xfffffffffffffffb    	// #-5
      24:	17fffffd 	b	18 <dev_attr_store+0x18>

0000000000000028 <device_namespace>:
      28:	d1004000 	sub	x0, x0, #0x10
			dev_name(dev));
	kfree(p);
}

static const void *device_namespace(struct kobject *kobj)
{
      2c:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
      30:	910003fd 	mov	x29, sp
	struct device *dev = kobj_to_dev(kobj);
	const void *ns = NULL;

	if (dev->class && dev->class->ns_type)
      34:	f9414c01 	ldr	x1, [x0,#664]
      38:	b40000e1 	cbz	x1, 54 <device_namespace+0x2c>
      3c:	f9402c22 	ldr	x2, [x1,#88]
      40:	b40000a2 	cbz	x2, 54 <device_namespace+0x2c>
		ns = dev->class->namespace(dev);
      44:	f9403021 	ldr	x1, [x1,#96]
      48:	d63f0020 	blr	x1

	return ns;
}
      4c:	a8c17bfd 	ldp	x29, x30, [sp],#16
      50:	d65f03c0 	ret
}

static const void *device_namespace(struct kobject *kobj)
{
	struct device *dev = kobj_to_dev(kobj);
	const void *ns = NULL;
      54:	d2800000 	mov	x0, #0x0                   	// #0
      58:	17fffffd 	b	4c <device_namespace+0x24>

000000000000005c <dev_uevent_filter>:

static int dev_uevent_filter(struct kset *kset, struct kobject *kobj)
{
	struct kobj_type *ktype = get_ktype(kobj);

	if (ktype == &device_ktype) {
      5c:	f9401423 	ldr	x3, [x1,#40]
      60:	90000002 	adrp	x2, 0 <dev_attr_store>
			60: R_AARCH64_ADR_PREL_PG_HI21	.data
      64:	91000042 	add	x2, x2, #0x0
			64: R_AARCH64_ADD_ABS_LO12_NC	.data
		if (dev->bus)
			return 1;
		if (dev->class)
			return 1;
	}
	return 0;
      68:	52800000 	mov	w0, #0x0                   	// #0

static int dev_uevent_filter(struct kset *kset, struct kobject *kobj)
{
	struct kobj_type *ktype = get_ktype(kobj);

	if (ktype == &device_ktype) {
      6c:	eb02007f 	cmp	x3, x2
      70:	54000040 	b.eq	78 <dev_uevent_filter+0x1c>
			return 1;
		if (dev->class)
			return 1;
	}
	return 0;
}
      74:	d65f03c0 	ret
{
	struct kobj_type *ktype = get_ktype(kobj);

	if (ktype == &device_ktype) {
		struct device *dev = kobj_to_dev(kobj);
		if (dev->bus)
      78:	f9403c22 	ldr	x2, [x1,#120]
			return 1;
      7c:	52800020 	mov	w0, #0x1                   	// #1
{
	struct kobj_type *ktype = get_ktype(kobj);

	if (ktype == &device_ktype) {
		struct device *dev = kobj_to_dev(kobj);
		if (dev->bus)
      80:	d1004021 	sub	x1, x1, #0x10
      84:	b5ffff82 	cbnz	x2, 74 <dev_uevent_filter+0x18>
			return 1;
		if (dev->class)
      88:	f9414c20 	ldr	x0, [x1,#664]
      8c:	eb1f001f 	cmp	x0, xzr
      90:	1a9f07e0 	cset	w0, ne
			return 1;
	}
	return 0;
}
      94:	d65f03c0 	ret

0000000000000098 <class_dir_child_ns_type>:

static const
struct kobj_ns_type_operations *class_dir_child_ns_type(struct kobject *kobj)
{
	struct class_dir *dir = to_class_dir(kobj);
	return dir->class->ns_type;
      98:	f9402000 	ldr	x0, [x0,#64]
}
      9c:	f9402c00 	ldr	x0, [x0,#88]
      a0:	d65f03c0 	ret

00000000000000a4 <__match_devt>:

static int __match_devt(struct device *dev, const void *data)
{
	const dev_t *devt = data;

	return dev->devt == *devt;
      a4:	b9425802 	ldr	w2, [x0,#600]
      a8:	b9400020 	ldr	w0, [x1]
      ac:	6b00005f 	cmp	w2, w0
}
      b0:	1a9f17e0 	cset	w0, eq
      b4:	d65f03c0 	ret

00000000000000b8 <device_store_ulong>:
#define to_ext_attr(x) container_of(x, struct dev_ext_attribute, attr)

ssize_t device_store_ulong(struct device *dev,
			   struct device_attribute *attr,
			   const char *buf, size_t size)
{
      b8:	a9bc7bfd 	stp	x29, x30, [sp,#-64]!
      bc:	910003fd 	mov	x29, sp
      c0:	a90153f3 	stp	x19, x20, [sp,#16]
      c4:	aa0203f3 	mov	x19, x2
      c8:	aa0103f4 	mov	x20, x1
	struct dev_ext_attribute *ea = to_ext_attr(attr);
	char *end;
	unsigned long new = simple_strtoul(buf, &end, 0);
      cc:	52800002 	mov	w2, #0x0                   	// #0
      d0:	9100e3a1 	add	x1, x29, #0x38
      d4:	aa1303e0 	mov	x0, x19
#define to_ext_attr(x) container_of(x, struct dev_ext_attribute, attr)

ssize_t device_store_ulong(struct device *dev,
			   struct device_attribute *attr,
			   const char *buf, size_t size)
{
      d8:	f90017a3 	str	x3, [x29,#40]
	struct dev_ext_attribute *ea = to_ext_attr(attr);
	char *end;
	unsigned long new = simple_strtoul(buf, &end, 0);
      dc:	94000000 	bl	0 <simple_strtoul>
			dc: R_AARCH64_CALL26	simple_strtoul
	if (end == buf)
      e0:	f9401fa2 	ldr	x2, [x29,#56]
      e4:	eb13005f 	cmp	x2, x19
      e8:	54000100 	b.eq	108 <device_store_ulong+0x50>
		return -EINVAL;
	*(unsigned long *)(ea->var) = new;
      ec:	f9401281 	ldr	x1, [x20,#32]
	/* Always return full write size even if we didn't consume all */
	return size;
      f0:	f94017a3 	ldr	x3, [x29,#40]
	struct dev_ext_attribute *ea = to_ext_attr(attr);
	char *end;
	unsigned long new = simple_strtoul(buf, &end, 0);
	if (end == buf)
		return -EINVAL;
	*(unsigned long *)(ea->var) = new;
      f4:	f9000020 	str	x0, [x1]
	/* Always return full write size even if we didn't consume all */
	return size;
}
      f8:	aa0303e0 	mov	x0, x3
      fc:	a94153f3 	ldp	x19, x20, [sp,#16]
     100:	a8c47bfd 	ldp	x29, x30, [sp],#64
     104:	d65f03c0 	ret
{
	struct dev_ext_attribute *ea = to_ext_attr(attr);
	char *end;
	unsigned long new = simple_strtoul(buf, &end, 0);
	if (end == buf)
		return -EINVAL;
     108:	928002a3 	mov	x3, #0xffffffffffffffea    	// #-22
     10c:	17fffffb 	b	f8 <device_store_ulong+0x40>

0000000000000110 <device_show_ulong>:
EXPORT_SYMBOL_GPL(device_store_ulong);

ssize_t device_show_ulong(struct device *dev,
			  struct device_attribute *attr,
			  char *buf)
{
     110:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     114:	aa0203e0 	mov	x0, x2
	struct dev_ext_attribute *ea = to_ext_attr(attr);
	return snprintf(buf, PAGE_SIZE, "%lx\n", *(unsigned long *)(ea->var));
     118:	90000002 	adrp	x2, 0 <dev_attr_store>
			118: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8
EXPORT_SYMBOL_GPL(device_store_ulong);

ssize_t device_show_ulong(struct device *dev,
			  struct device_attribute *attr,
			  char *buf)
{
     11c:	910003fd 	mov	x29, sp
	struct dev_ext_attribute *ea = to_ext_attr(attr);
	return snprintf(buf, PAGE_SIZE, "%lx\n", *(unsigned long *)(ea->var));
     120:	f9401023 	ldr	x3, [x1,#32]
     124:	91000042 	add	x2, x2, #0x0
			124: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8
     128:	d2820001 	mov	x1, #0x1000                	// #4096
     12c:	f9400063 	ldr	x3, [x3]
     130:	94000000 	bl	0 <snprintf>
			130: R_AARCH64_CALL26	snprintf
}
     134:	93407c00 	sxtw	x0, w0
     138:	a8c17bfd 	ldp	x29, x30, [sp],#16
     13c:	d65f03c0 	ret

0000000000000140 <device_show_int>:
EXPORT_SYMBOL_GPL(device_store_int);

ssize_t device_show_int(struct device *dev,
			struct device_attribute *attr,
			char *buf)
{
     140:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     144:	aa0203e0 	mov	x0, x2
	struct dev_ext_attribute *ea = to_ext_attr(attr);

	return snprintf(buf, PAGE_SIZE, "%d\n", *(int *)(ea->var));
     148:	90000002 	adrp	x2, 0 <dev_attr_store>
			148: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x8
EXPORT_SYMBOL_GPL(device_store_int);

ssize_t device_show_int(struct device *dev,
			struct device_attribute *attr,
			char *buf)
{
     14c:	910003fd 	mov	x29, sp
	struct dev_ext_attribute *ea = to_ext_attr(attr);

	return snprintf(buf, PAGE_SIZE, "%d\n", *(int *)(ea->var));
     150:	f9401023 	ldr	x3, [x1,#32]
     154:	91000042 	add	x2, x2, #0x0
			154: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x8
     158:	d2820001 	mov	x1, #0x1000                	// #4096
     15c:	b9400063 	ldr	w3, [x3]
     160:	94000000 	bl	0 <snprintf>
			160: R_AARCH64_CALL26	snprintf
}
     164:	93407c00 	sxtw	x0, w0
     168:	a8c17bfd 	ldp	x29, x30, [sp],#16
     16c:	d65f03c0 	ret

0000000000000170 <device_show_bool>:
}
EXPORT_SYMBOL_GPL(device_store_bool);

ssize_t device_show_bool(struct device *dev, struct device_attribute *attr,
			 char *buf)
{
     170:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     174:	aa0203e0 	mov	x0, x2
	struct dev_ext_attribute *ea = to_ext_attr(attr);

	return snprintf(buf, PAGE_SIZE, "%d\n", *(bool *)(ea->var));
     178:	90000002 	adrp	x2, 0 <dev_attr_store>
			178: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x8
}
EXPORT_SYMBOL_GPL(device_store_bool);

ssize_t device_show_bool(struct device *dev, struct device_attribute *attr,
			 char *buf)
{
     17c:	910003fd 	mov	x29, sp
	struct dev_ext_attribute *ea = to_ext_attr(attr);

	return snprintf(buf, PAGE_SIZE, "%d\n", *(bool *)(ea->var));
     180:	f9401023 	ldr	x3, [x1,#32]
     184:	91000042 	add	x2, x2, #0x0
			184: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x8
     188:	d2820001 	mov	x1, #0x1000                	// #4096
     18c:	39400063 	ldrb	w3, [x3]
     190:	94000000 	bl	0 <snprintf>
			190: R_AARCH64_CALL26	snprintf
}
     194:	93407c00 	sxtw	x0, w0
     198:	a8c17bfd 	ldp	x29, x30, [sp],#16
     19c:	d65f03c0 	ret

00000000000001a0 <device_store_int>:
EXPORT_SYMBOL_GPL(device_show_ulong);

ssize_t device_store_int(struct device *dev,
			 struct device_attribute *attr,
			 const char *buf, size_t size)
{
     1a0:	a9bc7bfd 	stp	x29, x30, [sp,#-64]!
     1a4:	910003fd 	mov	x29, sp
     1a8:	a90153f3 	stp	x19, x20, [sp,#16]
     1ac:	aa0203f3 	mov	x19, x2
     1b0:	aa0103f4 	mov	x20, x1
	struct dev_ext_attribute *ea = to_ext_attr(attr);
	char *end;
	long new = simple_strtol(buf, &end, 0);
     1b4:	52800002 	mov	w2, #0x0                   	// #0
     1b8:	9100e3a1 	add	x1, x29, #0x38
     1bc:	aa1303e0 	mov	x0, x19
EXPORT_SYMBOL_GPL(device_show_ulong);

ssize_t device_store_int(struct device *dev,
			 struct device_attribute *attr,
			 const char *buf, size_t size)
{
     1c0:	f90017a3 	str	x3, [x29,#40]
	struct dev_ext_attribute *ea = to_ext_attr(attr);
	char *end;
	long new = simple_strtol(buf, &end, 0);
     1c4:	94000000 	bl	0 <simple_strtol>
			1c4: R_AARCH64_CALL26	simple_strtol
	if (end == buf || new > INT_MAX || new < INT_MIN)
     1c8:	f9401fa2 	ldr	x2, [x29,#56]
     1cc:	eb13005f 	cmp	x2, x19
     1d0:	540001a0 	b.eq	204 <device_store_int+0x64>
     1d4:	d2b00002 	mov	x2, #0x80000000            	// #2147483648
     1d8:	b2407fe4 	mov	x4, #0xffffffff            	// #4294967295
     1dc:	8b020002 	add	x2, x0, x2
     1e0:	eb04005f 	cmp	x2, x4
     1e4:	54000108 	b.hi	204 <device_store_int+0x64>
		return -EINVAL;
	*(int *)(ea->var) = new;
     1e8:	f9401281 	ldr	x1, [x20,#32]
	/* Always return full write size even if we didn't consume all */
	return size;
     1ec:	f94017a3 	ldr	x3, [x29,#40]
	struct dev_ext_attribute *ea = to_ext_attr(attr);
	char *end;
	long new = simple_strtol(buf, &end, 0);
	if (end == buf || new > INT_MAX || new < INT_MIN)
		return -EINVAL;
	*(int *)(ea->var) = new;
     1f0:	b9000020 	str	w0, [x1]
	/* Always return full write size even if we didn't consume all */
	return size;
}
     1f4:	aa0303e0 	mov	x0, x3
     1f8:	a94153f3 	ldp	x19, x20, [sp,#16]
     1fc:	a8c47bfd 	ldp	x29, x30, [sp],#64
     200:	d65f03c0 	ret
{
	struct dev_ext_attribute *ea = to_ext_attr(attr);
	char *end;
	long new = simple_strtol(buf, &end, 0);
	if (end == buf || new > INT_MAX || new < INT_MIN)
		return -EINVAL;
     204:	928002a3 	mov	x3, #0xffffffffffffffea    	// #-22
     208:	17fffffb 	b	1f4 <device_store_int+0x54>

000000000000020c <device_store_bool>:
}
EXPORT_SYMBOL_GPL(device_show_int);

ssize_t device_store_bool(struct device *dev, struct device_attribute *attr,
			  const char *buf, size_t size)
{
     20c:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
	struct dev_ext_attribute *ea = to_ext_attr(attr);

	if (strtobool(buf, ea->var) < 0)
     210:	aa0203e0 	mov	x0, x2
}
EXPORT_SYMBOL_GPL(device_show_int);

ssize_t device_store_bool(struct device *dev, struct device_attribute *attr,
			  const char *buf, size_t size)
{
     214:	910003fd 	mov	x29, sp
	struct dev_ext_attribute *ea = to_ext_attr(attr);

	if (strtobool(buf, ea->var) < 0)
     218:	f9401021 	ldr	x1, [x1,#32]
}
EXPORT_SYMBOL_GPL(device_show_int);

ssize_t device_store_bool(struct device *dev, struct device_attribute *attr,
			  const char *buf, size_t size)
{
     21c:	f9000fa3 	str	x3, [x29,#24]
	struct dev_ext_attribute *ea = to_ext_attr(attr);

	if (strtobool(buf, ea->var) < 0)
     220:	94000000 	bl	0 <strtobool>
			220: R_AARCH64_CALL26	strtobool
		return -EINVAL;

	return size;
     224:	6b1f001f 	cmp	w0, wzr
}
     228:	f9400fa3 	ldr	x3, [x29,#24]
     22c:	928002a0 	mov	x0, #0xffffffffffffffea    	// #-22
     230:	a8c27bfd 	ldp	x29, x30, [sp],#32
     234:	9a80a060 	csel	x0, x3, x0, ge
     238:	d65f03c0 	ret

000000000000023c <device_create_file>:
 * @dev: device.
 * @attr: device attribute descriptor.
 */
int device_create_file(struct device *dev,
		       const struct device_attribute *attr)
{
     23c:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
     240:	910003fd 	mov	x29, sp
     244:	a90153f3 	stp	x19, x20, [sp,#16]
	int error = 0;

	if (dev) {
     248:	b4000440 	cbz	x0, 2d0 <device_create_file+0x94>
     24c:	aa0003f4 	mov	x20, x0
		WARN(((attr->attr.mode & S_IWUGO) && !attr->store),
     250:	79401020 	ldrh	w0, [x1,#8]
     254:	aa0103f3 	mov	x19, x1
     258:	52801241 	mov	w1, #0x92                  	// #146
     25c:	6a01001f 	tst	w0, w1
     260:	54000060 	b.eq	26c <device_create_file+0x30>
     264:	f9400e61 	ldr	x1, [x19,#24]
     268:	b4000261 	cbz	x1, 2b4 <device_create_file+0x78>
			"Attribute %s: write permission without 'store'\n",
			attr->attr.name);
		WARN(((attr->attr.mode & S_IRUGO) && !attr->show),
     26c:	52802481 	mov	w1, #0x124                 	// #292
     270:	6a01001f 	tst	w0, w1
     274:	54000101 	b.ne	294 <device_create_file+0x58>
#endif /* CONFIG_SYSFS */

static inline int __must_check sysfs_create_file(struct kobject *kobj,
						 const struct attribute *attr)
{
	return sysfs_create_file_ns(kobj, attr, NULL);
     278:	aa1303e1 	mov	x1, x19
     27c:	d2800002 	mov	x2, #0x0                   	// #0
     280:	91004280 	add	x0, x20, #0x10
     284:	94000000 	bl	0 <sysfs_create_file_ns>
			284: R_AARCH64_CALL26	sysfs_create_file_ns
			attr->attr.name);
		error = sysfs_create_file(&dev->kobj, &attr->attr);
	}

	return error;
}
     288:	a94153f3 	ldp	x19, x20, [sp,#16]
     28c:	a8c27bfd 	ldp	x29, x30, [sp],#32
     290:	d65f03c0 	ret

	if (dev) {
		WARN(((attr->attr.mode & S_IWUGO) && !attr->store),
			"Attribute %s: write permission without 'store'\n",
			attr->attr.name);
		WARN(((attr->attr.mode & S_IRUGO) && !attr->show),
     294:	f9400a60 	ldr	x0, [x19,#16]
     298:	b5ffff00 	cbnz	x0, 278 <device_create_file+0x3c>
     29c:	f9400261 	ldr	x1, [x19]
     2a0:	90000000 	adrp	x0, 0 <dev_attr_store>
			2a0: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x40
     2a4:	91000000 	add	x0, x0, #0x0
			2a4: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x40
     2a8:	94000000 	bl	0 <printk>
			2a8: R_AARCH64_CALL26	printk
     2ac:	d4210000 	brk	#0x800
     2b0:	17fffff2 	b	278 <device_create_file+0x3c>
		       const struct device_attribute *attr)
{
	int error = 0;

	if (dev) {
		WARN(((attr->attr.mode & S_IWUGO) && !attr->store),
     2b4:	f9400261 	ldr	x1, [x19]
     2b8:	90000000 	adrp	x0, 0 <dev_attr_store>
			2b8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x10
     2bc:	91000000 	add	x0, x0, #0x0
			2bc: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x10
     2c0:	94000000 	bl	0 <printk>
			2c0: R_AARCH64_CALL26	printk
     2c4:	d4210000 	brk	#0x800
     2c8:	79401260 	ldrh	w0, [x19,#8]
     2cc:	17ffffe8 	b	26c <device_create_file+0x30>
 * @attr: device attribute descriptor.
 */
int device_create_file(struct device *dev,
		       const struct device_attribute *attr)
{
	int error = 0;
     2d0:	52800000 	mov	w0, #0x0                   	// #0
			attr->attr.name);
		error = sysfs_create_file(&dev->kobj, &attr->attr);
	}

	return error;
}
     2d4:	a94153f3 	ldp	x19, x20, [sp,#16]
     2d8:	a8c27bfd 	ldp	x29, x30, [sp],#32
     2dc:	d65f03c0 	ret

00000000000002e0 <device_remove_file>:
 * @dev: device.
 * @attr: device attribute descriptor.
 */
void device_remove_file(struct device *dev,
			const struct device_attribute *attr)
{
     2e0:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     2e4:	910003fd 	mov	x29, sp
	if (dev)
     2e8:	b4000080 	cbz	x0, 2f8 <device_remove_file+0x18>
}

static inline void sysfs_remove_file(struct kobject *kobj,
				     const struct attribute *attr)
{
	sysfs_remove_file_ns(kobj, attr, NULL);
     2ec:	d2800002 	mov	x2, #0x0                   	// #0
     2f0:	91004000 	add	x0, x0, #0x10
     2f4:	94000000 	bl	0 <sysfs_remove_file_ns>
			2f4: R_AARCH64_CALL26	sysfs_remove_file_ns
		sysfs_remove_file(&dev->kobj, &attr->attr);
}
     2f8:	a8c17bfd 	ldp	x29, x30, [sp],#16
     2fc:	d65f03c0 	ret

0000000000000300 <device_remove_attrs>:

	return error;
}

static void device_remove_attrs(struct device *dev)
{
     300:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
     304:	910003fd 	mov	x29, sp
     308:	a90153f3 	stp	x19, x20, [sp,#16]
     30c:	a9025bf5 	stp	x21, x22, [sp,#32]
     310:	aa0003f3 	mov	x19, x0
     314:	d2800214 	mov	x20, #0x10                  	// #16
	struct class *class = dev->class;
     318:	f9414c15 	ldr	x21, [x0,#664]
	const struct device_type *type = dev->type;
     31c:	f9402c16 	ldr	x22, [x0,#88]
 * @attr: device attribute descriptor.
 */
void device_remove_file(struct device *dev,
			const struct device_attribute *attr)
{
	if (dev)
     320:	b4000100 	cbz	x0, 340 <device_remove_attrs+0x40>
     324:	90000001 	adrp	x1, 0 <dev_attr_store>
			324: R_AARCH64_ADR_PREL_PG_HI21	.data
		sysfs_remove_file(&dev->kobj, &attr->attr);
     328:	91004014 	add	x20, x0, #0x10
     32c:	91000021 	add	x1, x1, #0x0
			32c: R_AARCH64_ADD_ABS_LO12_NC	.data
     330:	d2800002 	mov	x2, #0x0                   	// #0
     334:	9100a021 	add	x1, x1, #0x28
     338:	aa1403e0 	mov	x0, x20
     33c:	94000000 	bl	0 <sysfs_remove_file_ns>
			33c: R_AARCH64_CALL26	sysfs_remove_file_ns
}

void device_remove_groups(struct device *dev,
			  const struct attribute_group **groups)
{
	sysfs_remove_groups(&dev->kobj, groups);
     340:	f9415261 	ldr	x1, [x19,#672]
     344:	aa1403e0 	mov	x0, x20
     348:	94000000 	bl	0 <sysfs_remove_groups>
			348: R_AARCH64_CALL26	sysfs_remove_groups
	const struct device_type *type = dev->type;

	device_remove_file(dev, &dev_attr_online);
	device_remove_groups(dev, dev->groups);

	if (type)
     34c:	b4000096 	cbz	x22, 35c <device_remove_attrs+0x5c>
}

void device_remove_groups(struct device *dev,
			  const struct attribute_group **groups)
{
	sysfs_remove_groups(&dev->kobj, groups);
     350:	f94006c1 	ldr	x1, [x22,#8]
     354:	aa1403e0 	mov	x0, x20
     358:	94000000 	bl	0 <sysfs_remove_groups>
			358: R_AARCH64_CALL26	sysfs_remove_groups
	device_remove_groups(dev, dev->groups);

	if (type)
		device_remove_groups(dev, type->groups);

	if (class)
     35c:	b4000095 	cbz	x21, 36c <device_remove_attrs+0x6c>
}

void device_remove_groups(struct device *dev,
			  const struct attribute_group **groups)
{
	sysfs_remove_groups(&dev->kobj, groups);
     360:	f9400ea1 	ldr	x1, [x21,#24]
     364:	aa1403e0 	mov	x0, x20
     368:	94000000 	bl	0 <sysfs_remove_groups>
			368: R_AARCH64_CALL26	sysfs_remove_groups
	if (type)
		device_remove_groups(dev, type->groups);

	if (class)
		device_remove_groups(dev, class->dev_groups);
}
     36c:	a94153f3 	ldp	x19, x20, [sp,#16]
     370:	a9425bf5 	ldp	x21, x22, [sp,#32]
     374:	a8c37bfd 	ldp	x29, x30, [sp],#48
     378:	d65f03c0 	ret

000000000000037c <device_remove_file_self>:
 *
 * See kernfs_remove_self() for details.
 */
bool device_remove_file_self(struct device *dev,
			     const struct device_attribute *attr)
{
     37c:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     380:	910003fd 	mov	x29, sp
	if (dev)
     384:	b40000c0 	cbz	x0, 39c <device_remove_file_self+0x20>
		return sysfs_remove_file_self(&dev->kobj, &attr->attr);
     388:	91004000 	add	x0, x0, #0x10
     38c:	94000000 	bl	0 <sysfs_remove_file_self>
			38c: R_AARCH64_CALL26	sysfs_remove_file_self
     390:	53001c00 	uxtb	w0, w0
	else
		return false;
}
     394:	a8c17bfd 	ldp	x29, x30, [sp],#16
     398:	d65f03c0 	ret
			     const struct device_attribute *attr)
{
	if (dev)
		return sysfs_remove_file_self(&dev->kobj, &attr->attr);
	else
		return false;
     39c:	52800000 	mov	w0, #0x0                   	// #0
}
     3a0:	a8c17bfd 	ldp	x29, x30, [sp],#16
     3a4:	d65f03c0 	ret

00000000000003a8 <device_create_bin_file>:
 * @dev: device.
 * @attr: device binary attribute descriptor.
 */
int device_create_bin_file(struct device *dev,
			   const struct bin_attribute *attr)
{
     3a8:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     3ac:	910003fd 	mov	x29, sp
	int error = -EINVAL;
	if (dev)
     3b0:	b40000a0 	cbz	x0, 3c4 <device_create_bin_file+0x1c>
		error = sysfs_create_bin_file(&dev->kobj, attr);
     3b4:	91004000 	add	x0, x0, #0x10
     3b8:	94000000 	bl	0 <sysfs_create_bin_file>
			3b8: R_AARCH64_CALL26	sysfs_create_bin_file
	return error;
}
     3bc:	a8c17bfd 	ldp	x29, x30, [sp],#16
     3c0:	d65f03c0 	ret
 * @attr: device binary attribute descriptor.
 */
int device_create_bin_file(struct device *dev,
			   const struct bin_attribute *attr)
{
	int error = -EINVAL;
     3c4:	128002a0 	mov	w0, #0xffffffea            	// #-22
     3c8:	17fffffd 	b	3bc <device_create_bin_file+0x14>

00000000000003cc <device_remove_bin_file>:
 * @dev: device.
 * @attr: device binary attribute descriptor.
 */
void device_remove_bin_file(struct device *dev,
			    const struct bin_attribute *attr)
{
     3cc:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     3d0:	910003fd 	mov	x29, sp
	if (dev)
     3d4:	b4000060 	cbz	x0, 3e0 <device_remove_bin_file+0x14>
		sysfs_remove_bin_file(&dev->kobj, attr);
     3d8:	91004000 	add	x0, x0, #0x10
     3dc:	94000000 	bl	0 <sysfs_remove_bin_file>
			3dc: R_AARCH64_CALL26	sysfs_remove_bin_file
}
     3e0:	a8c17bfd 	ldp	x29, x30, [sp],#16
     3e4:	d65f03c0 	ret

00000000000003e8 <device_release>:
 * This is called once the reference count for the object
 * reaches 0. We forward the call to the device's release
 * method, which should handle actually freeing the structure.
 */
static void device_release(struct kobject *kobj)
{
     3e8:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
     3ec:	910003fd 	mov	x29, sp
     3f0:	a90153f3 	stp	x19, x20, [sp,#16]
     3f4:	aa0003f4 	mov	x20, x0
     3f8:	d1004013 	sub	x19, x0, #0x10
     3fc:	f90013f5 	str	x21, [sp,#32]
	 *
	 * Drivers still can add resources into device after device
	 * is deleted but alive, so release devres here to avoid
	 * possible memory leak.
	 */
	devres_release_all(dev);
     400:	aa1303e0 	mov	x0, x19
 * method, which should handle actually freeing the structure.
 */
static void device_release(struct kobject *kobj)
{
	struct device *dev = kobj_to_dev(kobj);
	struct device_private *p = dev->p;
     404:	f85f8295 	ldr	x21, [x20,#-8]
	 *
	 * Drivers still can add resources into device after device
	 * is deleted but alive, so release devres here to avoid
	 * possible memory leak.
	 */
	devres_release_all(dev);
     408:	94000000 	bl	0 <devres_release_all>
			408: R_AARCH64_CALL26	devres_release_all

	if (dev->release)
     40c:	f9415661 	ldr	x1, [x19,#680]
     410:	b4000121 	cbz	x1, 434 <device_release+0x4c>
		dev->release(dev);
	else if (dev->type && dev->type->release)
		dev->type->release(dev);
	else if (dev->class && dev->class->dev_release)
		dev->class->dev_release(dev);
     414:	aa1303e0 	mov	x0, x19
     418:	d63f0020 	blr	x1
	else
		WARN(1, KERN_ERR "Device '%s' does not have a release() "
			"function, it is broken and must be fixed.\n",
			dev_name(dev));
	kfree(p);
     41c:	aa1503e0 	mov	x0, x21
     420:	94000000 	bl	0 <kfree>
			420: R_AARCH64_CALL26	kfree
}
     424:	f94013f5 	ldr	x21, [sp,#32]
     428:	a94153f3 	ldp	x19, x20, [sp,#16]
     42c:	a8c37bfd 	ldp	x29, x30, [sp],#48
     430:	d65f03c0 	ret
	 */
	devres_release_all(dev);

	if (dev->release)
		dev->release(dev);
	else if (dev->type && dev->type->release)
     434:	f9402e60 	ldr	x0, [x19,#88]
     438:	b4000060 	cbz	x0, 444 <device_release+0x5c>
     43c:	f9401001 	ldr	x1, [x0,#32]
     440:	b5fffea1 	cbnz	x1, 414 <device_release+0x2c>
		dev->type->release(dev);
	else if (dev->class && dev->class->dev_release)
     444:	f9414e60 	ldr	x0, [x19,#664]
     448:	b4000060 	cbz	x0, 454 <device_release+0x6c>
     44c:	f9402001 	ldr	x1, [x0,#64]
     450:	b5fffe21 	cbnz	x1, 414 <device_release+0x2c>
#include <linux/pm_wakeup.h>

static inline const char *dev_name(const struct device *dev)
{
	/* Use the init name until the kobject becomes available */
	if (dev->init_name)
     454:	f9402a61 	ldr	x1, [x19,#80]
     458:	b40000c1 	cbz	x1, 470 <device_release+0x88>
		dev->class->dev_release(dev);
	else
		WARN(1, KERN_ERR "Device '%s' does not have a release() "
     45c:	90000000 	adrp	x0, 0 <dev_attr_store>
			45c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x70
     460:	91000000 	add	x0, x0, #0x0
			460: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x70
     464:	94000000 	bl	0 <printk>
			464: R_AARCH64_CALL26	printk
     468:	d4210000 	brk	#0x800
     46c:	17ffffec 	b	41c <device_release+0x34>
     470:	f9400281 	ldr	x1, [x20]
     474:	17fffffa 	b	45c <device_release+0x74>

0000000000000478 <class_dir_release>:
};

#define to_class_dir(obj) container_of(obj, struct class_dir, kobj)

static void class_dir_release(struct kobject *kobj)
{
     478:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     47c:	910003fd 	mov	x29, sp
	struct class_dir *dir = to_class_dir(kobj);
	kfree(dir);
     480:	94000000 	bl	0 <kfree>
			480: R_AARCH64_CALL26	kfree
}
     484:	a8c17bfd 	ldp	x29, x30, [sp],#16
     488:	d65f03c0 	ret

000000000000048c <root_device_release>:
{
	return container_of(d, struct root_device, dev);
}

static void root_device_release(struct device *dev)
{
     48c:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     490:	910003fd 	mov	x29, sp
	kfree(to_root_device(dev));
     494:	94000000 	bl	0 <kfree>
			494: R_AARCH64_CALL26	kfree
}
     498:	a8c17bfd 	ldp	x29, x30, [sp],#16
     49c:	d65f03c0 	ret

00000000000004a0 <device_create_release>:
}
EXPORT_SYMBOL_GPL(root_device_unregister);


static void device_create_release(struct device *dev)
{
     4a0:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
     4a4:	90000004 	adrp	x4, 0 <dev_attr_store>
			4a4: R_AARCH64_ADR_PREL_PG_HI21	__verbose
}
EXPORT_SYMBOL_GPL(root_device_unregister);


static void device_create_release(struct device *dev)
{
     4a8:	910003fd 	mov	x29, sp
     4ac:	f9000bf3 	str	x19, [sp,#16]
     4b0:	aa0003f3 	mov	x19, x0
	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
     4b4:	91000080 	add	x0, x4, #0x0
			4b4: R_AARCH64_ADD_ABS_LO12_NC	__verbose
     4b8:	79404400 	ldrh	w0, [x0,#34]
     4bc:	371000c0 	tbnz	w0, #2, 4d4 <device_create_release+0x34>
	kfree(dev);
     4c0:	aa1303e0 	mov	x0, x19
     4c4:	94000000 	bl	0 <kfree>
			4c4: R_AARCH64_CALL26	kfree
}
     4c8:	f9400bf3 	ldr	x19, [sp,#16]
     4cc:	a8c27bfd 	ldp	x29, x30, [sp],#32
     4d0:	d65f03c0 	ret
     4d4:	f9402a62 	ldr	x2, [x19,#80]
     4d8:	b4000182 	cbz	x2, 508 <device_create_release+0x68>
EXPORT_SYMBOL_GPL(root_device_unregister);


static void device_create_release(struct device *dev)
{
	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
     4dc:	90000003 	adrp	x3, 0 <dev_attr_store>
			4dc: R_AARCH64_ADR_PREL_PG_HI21	.rodata
     4e0:	90000001 	adrp	x1, 0 <dev_attr_store>
			4e0: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0xc8
     4e4:	91000080 	add	x0, x4, #0x0
			4e4: R_AARCH64_ADD_ABS_LO12_NC	__verbose
     4e8:	91000063 	add	x3, x3, #0x0
			4e8: R_AARCH64_ADD_ABS_LO12_NC	.rodata
     4ec:	91000021 	add	x1, x1, #0x0
			4ec: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0xc8
     4f0:	94000000 	bl	0 <__dynamic_pr_debug>
			4f0: R_AARCH64_CALL26	__dynamic_pr_debug
	kfree(dev);
     4f4:	aa1303e0 	mov	x0, x19
     4f8:	94000000 	bl	0 <kfree>
			4f8: R_AARCH64_CALL26	kfree
}
     4fc:	f9400bf3 	ldr	x19, [sp,#16]
     500:	a8c27bfd 	ldp	x29, x30, [sp],#32
     504:	d65f03c0 	ret
     508:	f9400a62 	ldr	x2, [x19,#16]
     50c:	17fffff4 	b	4dc <device_create_release+0x3c>

0000000000000510 <device_initialize>:
 *
 * NOTE: Use put_device() to give up your reference instead of freeing
 * @dev directly once you have called this function.
 */
void device_initialize(struct device *dev)
{
     510:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
	dev->kobj.kset = devices_kset;
     514:	90000003 	adrp	x3, 0 <dev_attr_store>
			514: R_AARCH64_ADR_PREL_PG_HI21	.bss
	kobject_init(&dev->kobj, &device_ktype);
     518:	90000001 	adrp	x1, 0 <dev_attr_store>
			518: R_AARCH64_ADR_PREL_PG_HI21	.data
 *
 * NOTE: Use put_device() to give up your reference instead of freeing
 * @dev directly once you have called this function.
 */
void device_initialize(struct device *dev)
{
     51c:	910003fd 	mov	x29, sp
     520:	a90153f3 	stp	x19, x20, [sp,#16]
     524:	aa0003f3 	mov	x19, x0
	dev->kobj.kset = devices_kset;
     528:	f9400062 	ldr	x2, [x3]
			528: R_AARCH64_LDST64_ABS_LO12_NC	.bss
	kobject_init(&dev->kobj, &device_ktype);
     52c:	91004000 	add	x0, x0, #0x10
     530:	91000021 	add	x1, x1, #0x0
			530: R_AARCH64_ADD_ABS_LO12_NC	.data
 * NOTE: Use put_device() to give up your reference instead of freeing
 * @dev directly once you have called this function.
 */
void device_initialize(struct device *dev)
{
	dev->kobj.kset = devices_kset;
     534:	91000074 	add	x20, x3, #0x0
			534: R_AARCH64_ADD_ABS_LO12_NC	.bss
     538:	f9001a62 	str	x2, [x19,#48]
	kobject_init(&dev->kobj, &device_ktype);
     53c:	94000000 	bl	0 <kobject_init>
			53c: R_AARCH64_CALL26	kobject_init
	INIT_LIST_HEAD(&dev->dma_pools);
     540:	91084260 	add	x0, x19, #0x210
	mutex_init(&dev->mutex);
     544:	90000001 	adrp	x1, 0 <dev_attr_store>
			544: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0xe0
{
	switch (size) {
	case 1: *(volatile __u8 *)p = *(__u8 *)res; break;
	case 2: *(volatile __u16 *)p = *(__u16 *)res; break;
	case 4: *(volatile __u32 *)p = *(__u32 *)res; break;
	case 8: *(volatile __u64 *)p = *(__u64 *)res; break;
     548:	f9010a60 	str	x0, [x19,#528]
     54c:	91002282 	add	x2, x20, #0x8
     550:	91000021 	add	x1, x1, #0x0
			550: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0xe0
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	WRITE_ONCE(list->next, list);
	list->prev = list;
     554:	f9000400 	str	x0, [x0,#8]
     558:	91018260 	add	x0, x19, #0x60
     55c:	94000000 	bl	0 <__mutex_init>
			55c: R_AARCH64_CALL26	__mutex_init
	lockdep_set_novalidate_class(&dev->mutex);
	spin_lock_init(&dev->devres_lock);
     560:	7904c27f 	strh	wzr, [x19,#608]
	INIT_LIST_HEAD(&dev->devres_head);
     564:	9109a260 	add	x0, x19, #0x268
	dev->kobj.kset = devices_kset;
	kobject_init(&dev->kobj, &device_ktype);
	INIT_LIST_HEAD(&dev->dma_pools);
	mutex_init(&dev->mutex);
	lockdep_set_novalidate_class(&dev->mutex);
	spin_lock_init(&dev->devres_lock);
     568:	7904c67f 	strh	wzr, [x19,#610]
     56c:	f9013660 	str	x0, [x19,#616]
     570:	f9000400 	str	x0, [x0,#8]
#include <linux/pm_qos.h>

static inline void device_pm_init_common(struct device *dev)
{
	if (!dev->power.early_init) {
     574:	3942b260 	ldrb	w0, [x19,#172]
     578:	373800c0 	tbnz	w0, #7, 590 <device_initialize+0x80>
		spin_lock_init(&dev->power.lock);
		dev->power.qos = NULL;
		dev->power.early_init = true;
     57c:	32196000 	orr	w0, w0, #0xffffff80
#include <linux/pm_qos.h>

static inline void device_pm_init_common(struct device *dev)
{
	if (!dev->power.early_init) {
		spin_lock_init(&dev->power.lock);
     580:	7901627f 	strh	wzr, [x19,#176]
     584:	7901667f 	strh	wzr, [x19,#178]
		dev->power.qos = NULL;
     588:	f900e27f 	str	xzr, [x19,#448]
		dev->power.early_init = true;
     58c:	3902b260 	strb	w0, [x19,#172]
#endif /* !CONFIG_PM_SLEEP */

static inline void device_pm_init(struct device *dev)
{
	device_pm_init_common(dev);
	device_pm_sleep_init(dev);
     590:	aa1303e0 	mov	x0, x19
     594:	94000000 	bl	0 <device_pm_sleep_init>
			594: R_AARCH64_CALL26	device_pm_sleep_init
	pm_runtime_init(dev);
     598:	aa1303e0 	mov	x0, x19
     59c:	94000000 	bl	0 <pm_runtime_init>
			59c: R_AARCH64_CALL26	pm_runtime_init
	INIT_LIST_HEAD(&dev->devres_head);
	device_pm_init(dev);
	set_dev_node(dev, -1);
#ifdef CONFIG_GENERIC_MSI_IRQ
	INIT_LIST_HEAD(&dev->msi_list);
     5a0:	91078260 	add	x0, x19, #0x1e0
     5a4:	f900f260 	str	x0, [x19,#480]
     5a8:	f9000400 	str	x0, [x0,#8]
#endif
}
     5ac:	a94153f3 	ldp	x19, x20, [sp,#16]
     5b0:	a8c27bfd 	ldp	x29, x30, [sp],#32
     5b4:	d65f03c0 	ret

00000000000005b8 <dev_set_name>:
 * dev_set_name - set a device name
 * @dev: device
 * @fmt: format string for the device's name
 */
int dev_set_name(struct device *dev, const char *fmt, ...)
{
     5b8:	a9b87bfd 	stp	x29, x30, [sp,#-128]!
	va_list vargs;
	int err;

	va_start(vargs, fmt);
	err = kobject_set_name_vargs(&dev->kobj, fmt, vargs);
     5bc:	91004000 	add	x0, x0, #0x10
 * dev_set_name - set a device name
 * @dev: device
 * @fmt: format string for the device's name
 */
int dev_set_name(struct device *dev, const char *fmt, ...)
{
     5c0:	910003fd 	mov	x29, sp
	va_list vargs;
	int err;

	va_start(vargs, fmt);
     5c4:	910203a8 	add	x8, x29, #0x80
     5c8:	f9001ba8 	str	x8, [x29,#48]
     5cc:	f9001fa8 	str	x8, [x29,#56]
     5d0:	910143a8 	add	x8, x29, #0x50
     5d4:	b9004fbf 	str	wzr, [x29,#76]
     5d8:	f90023a8 	str	x8, [x29,#64]
     5dc:	128005e8 	mov	w8, #0xffffffd0            	// #-48
     5e0:	b9004ba8 	str	w8, [x29,#72]
 * dev_set_name - set a device name
 * @dev: device
 * @fmt: format string for the device's name
 */
int dev_set_name(struct device *dev, const char *fmt, ...)
{
     5e4:	f90033a4 	str	x4, [x29,#96]
     5e8:	f90037a5 	str	x5, [x29,#104]
	va_list vargs;
	int err;

	va_start(vargs, fmt);
	err = kobject_set_name_vargs(&dev->kobj, fmt, vargs);
     5ec:	a94317a4 	ldp	x4, x5, [x29,#48]
     5f0:	a90117a4 	stp	x4, x5, [x29,#16]
     5f4:	a94417a4 	ldp	x4, x5, [x29,#64]
 * dev_set_name - set a device name
 * @dev: device
 * @fmt: format string for the device's name
 */
int dev_set_name(struct device *dev, const char *fmt, ...)
{
     5f8:	f9002ba2 	str	x2, [x29,#80]
	va_list vargs;
	int err;

	va_start(vargs, fmt);
	err = kobject_set_name_vargs(&dev->kobj, fmt, vargs);
     5fc:	910043a2 	add	x2, x29, #0x10
 * dev_set_name - set a device name
 * @dev: device
 * @fmt: format string for the device's name
 */
int dev_set_name(struct device *dev, const char *fmt, ...)
{
     600:	f9002fa3 	str	x3, [x29,#88]
     604:	f9003ba6 	str	x6, [x29,#112]
     608:	f9003fa7 	str	x7, [x29,#120]
	va_list vargs;
	int err;

	va_start(vargs, fmt);
	err = kobject_set_name_vargs(&dev->kobj, fmt, vargs);
     60c:	a90217a4 	stp	x4, x5, [x29,#32]
     610:	94000000 	bl	0 <kobject_set_name_vargs>
			610: R_AARCH64_CALL26	kobject_set_name_vargs
	va_end(vargs);
	return err;
}
     614:	a8c87bfd 	ldp	x29, x30, [sp],#128
     618:	d65f03c0 	ret

000000000000061c <dev_show>:
		device_remove_groups(dev, class->dev_groups);
}

static ssize_t dev_show(struct device *dev, struct device_attribute *attr,
			char *buf)
{
     61c:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     620:	910003fd 	mov	x29, sp
	return print_dev_t(buf, dev->devt);
     624:	b9425801 	ldr	w1, [x0,#600]
		device_remove_groups(dev, class->dev_groups);
}

static ssize_t dev_show(struct device *dev, struct device_attribute *attr,
			char *buf)
{
     628:	aa0203e0 	mov	x0, x2
	return print_dev_t(buf, dev->devt);
     62c:	12004c23 	and	w3, w1, #0xfffff
     630:	53147c22 	lsr	w2, w1, #20
     634:	90000001 	adrp	x1, 0 <dev_attr_store>
			634: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0xf0
     638:	91000021 	add	x1, x1, #0x0
			638: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0xf0
     63c:	94000000 	bl	0 <sprintf>
			63c: R_AARCH64_CALL26	sprintf
}
     640:	93407c00 	sxtw	x0, w0
     644:	a8c17bfd 	ldp	x29, x30, [sp],#16
     648:	d65f03c0 	ret

000000000000064c <uevent_show>:
	.uevent =	dev_uevent,
};

static ssize_t uevent_show(struct device *dev, struct device_attribute *attr,
			   char *buf)
{
     64c:	a9bc7bfd 	stp	x29, x30, [sp,#-64]!
     650:	910003fd 	mov	x29, sp
     654:	a90153f3 	stp	x19, x20, [sp,#16]
	int i;
	size_t count = 0;
	int retval;

	/* search the kset, the device belongs to */
	top_kobj = &dev->kobj;
     658:	91004014 	add	x20, x0, #0x10
	.uevent =	dev_uevent,
};

static ssize_t uevent_show(struct device *dev, struct device_attribute *attr,
			   char *buf)
{
     65c:	a90363f7 	stp	x23, x24, [sp,#48]
     660:	a9025bf5 	stp	x21, x22, [sp,#32]
     664:	aa0203f7 	mov	x23, x2
	int i;
	size_t count = 0;
	int retval;

	/* search the kset, the device belongs to */
	top_kobj = &dev->kobj;
     668:	aa1403e3 	mov	x3, x20
	while (!top_kobj->kset && top_kobj->parent)
     66c:	14000003 	b	678 <uevent_show+0x2c>
     670:	f9400c63 	ldr	x3, [x3,#24]
     674:	b40005a3 	cbz	x3, 728 <uevent_show+0xdc>
     678:	f9401073 	ldr	x19, [x3,#32]
     67c:	b4ffffb3 	cbz	x19, 670 <uevent_show+0x24>
		top_kobj = top_kobj->parent;
	if (!top_kobj->kset)
		goto out;

	kset = top_kobj->kset;
	if (!kset->uevent_ops || !kset->uevent_ops->uevent)
     680:	f9402e60 	ldr	x0, [x19,#88]
     684:	b4000520 	cbz	x0, 728 <uevent_show+0xdc>
     688:	f9400801 	ldr	x1, [x0,#16]
     68c:	b40004e1 	cbz	x1, 728 <uevent_show+0xdc>
		goto out;

	/* respect filter */
	if (kset->uevent_ops && kset->uevent_ops->filter)
     690:	f9400002 	ldr	x2, [x0]
     694:	b40000a2 	cbz	x2, 6a8 <uevent_show+0x5c>
		if (!kset->uevent_ops->filter(kset, &dev->kobj))
     698:	aa1403e1 	mov	x1, x20
     69c:	aa1303e0 	mov	x0, x19
     6a0:	d63f0040 	blr	x2
     6a4:	34000420 	cbz	w0, 728 <uevent_show+0xdc>

#else /* CONFIG_TRACING */
static __always_inline void *kmem_cache_alloc_trace(struct kmem_cache *s,
		gfp_t flags, size_t size)
{
	void *ret = kmem_cache_alloc(s, flags);
     6a8:	90000000 	adrp	x0, 0 <kmalloc_caches>
			6a8: R_AARCH64_ADR_PREL_PG_HI21	kmalloc_caches+0x60
     6ac:	52901801 	mov	w1, #0x80c0                	// #32960
     6b0:	72a04801 	movk	w1, #0x240, lsl #16
     6b4:	f9400000 	ldr	x0, [x0]
			6b4: R_AARCH64_LDST64_ABS_LO12_NC	kmalloc_caches+0x60
     6b8:	94000000 	bl	0 <kmem_cache_alloc>
			6b8: R_AARCH64_CALL26	kmem_cache_alloc
     6bc:	aa0003f6 	mov	x22, x0
			goto out;

	env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);
	if (!env)
     6c0:	b4000480 	cbz	x0, 750 <uevent_show+0x104>
		return -ENOMEM;

	/* let the kset specific function add its keys */
	retval = kset->uevent_ops->uevent(kset, &dev->kobj, env);
     6c4:	f9402e63 	ldr	x3, [x19,#88]
     6c8:	aa0003e2 	mov	x2, x0
     6cc:	aa1403e1 	mov	x1, x20
     6d0:	aa1303e0 	mov	x0, x19
     6d4:	d2800013 	mov	x19, #0x0                   	// #0
     6d8:	f9400863 	ldr	x3, [x3,#16]
     6dc:	d63f0060 	blr	x3
	if (retval)
     6e0:	35000280 	cbnz	w0, 730 <uevent_show+0xe4>
		goto out;

	/* copy keys to file */
	for (i = 0; i < env->envp_idx; i++)
     6e4:	b9411ac0 	ldr	w0, [x22,#280]
     6e8:	6b1f001f 	cmp	w0, wzr
     6ec:	5400022d 	b.le	730 <uevent_show+0xe4>
		count += sprintf(&buf[count], "%s\n", env->envp[i]);
     6f0:	90000018 	adrp	x24, 0 <dev_attr_store>
			6f0: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0xf8
     6f4:	910062d5 	add	x21, x22, #0x18
	retval = kset->uevent_ops->uevent(kset, &dev->kobj, env);
	if (retval)
		goto out;

	/* copy keys to file */
	for (i = 0; i < env->envp_idx; i++)
     6f8:	52800014 	mov	w20, #0x0                   	// #0
		count += sprintf(&buf[count], "%s\n", env->envp[i]);
     6fc:	91000318 	add	x24, x24, #0x0
			6fc: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0xf8
     700:	f84086a2 	ldr	x2, [x21],#8
     704:	8b1302e0 	add	x0, x23, x19
     708:	aa1803e1 	mov	x1, x24
	retval = kset->uevent_ops->uevent(kset, &dev->kobj, env);
	if (retval)
		goto out;

	/* copy keys to file */
	for (i = 0; i < env->envp_idx; i++)
     70c:	11000694 	add	w20, w20, #0x1
		count += sprintf(&buf[count], "%s\n", env->envp[i]);
     710:	94000000 	bl	0 <sprintf>
			710: R_AARCH64_CALL26	sprintf
     714:	8b20c273 	add	x19, x19, w0, sxtw
	retval = kset->uevent_ops->uevent(kset, &dev->kobj, env);
	if (retval)
		goto out;

	/* copy keys to file */
	for (i = 0; i < env->envp_idx; i++)
     718:	b9411ac3 	ldr	w3, [x22,#280]
     71c:	6b14007f 	cmp	w3, w20
     720:	54ffff0c 	b.gt	700 <uevent_show+0xb4>
     724:	14000003 	b	730 <uevent_show+0xe4>
     728:	d2800013 	mov	x19, #0x0                   	// #0
static ssize_t uevent_show(struct device *dev, struct device_attribute *attr,
			   char *buf)
{
	struct kobject *top_kobj;
	struct kset *kset;
	struct kobj_uevent_env *env = NULL;
     72c:	d2800016 	mov	x22, #0x0                   	// #0

	/* copy keys to file */
	for (i = 0; i < env->envp_idx; i++)
		count += sprintf(&buf[count], "%s\n", env->envp[i]);
out:
	kfree(env);
     730:	aa1603e0 	mov	x0, x22
     734:	94000000 	bl	0 <kfree>
			734: R_AARCH64_CALL26	kfree
	return count;
}
     738:	aa1303e0 	mov	x0, x19
     73c:	a94153f3 	ldp	x19, x20, [sp,#16]
     740:	a9425bf5 	ldp	x21, x22, [sp,#32]
     744:	a94363f7 	ldp	x23, x24, [sp,#48]
     748:	a8c47bfd 	ldp	x29, x30, [sp],#64
     74c:	d65f03c0 	ret
		if (!kset->uevent_ops->filter(kset, &dev->kobj))
			goto out;

	env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);
	if (!env)
		return -ENOMEM;
     750:	92800173 	mov	x19, #0xfffffffffffffff4    	// #-12
     754:	17fffff9 	b	738 <uevent_show+0xec>

0000000000000758 <online_show>:
}
static DEVICE_ATTR_RW(uevent);

static ssize_t online_show(struct device *dev, struct device_attribute *attr,
			   char *buf)
{
     758:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
     75c:	910003fd 	mov	x29, sp
     760:	a90153f3 	stp	x19, x20, [sp,#16]
#endif
}

static inline void device_lock(struct device *dev)
{
	mutex_lock(&dev->mutex);
     764:	91018014 	add	x20, x0, #0x60
     768:	aa0003f3 	mov	x19, x0
     76c:	aa1403e0 	mov	x0, x20
     770:	f90013f5 	str	x21, [sp,#32]
     774:	aa0203f5 	mov	x21, x2
     778:	94000000 	bl	0 <mutex_lock>
			778: R_AARCH64_CALL26	mutex_lock
	bool val;

	device_lock(dev);
	val = !dev->offline;
     77c:	394ae273 	ldrb	w19, [x19,#696]
	return mutex_trylock(&dev->mutex);
}

static inline void device_unlock(struct device *dev)
{
	mutex_unlock(&dev->mutex);
     780:	aa1403e0 	mov	x0, x20
     784:	d3410673 	ubfx	x19, x19, #1, #1
     788:	52000273 	eor	w19, w19, #0x1
     78c:	94000000 	bl	0 <mutex_unlock>
			78c: R_AARCH64_CALL26	mutex_unlock
	device_unlock(dev);
	return sprintf(buf, "%u\n", val);
     790:	90000001 	adrp	x1, 0 <dev_attr_store>
			790: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x100
     794:	aa1503e0 	mov	x0, x21
			   char *buf)
{
	bool val;

	device_lock(dev);
	val = !dev->offline;
     798:	53001e73 	uxtb	w19, w19
	device_unlock(dev);
	return sprintf(buf, "%u\n", val);
     79c:	91000021 	add	x1, x1, #0x0
			79c: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x100
     7a0:	2a1303e2 	mov	w2, w19
     7a4:	94000000 	bl	0 <sprintf>
			7a4: R_AARCH64_CALL26	sprintf
}
     7a8:	93407c00 	sxtw	x0, w0
     7ac:	a94153f3 	ldp	x19, x20, [sp,#16]
     7b0:	f94013f5 	ldr	x21, [sp,#32]
     7b4:	a8c37bfd 	ldp	x29, x30, [sp],#48
     7b8:	d65f03c0 	ret

00000000000007bc <get_device>:
 * This simply forwards the call to kobject_get(), though
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
     7bc:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     7c0:	910003fd 	mov	x29, sp
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
     7c4:	b40000c0 	cbz	x0, 7dc <get_device+0x20>
     7c8:	91004000 	add	x0, x0, #0x10
     7cc:	94000000 	bl	0 <kobject_get>
			7cc: R_AARCH64_CALL26	kobject_get
	bool			offline:1;
};

static inline struct device *kobj_to_dev(struct kobject *kobj)
{
	return container_of(kobj, struct device, kobj);
     7d0:	d1004000 	sub	x0, x0, #0x10
}
     7d4:	a8c17bfd 	ldp	x29, x30, [sp],#16
     7d8:	d65f03c0 	ret
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
     7dc:	d2800000 	mov	x0, #0x0                   	// #0
     7e0:	17fffffd 	b	7d4 <get_device+0x18>

00000000000007e4 <klist_children_get>:
		sysfs_remove_bin_file(&dev->kobj, attr);
}
EXPORT_SYMBOL_GPL(device_remove_bin_file);

static void klist_children_get(struct klist_node *n)
{
     7e4:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     7e8:	910003fd 	mov	x29, sp
	struct device_private *p = to_device_private_parent(n);
	struct device *dev = p->device;
     7ec:	f9403800 	ldr	x0, [x0,#112]
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
     7f0:	b4000060 	cbz	x0, 7fc <klist_children_get+0x18>
     7f4:	91004000 	add	x0, x0, #0x10
     7f8:	94000000 	bl	0 <kobject_get>
			7f8: R_AARCH64_CALL26	kobject_get
{
	struct device_private *p = to_device_private_parent(n);
	struct device *dev = p->device;

	get_device(dev);
}
     7fc:	a8c17bfd 	ldp	x29, x30, [sp],#16
     800:	d65f03c0 	ret

0000000000000804 <put_device>:
/**
 * put_device - decrement reference count.
 * @dev: device in question.
 */
void put_device(struct device *dev)
{
     804:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     808:	910003fd 	mov	x29, sp
	/* might_sleep(); */
	if (dev)
     80c:	b4000060 	cbz	x0, 818 <put_device+0x14>
		kobject_put(&dev->kobj);
     810:	91004000 	add	x0, x0, #0x10
     814:	94000000 	bl	0 <kobject_put>
			814: R_AARCH64_CALL26	kobject_put
}
     818:	a8c17bfd 	ldp	x29, x30, [sp],#16
     81c:	d65f03c0 	ret

0000000000000820 <klist_children_put>:

	get_device(dev);
}

static void klist_children_put(struct klist_node *n)
{
     820:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     824:	910003fd 	mov	x29, sp
	struct device_private *p = to_device_private_parent(n);
	struct device *dev = p->device;
     828:	f9403800 	ldr	x0, [x0,#112]
 * @dev: device in question.
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
     82c:	b4000060 	cbz	x0, 838 <klist_children_put+0x18>
		kobject_put(&dev->kobj);
     830:	91004000 	add	x0, x0, #0x10
     834:	94000000 	bl	0 <kobject_put>
			834: R_AARCH64_CALL26	kobject_put
{
	struct device_private *p = to_device_private_parent(n);
	struct device *dev = p->device;

	put_device(dev);
}
     838:	a8c17bfd 	ldp	x29, x30, [sp],#16
     83c:	d65f03c0 	ret

0000000000000840 <device_remove_class_symlinks>:
	sysfs_remove_link(&dev->kobj, "of_node");
	return error;
}

static void device_remove_class_symlinks(struct device *dev)
{
     840:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
     844:	910003fd 	mov	x29, sp
     848:	a90153f3 	stp	x19, x20, [sp,#16]
     84c:	aa0003f3 	mov	x19, x0
	if (dev_of_node(dev))
     850:	f9412400 	ldr	x0, [x0,#584]
     854:	b40000a0 	cbz	x0, 868 <device_remove_class_symlinks+0x28>
		sysfs_remove_link(&dev->kobj, "of_node");
     858:	90000001 	adrp	x1, 0 <dev_attr_store>
			858: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x108
     85c:	91004260 	add	x0, x19, #0x10
     860:	91000021 	add	x1, x1, #0x0
			860: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x108
     864:	94000000 	bl	0 <sysfs_remove_link>
			864: R_AARCH64_CALL26	sysfs_remove_link

	if (!dev->class)
     868:	f9414e60 	ldr	x0, [x19,#664]
     86c:	b4000300 	cbz	x0, 8cc <device_remove_class_symlinks+0x8c>
		return;

	if (dev->parent && device_is_not_partition(dev))
     870:	f9400260 	ldr	x0, [x19]
		sysfs_remove_link(&dev->kobj, "device");
     874:	91004274 	add	x20, x19, #0x10
		sysfs_remove_link(&dev->kobj, "of_node");

	if (!dev->class)
		return;

	if (dev->parent && device_is_not_partition(dev))
     878:	b4000140 	cbz	x0, 8a0 <device_remove_class_symlinks+0x60>
     87c:	f9402e61 	ldr	x1, [x19,#88]
     880:	90000000 	adrp	x0, 0 <part_type>
			880: R_AARCH64_ADR_PREL_PG_HI21	part_type
     884:	91000000 	add	x0, x0, #0x0
			884: R_AARCH64_ADD_ABS_LO12_NC	part_type
     888:	eb00003f 	cmp	x1, x0
     88c:	540000a0 	b.eq	8a0 <device_remove_class_symlinks+0x60>
		sysfs_remove_link(&dev->kobj, "device");
     890:	90000001 	adrp	x1, 0 <dev_attr_store>
			890: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x110
     894:	aa1403e0 	mov	x0, x20
     898:	91000021 	add	x1, x1, #0x0
			898: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x110
     89c:	94000000 	bl	0 <sysfs_remove_link>
			89c: R_AARCH64_CALL26	sysfs_remove_link
	sysfs_remove_link(&dev->kobj, "subsystem");
     8a0:	90000001 	adrp	x1, 0 <dev_attr_store>
			8a0: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x118
     8a4:	aa1403e0 	mov	x0, x20
     8a8:	91000021 	add	x1, x1, #0x0
			8a8: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x118
     8ac:	94000000 	bl	0 <sysfs_remove_link>
			8ac: R_AARCH64_CALL26	sysfs_remove_link
#ifdef CONFIG_BLOCK
	if (sysfs_deprecated && dev->class == &block_class)
		return;
#endif
	sysfs_delete_link(&dev->class->p->subsys.kobj, &dev->kobj, dev_name(dev));
     8b0:	f9414e60 	ldr	x0, [x19,#664]
#include <linux/pm_wakeup.h>

static inline const char *dev_name(const struct device *dev)
{
	/* Use the init name until the kobject becomes available */
	if (dev->init_name)
     8b4:	f9402a62 	ldr	x2, [x19,#80]
     8b8:	f9403803 	ldr	x3, [x0,#112]
     8bc:	91006060 	add	x0, x3, #0x18
     8c0:	b40000c2 	cbz	x2, 8d8 <device_remove_class_symlinks+0x98>
     8c4:	aa1403e1 	mov	x1, x20
     8c8:	94000000 	bl	0 <sysfs_delete_link>
			8c8: R_AARCH64_CALL26	sysfs_delete_link
}
     8cc:	a94153f3 	ldp	x19, x20, [sp,#16]
     8d0:	a8c27bfd 	ldp	x29, x30, [sp],#32
     8d4:	d65f03c0 	ret
     8d8:	f9400a62 	ldr	x2, [x19,#16]
     8dc:	17fffffa 	b	8c4 <device_remove_class_symlinks+0x84>

00000000000008e0 <device_for_each_child>:
 * We check the return of @fn each time. If it returns anything
 * other than 0, we break out and return that value.
 */
int device_for_each_child(struct device *parent, void *data,
			  int (*fn)(struct device *dev, void *data))
{
     8e0:	a9bc7bfd 	stp	x29, x30, [sp,#-64]!
     8e4:	910003fd 	mov	x29, sp
     8e8:	a90153f3 	stp	x19, x20, [sp,#16]
     8ec:	f90013f5 	str	x21, [sp,#32]
	struct klist_iter i;
	struct device *child;
	int error = 0;

	if (!parent->p)
     8f0:	f9400400 	ldr	x0, [x0,#8]
     8f4:	b4000300 	cbz	x0, 954 <device_for_each_child+0x74>
     8f8:	aa0103f4 	mov	x20, x1
		return 0;

	klist_iter_init(&parent->p->klist_children, &i);
     8fc:	9100c3a1 	add	x1, x29, #0x30
     900:	aa0203f5 	mov	x21, x2
int device_for_each_child(struct device *parent, void *data,
			  int (*fn)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;
	int error = 0;
     904:	52800013 	mov	w19, #0x0                   	// #0

	if (!parent->p)
		return 0;

	klist_iter_init(&parent->p->klist_children, &i);
     908:	94000000 	bl	0 <klist_iter_init>
			908: R_AARCH64_CALL26	klist_iter_init
	while ((child = next_device(&i)) && !error)
     90c:	14000007 	b	928 <device_for_each_child+0x48>
	struct device *dev = NULL;
	struct device_private *p;

	if (n) {
		p = to_device_private_parent(n);
		dev = p->device;
     910:	f9403803 	ldr	x3, [x0,#112]

	if (!parent->p)
		return 0;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)) && !error)
     914:	35000133 	cbnz	w19, 938 <device_for_each_child+0x58>
		error = fn(child, data);
     918:	aa0303e0 	mov	x0, x3

	if (!parent->p)
		return 0;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)) && !error)
     91c:	b40000e3 	cbz	x3, 938 <device_for_each_child+0x58>
		error = fn(child, data);
     920:	d63f02a0 	blr	x21
     924:	2a0003f3 	mov	w19, w0
	return dev;
}

static struct device *next_device(struct klist_iter *i)
{
	struct klist_node *n = klist_next(i);
     928:	9100c3a0 	add	x0, x29, #0x30
     92c:	94000000 	bl	0 <klist_next>
			92c: R_AARCH64_CALL26	klist_next
	if (!parent->p)
		return 0;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)) && !error)
		error = fn(child, data);
     930:	aa1403e1 	mov	x1, x20
{
	struct klist_node *n = klist_next(i);
	struct device *dev = NULL;
	struct device_private *p;

	if (n) {
     934:	b5fffee0 	cbnz	x0, 910 <device_for_each_child+0x30>
		return 0;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)) && !error)
		error = fn(child, data);
	klist_iter_exit(&i);
     938:	9100c3a0 	add	x0, x29, #0x30
     93c:	94000000 	bl	0 <klist_iter_exit>
			93c: R_AARCH64_CALL26	klist_iter_exit
	return error;
}
     940:	f94013f5 	ldr	x21, [sp,#32]

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)) && !error)
		error = fn(child, data);
	klist_iter_exit(&i);
	return error;
     944:	2a1303e0 	mov	w0, w19
}
     948:	a94153f3 	ldp	x19, x20, [sp,#16]
     94c:	a8c47bfd 	ldp	x29, x30, [sp],#64
     950:	d65f03c0 	ret
	struct klist_iter i;
	struct device *child;
	int error = 0;

	if (!parent->p)
		return 0;
     954:	52800000 	mov	w0, #0x0                   	// #0
	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)) && !error)
		error = fn(child, data);
	klist_iter_exit(&i);
	return error;
}
     958:	f94013f5 	ldr	x21, [sp,#32]
     95c:	a94153f3 	ldp	x19, x20, [sp,#16]
     960:	a8c47bfd 	ldp	x29, x30, [sp],#64
     964:	d65f03c0 	ret

0000000000000968 <device_find_child>:
 *
 * NOTE: you will need to drop the reference with put_device() after use.
 */
struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
     968:	a9bc7bfd 	stp	x29, x30, [sp,#-64]!
     96c:	910003fd 	mov	x29, sp
     970:	a90153f3 	stp	x19, x20, [sp,#16]
     974:	f90013f5 	str	x21, [sp,#32]
	struct klist_iter i;
	struct device *child;

	if (!parent)
     978:	b40003a0 	cbz	x0, 9ec <device_find_child+0x84>
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
     97c:	f9400400 	ldr	x0, [x0,#8]
     980:	aa0103f4 	mov	x20, x1
     984:	9100c3a1 	add	x1, x29, #0x30
     988:	aa0203f5 	mov	x21, x2
     98c:	94000000 	bl	0 <klist_iter_init>
			98c: R_AARCH64_CALL26	klist_iter_init
	while ((child = next_device(&i)))
     990:	14000006 	b	9a8 <device_find_child+0x40>
	struct device *dev = NULL;
	struct device_private *p;

	if (n) {
		p = to_device_private_parent(n);
		dev = p->device;
     994:	f9403813 	ldr	x19, [x0,#112]
	if (!parent)
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
     998:	aa1303e0 	mov	x0, x19

	if (!parent)
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
     99c:	b4000113 	cbz	x19, 9bc <device_find_child+0x54>
		if (match(child, data) && get_device(child))
     9a0:	d63f02a0 	blr	x21
     9a4:	350001a0 	cbnz	w0, 9d8 <device_find_child+0x70>
	return dev;
}

static struct device *next_device(struct klist_iter *i)
{
	struct klist_node *n = klist_next(i);
     9a8:	9100c3a0 	add	x0, x29, #0x30
     9ac:	94000000 	bl	0 <klist_next>
			9ac: R_AARCH64_CALL26	klist_next
	if (!parent)
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
     9b0:	aa1403e1 	mov	x1, x20
{
	struct klist_node *n = klist_next(i);
	struct device *dev = NULL;
	struct device_private *p;

	if (n) {
     9b4:	b5ffff00 	cbnz	x0, 994 <device_find_child+0x2c>
     9b8:	d2800013 	mov	x19, #0x0                   	// #0

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
     9bc:	9100c3a0 	add	x0, x29, #0x30
     9c0:	94000000 	bl	0 <klist_iter_exit>
			9c0: R_AARCH64_CALL26	klist_iter_exit
	return child;
     9c4:	aa1303e0 	mov	x0, x19
}
     9c8:	a94153f3 	ldp	x19, x20, [sp,#16]
     9cc:	f94013f5 	ldr	x21, [sp,#32]
     9d0:	a8c47bfd 	ldp	x29, x30, [sp],#64
     9d4:	d65f03c0 	ret
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
     9d8:	91004260 	add	x0, x19, #0x10
     9dc:	94000000 	bl	0 <kobject_get>
			9dc: R_AARCH64_CALL26	kobject_get
	if (!parent)
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
     9e0:	f100401f 	cmp	x0, #0x10
     9e4:	54fffe20 	b.eq	9a8 <device_find_child+0x40>
     9e8:	17fffff5 	b	9bc <device_find_child+0x54>
{
	struct klist_iter i;
	struct device *child;

	if (!parent)
		return NULL;
     9ec:	d2800000 	mov	x0, #0x0                   	// #0
     9f0:	17fffff6 	b	9c8 <device_find_child+0x60>

00000000000009f4 <device_for_each_child_reverse>:
 * We check the return of @fn each time. If it returns anything
 * other than 0, we break out and return that value.
 */
int device_for_each_child_reverse(struct device *parent, void *data,
				  int (*fn)(struct device *dev, void *data))
{
     9f4:	a9bc7bfd 	stp	x29, x30, [sp,#-64]!
     9f8:	910003fd 	mov	x29, sp
     9fc:	a90153f3 	stp	x19, x20, [sp,#16]
     a00:	f90013f5 	str	x21, [sp,#32]
	struct klist_iter i;
	struct device *child;
	int error = 0;

	if (!parent->p)
     a04:	f9400400 	ldr	x0, [x0,#8]
     a08:	b4000300 	cbz	x0, a68 <device_for_each_child_reverse+0x74>
     a0c:	aa0103f4 	mov	x20, x1
		return 0;

	klist_iter_init(&parent->p->klist_children, &i);
     a10:	9100c3a1 	add	x1, x29, #0x30
     a14:	aa0203f5 	mov	x21, x2
int device_for_each_child_reverse(struct device *parent, void *data,
				  int (*fn)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;
	int error = 0;
     a18:	52800013 	mov	w19, #0x0                   	// #0

	if (!parent->p)
		return 0;

	klist_iter_init(&parent->p->klist_children, &i);
     a1c:	94000000 	bl	0 <klist_iter_init>
			a1c: R_AARCH64_CALL26	klist_iter_init
	while ((child = prev_device(&i)) && !error)
     a20:	14000007 	b	a3c <device_for_each_child_reverse+0x48>
	struct device *dev = NULL;
	struct device_private *p;

	if (n) {
		p = to_device_private_parent(n);
		dev = p->device;
     a24:	f9403803 	ldr	x3, [x0,#112]

	if (!parent->p)
		return 0;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = prev_device(&i)) && !error)
     a28:	35000133 	cbnz	w19, a4c <device_for_each_child_reverse+0x58>
		error = fn(child, data);
     a2c:	aa0303e0 	mov	x0, x3

	if (!parent->p)
		return 0;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = prev_device(&i)) && !error)
     a30:	b40000e3 	cbz	x3, a4c <device_for_each_child_reverse+0x58>
		error = fn(child, data);
     a34:	d63f02a0 	blr	x21
     a38:	2a0003f3 	mov	w19, w0
}
EXPORT_SYMBOL_GPL(device_unregister);

static struct device *prev_device(struct klist_iter *i)
{
	struct klist_node *n = klist_prev(i);
     a3c:	9100c3a0 	add	x0, x29, #0x30
     a40:	94000000 	bl	0 <klist_prev>
			a40: R_AARCH64_CALL26	klist_prev
	if (!parent->p)
		return 0;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = prev_device(&i)) && !error)
		error = fn(child, data);
     a44:	aa1403e1 	mov	x1, x20
{
	struct klist_node *n = klist_prev(i);
	struct device *dev = NULL;
	struct device_private *p;

	if (n) {
     a48:	b5fffee0 	cbnz	x0, a24 <device_for_each_child_reverse+0x30>
		return 0;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = prev_device(&i)) && !error)
		error = fn(child, data);
	klist_iter_exit(&i);
     a4c:	9100c3a0 	add	x0, x29, #0x30
     a50:	94000000 	bl	0 <klist_iter_exit>
			a50: R_AARCH64_CALL26	klist_iter_exit
	return error;
}
     a54:	f94013f5 	ldr	x21, [sp,#32]

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = prev_device(&i)) && !error)
		error = fn(child, data);
	klist_iter_exit(&i);
	return error;
     a58:	2a1303e0 	mov	w0, w19
}
     a5c:	a94153f3 	ldp	x19, x20, [sp,#16]
     a60:	a8c47bfd 	ldp	x29, x30, [sp],#64
     a64:	d65f03c0 	ret
	struct klist_iter i;
	struct device *child;
	int error = 0;

	if (!parent->p)
		return 0;
     a68:	52800000 	mov	w0, #0x0                   	// #0
	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = prev_device(&i)) && !error)
		error = fn(child, data);
	klist_iter_exit(&i);
	return error;
}
     a6c:	f94013f5 	ldr	x21, [sp,#32]
     a70:	a94153f3 	ldp	x19, x20, [sp,#16]
     a74:	a8c47bfd 	ldp	x29, x30, [sp],#64
     a78:	d65f03c0 	ret

0000000000000a7c <device_rename>:
 * symlinks -- but never rename kernel devices later, it's a complete mess. We
 * don't even want to get into that and try to implement the missing pieces in
 * the core. We really have other pieces to fix in the driver core mess. :)
 */
int device_rename(struct device *dev, const char *new_name)
{
     a7c:	a9bc7bfd 	stp	x29, x30, [sp,#-64]!
     a80:	910003fd 	mov	x29, sp
     a84:	a90153f3 	stp	x19, x20, [sp,#16]
     a88:	a9025bf5 	stp	x21, x22, [sp,#32]
     a8c:	f9001bf7 	str	x23, [sp,#48]
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
     a90:	b4000620 	cbz	x0, b54 <device_rename+0xd8>
 * don't even want to get into that and try to implement the missing pieces in
 * the core. We really have other pieces to fix in the driver core mess. :)
 */
int device_rename(struct device *dev, const char *new_name)
{
	struct kobject *kobj = &dev->kobj;
     a94:	91004013 	add	x19, x0, #0x10
     a98:	aa0103f5 	mov	x21, x1
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
     a9c:	aa1303e0 	mov	x0, x19
     aa0:	94000000 	bl	0 <kobject_get>
			aa0: R_AARCH64_CALL26	kobject_get
	struct kobject *kobj = &dev->kobj;
	char *old_device_name = NULL;
	int error;

	dev = get_device(dev);
	if (!dev)
     aa4:	f1004014 	subs	x20, x0, #0x10
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
     aa8:	aa0003f7 	mov	x23, x0
	struct kobject *kobj = &dev->kobj;
	char *old_device_name = NULL;
	int error;

	dev = get_device(dev);
	if (!dev)
     aac:	54000540 	b.eq	b54 <device_rename+0xd8>
		return -EINVAL;

	dev_dbg(dev, "renaming to %s\n", new_name);
     ab0:	90000004 	adrp	x4, 0 <dev_attr_store>
			ab0: R_AARCH64_ADR_PREL_PG_HI21	__verbose
     ab4:	91000084 	add	x4, x4, #0x0
			ab4: R_AARCH64_ADD_ABS_LO12_NC	__verbose
     ab8:	9100a084 	add	x4, x4, #0x28
     abc:	79404480 	ldrh	w0, [x4,#34]
     ac0:	371005e0 	tbnz	w0, #2, b7c <device_rename+0x100>
     ac4:	f9402a80 	ldr	x0, [x20,#80]
     ac8:	b4000560 	cbz	x0, b74 <device_rename+0xf8>

	old_device_name = kstrdup(dev_name(dev), GFP_KERNEL);
     acc:	52801801 	mov	w1, #0xc0                  	// #192
     ad0:	72a04801 	movk	w1, #0x240, lsl #16
     ad4:	94000000 	bl	0 <kstrdup>
			ad4: R_AARCH64_CALL26	kstrdup
     ad8:	aa0003f6 	mov	x22, x0
	if (!old_device_name) {
     adc:	b4000480 	cbz	x0, b6c <device_rename+0xf0>
		error = -ENOMEM;
		goto out;
	}

	if (dev->class) {
     ae0:	f9414e80 	ldr	x0, [x20,#664]
     ae4:	b40002e0 	cbz	x0, b40 <device_rename+0xc4>
		error = sysfs_rename_link_ns(&dev->class->p->subsys.kobj,
     ae8:	f9403814 	ldr	x20, [x0,#112]
     aec:	aa1303e0 	mov	x0, x19
     af0:	91006294 	add	x20, x20, #0x18
     af4:	94000000 	bl	0 <kobject_namespace>
			af4: R_AARCH64_CALL26	kobject_namespace
     af8:	aa1503e3 	mov	x3, x21
     afc:	aa0003e4 	mov	x4, x0
     b00:	aa1603e2 	mov	x2, x22
     b04:	aa1403e0 	mov	x0, x20
     b08:	aa1303e1 	mov	x1, x19
     b0c:	94000000 	bl	0 <sysfs_rename_link_ns>
			b0c: R_AARCH64_CALL26	sysfs_rename_link_ns
     b10:	2a0003f4 	mov	w20, w0
					     kobj, old_device_name,
					     new_name, kobject_namespace(kobj));
		if (error)
     b14:	34000160 	cbz	w0, b40 <device_rename+0xc4>
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
		kobject_put(&dev->kobj);
     b18:	aa1703e0 	mov	x0, x23
     b1c:	94000000 	bl	0 <kobject_put>
			b1c: R_AARCH64_CALL26	kobject_put
		goto out;

out:
	put_device(dev);

	kfree(old_device_name);
     b20:	aa1603e0 	mov	x0, x22
     b24:	94000000 	bl	0 <kfree>
			b24: R_AARCH64_CALL26	kfree

	return error;
}
     b28:	f9401bf7 	ldr	x23, [sp,#48]
out:
	put_device(dev);

	kfree(old_device_name);

	return error;
     b2c:	2a1403e0 	mov	w0, w20
}
     b30:	a94153f3 	ldp	x19, x20, [sp,#16]
     b34:	a9425bf5 	ldp	x21, x22, [sp,#32]
     b38:	a8c47bfd 	ldp	x29, x30, [sp],#64
     b3c:	d65f03c0 	ret
					     new_name, kobject_namespace(kobj));
		if (error)
			goto out;
	}

	error = kobject_rename(kobj, new_name);
     b40:	aa1503e1 	mov	x1, x21
     b44:	aa1303e0 	mov	x0, x19
     b48:	94000000 	bl	0 <kobject_rename>
			b48: R_AARCH64_CALL26	kobject_rename
     b4c:	2a0003f4 	mov	w20, w0
     b50:	17fffff2 	b	b18 <device_rename+0x9c>
	char *old_device_name = NULL;
	int error;

	dev = get_device(dev);
	if (!dev)
		return -EINVAL;
     b54:	128002a0 	mov	w0, #0xffffffea            	// #-22
	put_device(dev);

	kfree(old_device_name);

	return error;
}
     b58:	f9401bf7 	ldr	x23, [sp,#48]
     b5c:	a94153f3 	ldp	x19, x20, [sp,#16]
     b60:	a9425bf5 	ldp	x21, x22, [sp,#32]
     b64:	a8c47bfd 	ldp	x29, x30, [sp],#64
     b68:	d65f03c0 	ret

	dev_dbg(dev, "renaming to %s\n", new_name);

	old_device_name = kstrdup(dev_name(dev), GFP_KERNEL);
	if (!old_device_name) {
		error = -ENOMEM;
     b6c:	12800174 	mov	w20, #0xfffffff4            	// #-12
     b70:	17ffffea 	b	b18 <device_rename+0x9c>
     b74:	f94002e0 	ldr	x0, [x23]
     b78:	17ffffd5 	b	acc <device_rename+0x50>

	dev = get_device(dev);
	if (!dev)
		return -EINVAL;

	dev_dbg(dev, "renaming to %s\n", new_name);
     b7c:	90000002 	adrp	x2, 0 <dev_attr_store>
			b7c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x128
     b80:	aa1503e3 	mov	x3, x21
     b84:	91000042 	add	x2, x2, #0x0
			b84: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x128
     b88:	aa1403e1 	mov	x1, x20
     b8c:	aa0403e0 	mov	x0, x4
     b90:	94000000 	bl	0 <__dynamic_dev_dbg>
			b90: R_AARCH64_CALL26	__dynamic_dev_dbg
     b94:	17ffffcc 	b	ac4 <device_rename+0x48>

0000000000000b98 <dev_driver_string.part.12>:
	 * so be careful about accessing it.  dev->bus and dev->class should
	 * never change once they are set, so they don't need special care.
	 */
	drv = ACCESS_ONCE(dev->driver);
	return drv ? drv->name :
			(dev->bus ? dev->bus->name :
     b98:	f9404401 	ldr	x1, [x0,#136]
     b9c:	b4000061 	cbz	x1, ba8 <dev_driver_string.part.12+0x10>
     ba0:	f9400020 	ldr	x0, [x1]
			(dev->class ? dev->class->name : ""));
}
     ba4:	d65f03c0 	ret
	 * never change once they are set, so they don't need special care.
	 */
	drv = ACCESS_ONCE(dev->driver);
	return drv ? drv->name :
			(dev->bus ? dev->bus->name :
			(dev->class ? dev->class->name : ""));
     ba8:	f9414c00 	ldr	x0, [x0,#664]
     bac:	b4000060 	cbz	x0, bb8 <dev_driver_string.part.12+0x20>
     bb0:	f9400000 	ldr	x0, [x0]
}
     bb4:	d65f03c0 	ret
	 * never change once they are set, so they don't need special care.
	 */
	drv = ACCESS_ONCE(dev->driver);
	return drv ? drv->name :
			(dev->bus ? dev->bus->name :
			(dev->class ? dev->class->name : ""));
     bb8:	90000000 	adrp	x0, 0 <dev_attr_store>
			bb8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x138
     bbc:	91000000 	add	x0, x0, #0x0
			bbc: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x138
}
     bc0:	d65f03c0 	ret

0000000000000bc4 <dev_driver_string>:
 * the device is not bound to a driver, it will return the name of the bus
 * it is attached to.  If it is not attached to a bus either, an empty
 * string will be returned.
 */
const char *dev_driver_string(const struct device *dev)
{
     bc4:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
     bc8:	910003fd 	mov	x29, sp

	/* dev->driver can change to NULL underneath us because of unbinding,
	 * so be careful about accessing it.  dev->bus and dev->class should
	 * never change once they are set, so they don't need special care.
	 */
	drv = ACCESS_ONCE(dev->driver);
     bcc:	f9404801 	ldr	x1, [x0,#144]
	return drv ? drv->name :
     bd0:	b4000081 	cbz	x1, be0 <dev_driver_string+0x1c>
     bd4:	f9400020 	ldr	x0, [x1]
			(dev->bus ? dev->bus->name :
			(dev->class ? dev->class->name : ""));
}
     bd8:	a8c17bfd 	ldp	x29, x30, [sp],#16
     bdc:	d65f03c0 	ret
     be0:	97ffffee 	bl	b98 <dev_driver_string.part.12>
     be4:	a8c17bfd 	ldp	x29, x30, [sp],#16
     be8:	d65f03c0 	ret

0000000000000bec <dev_attr_show>:

#define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)

static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,
			     char *buf)
{
     bec:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
	bool			offline:1;
};

static inline struct device *kobj_to_dev(struct kobject *kobj)
{
	return container_of(kobj, struct device, kobj);
     bf0:	d1004000 	sub	x0, x0, #0x10
     bf4:	910003fd 	mov	x29, sp
     bf8:	a90153f3 	stp	x19, x20, [sp,#16]
	struct device_attribute *dev_attr = to_dev_attr(attr);
	struct device *dev = kobj_to_dev(kobj);
	ssize_t ret = -EIO;

	if (dev_attr->show)
     bfc:	f9400824 	ldr	x4, [x1,#16]
     c00:	b40001c4 	cbz	x4, c38 <dev_attr_show+0x4c>
     c04:	aa0103f3 	mov	x19, x1
		ret = dev_attr->show(dev, dev_attr, buf);
     c08:	d63f0080 	blr	x4
	if (ret >= (ssize_t)PAGE_SIZE) {
     c0c:	f13ffc1f 	cmp	x0, #0xfff
	struct device_attribute *dev_attr = to_dev_attr(attr);
	struct device *dev = kobj_to_dev(kobj);
	ssize_t ret = -EIO;

	if (dev_attr->show)
		ret = dev_attr->show(dev, dev_attr, buf);
     c10:	aa0003f4 	mov	x20, x0
	if (ret >= (ssize_t)PAGE_SIZE) {
     c14:	540000ad 	b.le	c28 <dev_attr_show+0x3c>
}

static inline void print_symbol(const char *fmt, unsigned long addr)
{
	__check_printsym_format(fmt, "");
	__print_symbol(fmt, (unsigned long)
     c18:	90000000 	adrp	x0, 0 <dev_attr_store>
			c18: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x140
     c1c:	f9400a61 	ldr	x1, [x19,#16]
     c20:	91000000 	add	x0, x0, #0x0
			c20: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x140
     c24:	94000000 	bl	0 <__print_symbol>
			c24: R_AARCH64_CALL26	__print_symbol
		print_symbol("dev_attr_show: %s returned bad count\n",
				(unsigned long)dev_attr->show);
	}
	return ret;
}
     c28:	aa1403e0 	mov	x0, x20
     c2c:	a94153f3 	ldp	x19, x20, [sp,#16]
     c30:	a8c27bfd 	ldp	x29, x30, [sp],#32
     c34:	d65f03c0 	ret
static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,
			     char *buf)
{
	struct device_attribute *dev_attr = to_dev_attr(attr);
	struct device *dev = kobj_to_dev(kobj);
	ssize_t ret = -EIO;
     c38:	92800094 	mov	x20, #0xfffffffffffffffb    	// #-5
     c3c:	17fffffb 	b	c28 <dev_attr_show+0x3c>

0000000000000c40 <dev_uevent_name>:

static const char *dev_uevent_name(struct kset *kset, struct kobject *kobj)
{
	struct device *dev = kobj_to_dev(kobj);

	if (dev->bus)
     c40:	d1004021 	sub	x1, x1, #0x10
     c44:	f9404420 	ldr	x0, [x1,#136]
     c48:	b4000060 	cbz	x0, c54 <dev_uevent_name+0x14>
		return dev->bus->name;
	if (dev->class)
		return dev->class->name;
     c4c:	f9400000 	ldr	x0, [x0]
	return NULL;
}
     c50:	d65f03c0 	ret
{
	struct device *dev = kobj_to_dev(kobj);

	if (dev->bus)
		return dev->bus->name;
	if (dev->class)
     c54:	f9414c20 	ldr	x0, [x1,#664]
     c58:	b5ffffa0 	cbnz	x0, c4c <dev_uevent_name+0xc>
		return dev->class->name;
	return NULL;
     c5c:	d2800000 	mov	x0, #0x0                   	// #0
}
     c60:	d65f03c0 	ret

0000000000000c64 <set_primary_fwnode>:
 * Set the device's firmware node pointer to @fwnode, but if a secondary
 * firmware node of the device is present, preserve it.
 */
void set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode)
{
	if (fwnode) {
     c64:	b40001c1 	cbz	x1, c9c <set_primary_fwnode+0x38>
		struct fwnode_handle *fn = dev->fwnode;
     c68:	f9412803 	ldr	x3, [x0,#592]

#endif

static inline bool fwnode_is_primary(struct fwnode_handle *fwnode)
{
	return fwnode && !IS_ERR(fwnode->secondary);
     c6c:	b4000103 	cbz	x3, c8c <set_primary_fwnode+0x28>
     c70:	f9400462 	ldr	x2, [x3,#8]
     c74:	b140045f 	cmn	x2, #0x1, lsl #12
     c78:	54000208 	b.hi	cb8 <set_primary_fwnode+0x54>
		struct fwnode_handle *fn = dev->fwnode;

		if (fwnode_is_primary(fn))
			fn = fn->secondary;

		if (fn) {
     c7c:	b4000082 	cbz	x2, c8c <set_primary_fwnode+0x28>
			WARN_ON(fwnode->secondary);
     c80:	f9400423 	ldr	x3, [x1,#8]
     c84:	b5000083 	cbnz	x3, c94 <set_primary_fwnode+0x30>
			fwnode->secondary = fn;
     c88:	f9000422 	str	x2, [x1,#8]
		}
		dev->fwnode = fwnode;
	} else {
		dev->fwnode = fwnode_is_primary(dev->fwnode) ?
     c8c:	f9012801 	str	x1, [x0,#592]
			dev->fwnode->secondary : NULL;
	}
}
     c90:	d65f03c0 	ret

		if (fwnode_is_primary(fn))
			fn = fn->secondary;

		if (fn) {
			WARN_ON(fwnode->secondary);
     c94:	d4210000 	brk	#0x800
     c98:	17fffffc 	b	c88 <set_primary_fwnode+0x24>
			fwnode->secondary = fn;
		}
		dev->fwnode = fwnode;
	} else {
		dev->fwnode = fwnode_is_primary(dev->fwnode) ?
     c9c:	f9412801 	ldr	x1, [x0,#592]

#endif

static inline bool fwnode_is_primary(struct fwnode_handle *fwnode)
{
	return fwnode && !IS_ERR(fwnode->secondary);
     ca0:	b4ffff61 	cbz	x1, c8c <set_primary_fwnode+0x28>
     ca4:	f9400421 	ldr	x1, [x1,#8]
			fwnode->secondary = fn;
		}
		dev->fwnode = fwnode;
	} else {
		dev->fwnode = fwnode_is_primary(dev->fwnode) ?
			dev->fwnode->secondary : NULL;
     ca8:	b13ffc3f 	cmn	x1, #0xfff
     cac:	9a9f3021 	csel	x1, x1, xzr, cc
			WARN_ON(fwnode->secondary);
			fwnode->secondary = fn;
		}
		dev->fwnode = fwnode;
	} else {
		dev->fwnode = fwnode_is_primary(dev->fwnode) ?
     cb0:	f9012801 	str	x1, [x0,#592]
			dev->fwnode->secondary : NULL;
	}
}
     cb4:	d65f03c0 	ret

#endif

static inline bool fwnode_is_primary(struct fwnode_handle *fwnode)
{
	return fwnode && !IS_ERR(fwnode->secondary);
     cb8:	aa0303e2 	mov	x2, x3
     cbc:	17fffff1 	b	c80 <set_primary_fwnode+0x1c>

0000000000000cc0 <cleanup_glue_dir.isra.17>:
	if (parent)
		return &parent->kobj;
	return NULL;
}

static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)
     cc0:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
     cc4:	910003fd 	mov	x29, sp
     cc8:	a90153f3 	stp	x19, x20, [sp,#16]
{
	/* see if we live in a "glue" directory */
	if (!glue_dir || !dev->class ||
     ccc:	b4000101 	cbz	x1, cec <cleanup_glue_dir.isra.17+0x2c>
     cd0:	f9400000 	ldr	x0, [x0]
     cd4:	b40000c0 	cbz	x0, cec <cleanup_glue_dir.isra.17+0x2c>
	    glue_dir->kset != &dev->class->p->glue_dirs)
     cd8:	f9403802 	ldr	x2, [x0,#112]
}

static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)
{
	/* see if we live in a "glue" directory */
	if (!glue_dir || !dev->class ||
     cdc:	f9401020 	ldr	x0, [x1,#32]
	    glue_dir->kset != &dev->class->p->glue_dirs)
     ce0:	9104e042 	add	x2, x2, #0x138
}

static void cleanup_glue_dir(struct device *dev, struct kobject *glue_dir)
{
	/* see if we live in a "glue" directory */
	if (!glue_dir || !dev->class ||
     ce4:	eb02001f 	cmp	x0, x2
     ce8:	54000080 	b.eq	cf8 <cleanup_glue_dir.isra.17+0x38>
		return;

	mutex_lock(&gdp_mutex);
	kobject_put(glue_dir);
	mutex_unlock(&gdp_mutex);
}
     cec:	a94153f3 	ldp	x19, x20, [sp,#16]
     cf0:	a8c27bfd 	ldp	x29, x30, [sp],#32
     cf4:	d65f03c0 	ret
	/* see if we live in a "glue" directory */
	if (!glue_dir || !dev->class ||
	    glue_dir->kset != &dev->class->p->glue_dirs)
		return;

	mutex_lock(&gdp_mutex);
     cf8:	90000014 	adrp	x20, 0 <dev_attr_store>
			cf8: R_AARCH64_ADR_PREL_PG_HI21	.data
     cfc:	aa0103f3 	mov	x19, x1
     d00:	91000294 	add	x20, x20, #0x0
			d00: R_AARCH64_ADD_ABS_LO12_NC	.data
     d04:	91012294 	add	x20, x20, #0x48
     d08:	aa1403e0 	mov	x0, x20
     d0c:	94000000 	bl	0 <mutex_lock>
			d0c: R_AARCH64_CALL26	mutex_lock
	kobject_put(glue_dir);
     d10:	aa1303e0 	mov	x0, x19
     d14:	94000000 	bl	0 <kobject_put>
			d14: R_AARCH64_CALL26	kobject_put
	mutex_unlock(&gdp_mutex);
     d18:	aa1403e0 	mov	x0, x20
     d1c:	94000000 	bl	0 <mutex_unlock>
			d1c: R_AARCH64_CALL26	mutex_unlock
     d20:	17fffff3 	b	cec <cleanup_glue_dir.isra.17+0x2c>

0000000000000d24 <device_del>:
 *
 * NOTE: this should be called manually _iff_ device_add() was
 * also called manually.
 */
void device_del(struct device *dev)
{
     d24:	a9bb7bfd 	stp	x29, x30, [sp,#-80]!
     d28:	910003fd 	mov	x29, sp
     d2c:	a90153f3 	stp	x19, x20, [sp,#16]
     d30:	a9025bf5 	stp	x21, x22, [sp,#32]
     d34:	f9001bf7 	str	x23, [sp,#48]
     d38:	aa0003f4 	mov	x20, x0
	struct class_interface *class_intf;

	/* Notify clients of device removal.  This call must come
	 * before dpm_sysfs_remove().
	 */
	if (dev->bus)
     d3c:	f9404400 	ldr	x0, [x0,#136]
 * NOTE: this should be called manually _iff_ device_add() was
 * also called manually.
 */
void device_del(struct device *dev)
{
	struct device *parent = dev->parent;
     d40:	f9400296 	ldr	x22, [x20]
	struct class_interface *class_intf;

	/* Notify clients of device removal.  This call must come
	 * before dpm_sysfs_remove().
	 */
	if (dev->bus)
     d44:	b40000c0 	cbz	x0, d5c <device_del+0x38>
		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
     d48:	f9404800 	ldr	x0, [x0,#144]
     d4c:	aa1403e2 	mov	x2, x20
     d50:	d2800041 	mov	x1, #0x2                   	// #2
     d54:	9103e000 	add	x0, x0, #0xf8
     d58:	94000000 	bl	0 <blocking_notifier_call_chain>
			d58: R_AARCH64_CALL26	blocking_notifier_call_chain
					     BUS_NOTIFY_DEL_DEVICE, dev);
	dpm_sysfs_remove(dev);
     d5c:	aa1403e0 	mov	x0, x20
     d60:	94000000 	bl	0 <dpm_sysfs_remove>
			d60: R_AARCH64_CALL26	dpm_sysfs_remove
	if (parent)
     d64:	b4000096 	cbz	x22, d74 <device_del+0x50>
		klist_del(&dev->p->knode_parent);
     d68:	f9400680 	ldr	x0, [x20,#8]
     d6c:	9100a000 	add	x0, x0, #0x28
     d70:	94000000 	bl	0 <klist_del>
			d70: R_AARCH64_CALL26	klist_del
	if (MAJOR(dev->devt)) {
     d74:	b9425a81 	ldr	w1, [x20,#600]
     d78:	53147c21 	lsr	w1, w1, #20
     d7c:	35000981 	cbnz	w1, eac <device_del+0x188>
     d80:	90000015 	adrp	x21, 0 <dev_attr_store>
			d80: R_AARCH64_ADR_PREL_PG_HI21	.bss
		devtmpfs_delete_node(dev);
		device_remove_sys_dev_entry(dev);
		device_remove_file(dev, &dev_attr_dev);
	}
	if (dev->class) {
     d84:	f9414e80 	ldr	x0, [x20,#664]
     d88:	91004297 	add	x23, x20, #0x10
     d8c:	b40003a0 	cbz	x0, e00 <device_del+0xdc>
		device_remove_class_symlinks(dev);
     d90:	aa1403e0 	mov	x0, x20
     d94:	97fffeab 	bl	840 <device_remove_class_symlinks>

		mutex_lock(&dev->class->p->mutex);
     d98:	f9414e80 	ldr	x0, [x20,#664]
     d9c:	f9403800 	ldr	x0, [x0,#112]
     da0:	9101e000 	add	x0, x0, #0x78
     da4:	94000000 	bl	0 <mutex_lock>
			da4: R_AARCH64_CALL26	mutex_lock
		/* notify any interfaces that the device is now gone */
		list_for_each_entry(class_intf,
     da8:	f9414e83 	ldr	x3, [x20,#664]
     dac:	f9403860 	ldr	x0, [x3,#112]
     db0:	f8468c13 	ldr	x19, [x0,#104]!
     db4:	eb00027f 	cmp	x19, x0
     db8:	54000180 	b.eq	de8 <device_del+0xc4>
				    &dev->class->p->interfaces, node)
			if (class_intf->remove_dev)
     dbc:	f9401262 	ldr	x2, [x19,#32]
				class_intf->remove_dev(dev, class_intf);
     dc0:	aa1303e1 	mov	x1, x19
     dc4:	aa1403e0 	mov	x0, x20

		mutex_lock(&dev->class->p->mutex);
		/* notify any interfaces that the device is now gone */
		list_for_each_entry(class_intf,
				    &dev->class->p->interfaces, node)
			if (class_intf->remove_dev)
     dc8:	b4000062 	cbz	x2, dd4 <device_del+0xb0>
				class_intf->remove_dev(dev, class_intf);
     dcc:	d63f0040 	blr	x2
     dd0:	f9414e83 	ldr	x3, [x20,#664]
	if (dev->class) {
		device_remove_class_symlinks(dev);

		mutex_lock(&dev->class->p->mutex);
		/* notify any interfaces that the device is now gone */
		list_for_each_entry(class_intf,
     dd4:	f9403861 	ldr	x1, [x3,#112]
     dd8:	f9400273 	ldr	x19, [x19]
     ddc:	9101a021 	add	x1, x1, #0x68
     de0:	eb01027f 	cmp	x19, x1
     de4:	54fffec1 	b.ne	dbc <device_del+0x98>
				    &dev->class->p->interfaces, node)
			if (class_intf->remove_dev)
				class_intf->remove_dev(dev, class_intf);
		/* remove the device from the class list */
		klist_del(&dev->knode_class);
     de8:	9109e280 	add	x0, x20, #0x278
     dec:	94000000 	bl	0 <klist_del>
			dec: R_AARCH64_CALL26	klist_del
		mutex_unlock(&dev->class->p->mutex);
     df0:	f9414e80 	ldr	x0, [x20,#664]
     df4:	f9403800 	ldr	x0, [x0,#112]
     df8:	9101e000 	add	x0, x0, #0x78
     dfc:	94000000 	bl	0 <mutex_unlock>
			dfc: R_AARCH64_CALL26	mutex_unlock
 * @attr: device attribute descriptor.
 */
void device_remove_file(struct device *dev,
			const struct device_attribute *attr)
{
	if (dev)
     e00:	b40000f4 	cbz	x20, e1c <device_del+0xf8>
     e04:	90000013 	adrp	x19, 0 <dev_attr_store>
			e04: R_AARCH64_ADR_PREL_PG_HI21	.data
     e08:	91000261 	add	x1, x19, #0x0
			e08: R_AARCH64_ADD_ABS_LO12_NC	.data
     e0c:	d2800002 	mov	x2, #0x0                   	// #0
     e10:	91024021 	add	x1, x1, #0x90
     e14:	aa1703e0 	mov	x0, x23
     e18:	94000000 	bl	0 <sysfs_remove_file_ns>
			e18: R_AARCH64_CALL26	sysfs_remove_file_ns
		/* remove the device from the class list */
		klist_del(&dev->knode_class);
		mutex_unlock(&dev->class->p->mutex);
	}
	device_remove_file(dev, &dev_attr_uevent);
	device_remove_attrs(dev);
     e1c:	aa1403e0 	mov	x0, x20
	driver_deferred_probe_del(dev);

	/* Notify the platform of the removal, in case they
	 * need to do anything...
	 */
	if (platform_notify_remove)
     e20:	910002b5 	add	x21, x21, #0x0
			e20: R_AARCH64_ADD_ABS_LO12_NC	.bss
		/* remove the device from the class list */
		klist_del(&dev->knode_class);
		mutex_unlock(&dev->class->p->mutex);
	}
	device_remove_file(dev, &dev_attr_uevent);
	device_remove_attrs(dev);
     e24:	97fffd37 	bl	300 <device_remove_attrs>
	bus_remove_device(dev);
     e28:	aa1403e0 	mov	x0, x20
     e2c:	94000000 	bl	0 <bus_remove_device>
			e2c: R_AARCH64_CALL26	bus_remove_device
	device_pm_remove(dev);
     e30:	aa1403e0 	mov	x0, x20
     e34:	94000000 	bl	0 <device_pm_remove>
			e34: R_AARCH64_CALL26	device_pm_remove
	driver_deferred_probe_del(dev);
     e38:	aa1403e0 	mov	x0, x20
     e3c:	94000000 	bl	0 <driver_deferred_probe_del>
			e3c: R_AARCH64_CALL26	driver_deferred_probe_del

	/* Notify the platform of the removal, in case they
	 * need to do anything...
	 */
	if (platform_notify_remove)
     e40:	f9400aa1 	ldr	x1, [x21,#16]
     e44:	b4000061 	cbz	x1, e50 <device_del+0x12c>
		platform_notify_remove(dev);
     e48:	aa1403e0 	mov	x0, x20
     e4c:	d63f0020 	blr	x1
	if (dev->bus)
     e50:	f9404680 	ldr	x0, [x20,#136]
     e54:	b40000c0 	cbz	x0, e6c <device_del+0x148>
		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
     e58:	f9404800 	ldr	x0, [x0,#144]
     e5c:	aa1403e2 	mov	x2, x20
     e60:	d2800061 	mov	x1, #0x3                   	// #3
     e64:	9103e000 	add	x0, x0, #0xf8
     e68:	94000000 	bl	0 <blocking_notifier_call_chain>
			e68: R_AARCH64_CALL26	blocking_notifier_call_chain
					     BUS_NOTIFY_REMOVED_DEVICE, dev);
	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
     e6c:	52800021 	mov	w1, #0x1                   	// #1
     e70:	aa1703e0 	mov	x0, x23
     e74:	94000000 	bl	0 <kobject_uevent>
			e74: R_AARCH64_CALL26	kobject_uevent
	mutex_unlock(&gdp_mutex);
}

static void cleanup_device_parent(struct device *dev)
{
	cleanup_glue_dir(dev, dev->kobj.parent);
     e78:	f9401681 	ldr	x1, [x20,#40]
     e7c:	910a6280 	add	x0, x20, #0x298
     e80:	97ffff90 	bl	cc0 <cleanup_glue_dir.isra.17>
	if (dev->bus)
		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
					     BUS_NOTIFY_REMOVED_DEVICE, dev);
	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
	cleanup_device_parent(dev);
	kobject_del(&dev->kobj);
     e84:	aa1703e0 	mov	x0, x23
     e88:	94000000 	bl	0 <kobject_del>
			e88: R_AARCH64_CALL26	kobject_del
 * @dev: device in question.
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
     e8c:	b4000076 	cbz	x22, e98 <device_del+0x174>
		kobject_put(&dev->kobj);
     e90:	910042c0 	add	x0, x22, #0x10
     e94:	94000000 	bl	0 <kobject_put>
			e94: R_AARCH64_CALL26	kobject_put
					     BUS_NOTIFY_REMOVED_DEVICE, dev);
	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
	cleanup_device_parent(dev);
	kobject_del(&dev->kobj);
	put_device(parent);
}
     e98:	a94153f3 	ldp	x19, x20, [sp,#16]
     e9c:	a9425bf5 	ldp	x21, x22, [sp,#32]
     ea0:	f9401bf7 	ldr	x23, [sp,#48]
     ea4:	a8c57bfd 	ldp	x29, x30, [sp],#80
     ea8:	d65f03c0 	ret
					     BUS_NOTIFY_DEL_DEVICE, dev);
	dpm_sysfs_remove(dev);
	if (parent)
		klist_del(&dev->p->knode_parent);
	if (MAJOR(dev->devt)) {
		devtmpfs_delete_node(dev);
     eac:	aa1403e0 	mov	x0, x20
     eb0:	94000000 	bl	0 <devtmpfs_delete_node>
			eb0: R_AARCH64_CALL26	devtmpfs_delete_node
     eb4:	f9414e80 	ldr	x0, [x20,#664]
 */
static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;

	if (dev->class)
     eb8:	b4000320 	cbz	x0, f1c <device_del+0x1f8>
		kobj = dev->class->dev_kobj;
     ebc:	f9401013 	ldr	x19, [x0,#32]
     ec0:	90000015 	adrp	x21, 0 <dev_attr_store>
			ec0: R_AARCH64_ADR_PREL_PG_HI21	.bss
static void device_remove_sys_dev_entry(struct device *dev)
{
	struct kobject *kobj = device_to_dev_kobj(dev);
	char devt_str[15];

	if (kobj) {
     ec4:	b4000173 	cbz	x19, ef0 <device_del+0x1cc>
		format_dev_t(devt_str, dev->devt);
     ec8:	b9425a82 	ldr	w2, [x20,#600]
     ecc:	90000001 	adrp	x1, 0 <dev_attr_store>
			ecc: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x168
     ed0:	91000021 	add	x1, x1, #0x0
			ed0: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x168
     ed4:	910103a0 	add	x0, x29, #0x40
     ed8:	12004c43 	and	w3, w2, #0xfffff
     edc:	53147c42 	lsr	w2, w2, #20
     ee0:	94000000 	bl	0 <sprintf>
			ee0: R_AARCH64_CALL26	sprintf
		sysfs_remove_link(kobj, devt_str);
     ee4:	910103a1 	add	x1, x29, #0x40
     ee8:	aa1303e0 	mov	x0, x19
     eec:	94000000 	bl	0 <sysfs_remove_link>
			eec: R_AARCH64_CALL26	sysfs_remove_link
 * @attr: device attribute descriptor.
 */
void device_remove_file(struct device *dev,
			const struct device_attribute *attr)
{
	if (dev)
     ef0:	b4fff4b4 	cbz	x20, d84 <device_del+0x60>
     ef4:	90000013 	adrp	x19, 0 <dev_attr_store>
			ef4: R_AARCH64_ADR_PREL_PG_HI21	.data
		sysfs_remove_file(&dev->kobj, &attr->attr);
     ef8:	91004297 	add	x23, x20, #0x10
     efc:	91000261 	add	x1, x19, #0x0
			efc: R_AARCH64_ADD_ABS_LO12_NC	.data
     f00:	aa1703e0 	mov	x0, x23
     f04:	d2800002 	mov	x2, #0x0                   	// #0
     f08:	9101c021 	add	x1, x1, #0x70
     f0c:	94000000 	bl	0 <sysfs_remove_file_ns>
			f0c: R_AARCH64_CALL26	sysfs_remove_file_ns
	if (MAJOR(dev->devt)) {
		devtmpfs_delete_node(dev);
		device_remove_sys_dev_entry(dev);
		device_remove_file(dev, &dev_attr_dev);
	}
	if (dev->class) {
     f10:	f9414e80 	ldr	x0, [x20,#664]
     f14:	b5fff3e0 	cbnz	x0, d90 <device_del+0x6c>
     f18:	17ffffbc 	b	e08 <device_del+0xe4>
	struct kobject *kobj;

	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;
     f1c:	90000015 	adrp	x21, 0 <dev_attr_store>
			f1c: R_AARCH64_ADR_PREL_PG_HI21	.bss
     f20:	910002a0 	add	x0, x21, #0x0
			f20: R_AARCH64_ADD_ABS_LO12_NC	.bss
     f24:	f9400413 	ldr	x19, [x0,#8]
     f28:	17ffffe7 	b	ec4 <device_del+0x1a0>

0000000000000f2c <device_unregister>:
 * is the final reference count, the device will be cleaned up
 * via device_release() above. Otherwise, the structure will
 * stick around until the final reference to the device is dropped.
 */
void device_unregister(struct device *dev)
{
     f2c:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
     f30:	90000001 	adrp	x1, 0 <dev_attr_store>
			f30: R_AARCH64_ADR_PREL_PG_HI21	__verbose
 * is the final reference count, the device will be cleaned up
 * via device_release() above. Otherwise, the structure will
 * stick around until the final reference to the device is dropped.
 */
void device_unregister(struct device *dev)
{
     f34:	910003fd 	mov	x29, sp
     f38:	f9000bf3 	str	x19, [sp,#16]
     f3c:	aa0003f3 	mov	x19, x0
	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
     f40:	91000020 	add	x0, x1, #0x0
			f40: R_AARCH64_ADD_ABS_LO12_NC	__verbose
     f44:	7940e400 	ldrh	w0, [x0,#114]
     f48:	37100120 	tbnz	w0, #2, f6c <device_unregister+0x40>
	device_del(dev);
     f4c:	aa1303e0 	mov	x0, x19
     f50:	94000000 	bl	d24 <device_del>
			f50: R_AARCH64_CALL26	device_del
 * @dev: device in question.
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
     f54:	b4000073 	cbz	x19, f60 <device_unregister+0x34>
		kobject_put(&dev->kobj);
     f58:	91004260 	add	x0, x19, #0x10
     f5c:	94000000 	bl	0 <kobject_put>
			f5c: R_AARCH64_CALL26	kobject_put
void device_unregister(struct device *dev)
{
	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
	device_del(dev);
	put_device(dev);
}
     f60:	f9400bf3 	ldr	x19, [sp,#16]
     f64:	a8c27bfd 	ldp	x29, x30, [sp],#32
     f68:	d65f03c0 	ret
#include <linux/pm_wakeup.h>

static inline const char *dev_name(const struct device *dev)
{
	/* Use the init name until the kobject becomes available */
	if (dev->init_name)
     f6c:	f9402a62 	ldr	x2, [x19,#80]
     f70:	b4000142 	cbz	x2, f98 <device_unregister+0x6c>
 * via device_release() above. Otherwise, the structure will
 * stick around until the final reference to the device is dropped.
 */
void device_unregister(struct device *dev)
{
	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
     f74:	90000003 	adrp	x3, 0 <dev_attr_store>
			f74: R_AARCH64_ADR_PREL_PG_HI21	.rodata
     f78:	91000020 	add	x0, x1, #0x0
			f78: R_AARCH64_ADD_ABS_LO12_NC	__verbose
     f7c:	91000063 	add	x3, x3, #0x0
			f7c: R_AARCH64_ADD_ABS_LO12_NC	.rodata
     f80:	90000001 	adrp	x1, 0 <dev_attr_store>
			f80: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0xc8
     f84:	91006063 	add	x3, x3, #0x18
     f88:	91000021 	add	x1, x1, #0x0
			f88: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0xc8
     f8c:	91014000 	add	x0, x0, #0x50
     f90:	94000000 	bl	0 <__dynamic_pr_debug>
			f90: R_AARCH64_CALL26	__dynamic_pr_debug
     f94:	17ffffee 	b	f4c <device_unregister+0x20>
     f98:	f9400a62 	ldr	x2, [x19,#16]
     f9c:	17fffff6 	b	f74 <device_unregister+0x48>

0000000000000fa0 <root_device_unregister>:
 *
 * This function unregisters and cleans up a device that was created by
 * root_device_register().
 */
void root_device_unregister(struct device *dev)
{
     fa0:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
     fa4:	910003fd 	mov	x29, sp
     fa8:	f9000bf3 	str	x19, [sp,#16]
     fac:	aa0003f3 	mov	x19, x0
	struct root_device *root = to_root_device(dev);

	if (root->owner)
     fb0:	f9416000 	ldr	x0, [x0,#704]
     fb4:	b40000a0 	cbz	x0, fc8 <root_device_unregister+0x28>
		sysfs_remove_link(&root->dev.kobj, "module");
     fb8:	90000001 	adrp	x1, 0 <dev_attr_store>
			fb8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x170
     fbc:	91004260 	add	x0, x19, #0x10
     fc0:	91000021 	add	x1, x1, #0x0
			fc0: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x170
     fc4:	94000000 	bl	0 <sysfs_remove_link>
			fc4: R_AARCH64_CALL26	sysfs_remove_link

	device_unregister(dev);
     fc8:	aa1303e0 	mov	x0, x19
     fcc:	94000000 	bl	f2c <device_unregister>
			fcc: R_AARCH64_CALL26	device_unregister
}
     fd0:	f9400bf3 	ldr	x19, [sp,#16]
     fd4:	a8c27bfd 	ldp	x29, x30, [sp],#32
     fd8:	d65f03c0 	ret

0000000000000fdc <device_destroy>:
 *
 * This call unregisters and cleans up a device that was created with a
 * call to device_create().
 */
void device_destroy(struct class *class, dev_t devt)
{
     fdc:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
	struct device *dev;

	dev = class_find_device(class, NULL, &devt, __match_devt);
     fe0:	90000003 	adrp	x3, 0 <dev_attr_store>
			fe0: R_AARCH64_ADR_PREL_PG_HI21	.text+0xa4
 *
 * This call unregisters and cleans up a device that was created with a
 * call to device_create().
 */
void device_destroy(struct class *class, dev_t devt)
{
     fe4:	910003fd 	mov	x29, sp
     fe8:	9100c3a2 	add	x2, x29, #0x30
     fec:	f9000bf3 	str	x19, [sp,#16]
	struct device *dev;

	dev = class_find_device(class, NULL, &devt, __match_devt);
     ff0:	91000063 	add	x3, x3, #0x0
			ff0: R_AARCH64_ADD_ABS_LO12_NC	.text+0xa4
 *
 * This call unregisters and cleans up a device that was created with a
 * call to device_create().
 */
void device_destroy(struct class *class, dev_t devt)
{
     ff4:	b81fcc41 	str	w1, [x2,#-4]!
	struct device *dev;

	dev = class_find_device(class, NULL, &devt, __match_devt);
     ff8:	d2800001 	mov	x1, #0x0                   	// #0
     ffc:	94000000 	bl	0 <class_find_device>
			ffc: R_AARCH64_CALL26	class_find_device
    1000:	aa0003f3 	mov	x19, x0
	if (dev) {
    1004:	b40000a0 	cbz	x0, 1018 <device_destroy+0x3c>
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
		kobject_put(&dev->kobj);
    1008:	91004000 	add	x0, x0, #0x10
    100c:	94000000 	bl	0 <kobject_put>
			100c: R_AARCH64_CALL26	kobject_put
	struct device *dev;

	dev = class_find_device(class, NULL, &devt, __match_devt);
	if (dev) {
		put_device(dev);
		device_unregister(dev);
    1010:	aa1303e0 	mov	x0, x19
    1014:	94000000 	bl	f2c <device_unregister>
			1014: R_AARCH64_CALL26	device_unregister
	}
}
    1018:	f9400bf3 	ldr	x19, [sp,#16]
    101c:	a8c37bfd 	ldp	x29, x30, [sp],#48
    1020:	d65f03c0 	ret

0000000000001024 <device_check_offline>:
	kset_unregister(devices_kset);
	return -ENOMEM;
}

static int device_check_offline(struct device *dev, void *not_used)
{
    1024:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
	int ret;

	ret = device_for_each_child(dev, NULL, device_check_offline);
    1028:	90000002 	adrp	x2, 0 <dev_attr_store>
			1028: R_AARCH64_ADR_PREL_PG_HI21	.text+0x1024
    102c:	d2800001 	mov	x1, #0x0                   	// #0
	kset_unregister(devices_kset);
	return -ENOMEM;
}

static int device_check_offline(struct device *dev, void *not_used)
{
    1030:	910003fd 	mov	x29, sp
	int ret;

	ret = device_for_each_child(dev, NULL, device_check_offline);
    1034:	91000042 	add	x2, x2, #0x0
			1034: R_AARCH64_ADD_ABS_LO12_NC	.text+0x1024
	kset_unregister(devices_kset);
	return -ENOMEM;
}

static int device_check_offline(struct device *dev, void *not_used)
{
    1038:	f9000bf3 	str	x19, [sp,#16]
    103c:	aa0003f3 	mov	x19, x0
	int ret;

	ret = device_for_each_child(dev, NULL, device_check_offline);
    1040:	94000000 	bl	8e0 <device_for_each_child>
			1040: R_AARCH64_CALL26	device_for_each_child
	if (ret)
    1044:	35000180 	cbnz	w0, 1074 <device_check_offline+0x50>
    1048:	f9404661 	ldr	x1, [x19,#136]
				      umode_t *mode, kuid_t *uid, kgid_t *gid,
				      const char **tmp);

static inline bool device_supports_offline(struct device *dev)
{
	return dev->bus && dev->bus->offline && dev->bus->online;
    104c:	b4000141 	cbz	x1, 1074 <device_check_offline+0x50>
    1050:	f9403422 	ldr	x2, [x1,#104]
    1054:	b4000102 	cbz	x2, 1074 <device_check_offline+0x50>
    1058:	f9403021 	ldr	x1, [x1,#96]
    105c:	b40000c1 	cbz	x1, 1074 <device_check_offline+0x50>
		return ret;

	return device_supports_offline(dev) && !dev->offline ? -EBUSY : 0;
    1060:	394ae260 	ldrb	w0, [x19,#696]
    1064:	d3410400 	ubfx	x0, x0, #1, #1
    1068:	6b1f001f 	cmp	w0, wzr
    106c:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    1070:	1a9f0000 	csel	w0, w0, wzr, eq
}
    1074:	f9400bf3 	ldr	x19, [sp,#16]
    1078:	a8c27bfd 	ldp	x29, x30, [sp],#32
    107c:	d65f03c0 	ret

0000000000001080 <dev_vprintk_emit>:
	return 0;
}

int dev_vprintk_emit(int level, const struct device *dev,
		     const char *fmt, va_list args)
{
    1080:	a9af7bfd 	stp	x29, x30, [sp,#-272]!
    1084:	910003fd 	mov	x29, sp
    1088:	a90363f7 	stp	x23, x24, [sp,#48]
    108c:	a9025bf5 	stp	x21, x22, [sp,#32]
    1090:	a9046bf9 	stp	x25, x26, [sp,#64]
    1094:	a90153f3 	stp	x19, x20, [sp,#16]
    1098:	f9002bfb 	str	x27, [sp,#80]
    109c:	2a0003f7 	mov	w23, w0
    10a0:	aa0103f9 	mov	x25, x1
    10a4:	aa0203f8 	mov	x24, x2
create_syslog_header(const struct device *dev, char *hdr, size_t hdrlen)
{
	const char *subsys;
	size_t pos = 0;

	if (dev->class)
    10a8:	f9414c20 	ldr	x0, [x1,#664]
	return 0;
}

int dev_vprintk_emit(int level, const struct device *dev,
		     const char *fmt, va_list args)
{
    10ac:	aa0303f6 	mov	x22, x3
create_syslog_header(const struct device *dev, char *hdr, size_t hdrlen)
{
	const char *subsys;
	size_t pos = 0;

	if (dev->class)
    10b0:	b40008e0 	cbz	x0, 11cc <dev_vprintk_emit+0x14c>
		subsys = dev->class->name;
	else if (dev->bus)
		subsys = dev->bus->name;
    10b4:	f940001a 	ldr	x26, [x0]
	else
		return 0;

	pos += snprintf(hdr + pos, hdrlen - pos, "SUBSYSTEM=%s", subsys);
    10b8:	910243b4 	add	x20, x29, #0x90
    10bc:	90000002 	adrp	x2, 0 <dev_attr_store>
			10bc: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x178
    10c0:	d2801001 	mov	x1, #0x80                  	// #128
    10c4:	aa1a03e3 	mov	x3, x26
    10c8:	91000042 	add	x2, x2, #0x0
			10c8: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x178
    10cc:	aa1403e0 	mov	x0, x20
    10d0:	94000000 	bl	0 <snprintf>
			10d0: R_AARCH64_CALL26	snprintf
    10d4:	93407c15 	sxtw	x21, w0
	if (pos >= hdrlen)
    10d8:	f101febf 	cmp	x21, #0x7f
    10dc:	540009c8 	b.hi	1214 <dev_vprintk_emit+0x194>
	 *   b12:8         block dev_t
	 *   c127:3        char dev_t
	 *   n8            netdev ifindex
	 *   +sound:card0  subsystem:devname
	 */
	if (MAJOR(dev->devt)) {
    10e0:	b9425b3b 	ldr	w27, [x25,#600]
    10e4:	53147f64 	lsr	w4, w27, #20
    10e8:	350004a4 	cbnz	w4, 117c <dev_vprintk_emit+0xfc>
			c = 'c';
		pos++;
		pos += snprintf(hdr + pos, hdrlen - pos,
				"DEVICE=%c%u:%u",
				c, MAJOR(dev->devt), MINOR(dev->devt));
	} else if (strcmp(subsys, "net") == 0) {
    10ec:	90000001 	adrp	x1, 0 <dev_attr_store>
			10ec: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x1a0
    10f0:	aa1a03e0 	mov	x0, x26
    10f4:	91000021 	add	x1, x1, #0x0
			10f4: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x1a0
    10f8:	94000000 	bl	0 <strcmp>
			10f8: R_AARCH64_CALL26	strcmp
    10fc:	34000720 	cbz	w0, 11e0 <dev_vprintk_emit+0x160>
#include <linux/pm_wakeup.h>

static inline const char *dev_name(const struct device *dev)
{
	/* Use the init name until the kobject becomes available */
	if (dev->init_name)
    1100:	f9402b24 	ldr	x4, [x25,#80]

		pos++;
		pos += snprintf(hdr + pos, hdrlen - pos,
				"DEVICE=n%u", net->ifindex);
	} else {
		pos++;
    1104:	910006b3 	add	x19, x21, #0x1
		pos += snprintf(hdr + pos, hdrlen - pos,
    1108:	d2800fe1 	mov	x1, #0x7f                  	// #127
    110c:	8b130280 	add	x0, x20, x19
    1110:	cb150021 	sub	x1, x1, x21
    1114:	b40007c4 	cbz	x4, 120c <dev_vprintk_emit+0x18c>
    1118:	90000002 	adrp	x2, 0 <dev_attr_store>
			1118: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x1b8
    111c:	aa1a03e3 	mov	x3, x26
    1120:	91000042 	add	x2, x2, #0x0
			1120: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x1b8
    1124:	94000000 	bl	0 <snprintf>
			1124: R_AARCH64_CALL26	snprintf
    1128:	8b20c263 	add	x3, x19, w0, sxtw
				"DEVICE=+%s:%s", subsys, dev_name(dev));
	}

	if (pos >= hdrlen)
    112c:	f101fc7f 	cmp	x3, #0x7f
    1130:	54000728 	b.hi	1214 <dev_vprintk_emit+0x194>
	char hdr[128];
	size_t hdrlen;

	hdrlen = create_syslog_header(dev, hdr, sizeof(hdr));

	return vprintk_emit(0, level, hdrlen ? hdr : NULL, hdrlen, fmt, args);
    1134:	eb1f007f 	cmp	x3, xzr
    1138:	9a9f1282 	csel	x2, x20, xzr, ne
    113c:	a94026c8 	ldp	x8, x9, [x22]
    1140:	a9411ec6 	ldp	x6, x7, [x22,#16]
    1144:	9101c3a5 	add	x5, x29, #0x70
    1148:	aa1803e4 	mov	x4, x24
    114c:	2a1703e1 	mov	w1, w23
    1150:	52800000 	mov	w0, #0x0                   	// #0
    1154:	a90727a8 	stp	x8, x9, [x29,#112]
    1158:	a9081fa6 	stp	x6, x7, [x29,#128]
    115c:	94000000 	bl	0 <vprintk_emit>
			115c: R_AARCH64_CALL26	vprintk_emit
}
    1160:	f9402bfb 	ldr	x27, [sp,#80]
    1164:	a94153f3 	ldp	x19, x20, [sp,#16]
    1168:	a9425bf5 	ldp	x21, x22, [sp,#32]
    116c:	a94363f7 	ldp	x23, x24, [sp,#48]
    1170:	a9446bf9 	ldp	x25, x26, [sp,#64]
    1174:	a8d17bfd 	ldp	x29, x30, [sp],#272
    1178:	d65f03c0 	ret
	 *   +sound:card0  subsystem:devname
	 */
	if (MAJOR(dev->devt)) {
		char c;

		if (strcmp(subsys, "block") == 0)
    117c:	90000001 	adrp	x1, 0 <dev_attr_store>
			117c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x188
    1180:	aa1a03e0 	mov	x0, x26
    1184:	91000021 	add	x1, x1, #0x0
			1184: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x188
    1188:	b9006fa4 	str	w4, [x29,#108]
			c = 'b';
		else
			c = 'c';
		pos++;
    118c:	910006b3 	add	x19, x21, #0x1
	 *   +sound:card0  subsystem:devname
	 */
	if (MAJOR(dev->devt)) {
		char c;

		if (strcmp(subsys, "block") == 0)
    1190:	94000000 	bl	0 <strcmp>
			1190: R_AARCH64_CALL26	strcmp
    1194:	6b1f001f 	cmp	w0, wzr
			c = 'b';
		else
			c = 'c';
		pos++;
		pos += snprintf(hdr + pos, hdrlen - pos,
    1198:	b9406fa4 	ldr	w4, [x29,#108]
    119c:	52800c60 	mov	w0, #0x63                  	// #99
    11a0:	52800c43 	mov	w3, #0x62                  	// #98
    11a4:	90000002 	adrp	x2, 0 <dev_attr_store>
			11a4: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x190
    11a8:	d2800fe1 	mov	x1, #0x7f                  	// #127
    11ac:	1a800063 	csel	w3, w3, w0, eq
    11b0:	12004f65 	and	w5, w27, #0xfffff
    11b4:	91000042 	add	x2, x2, #0x0
			11b4: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x190
    11b8:	cb150021 	sub	x1, x1, x21
    11bc:	8b130280 	add	x0, x20, x19
    11c0:	94000000 	bl	0 <snprintf>
			11c0: R_AARCH64_CALL26	snprintf
    11c4:	8b20c263 	add	x3, x19, w0, sxtw
    11c8:	17ffffd9 	b	112c <dev_vprintk_emit+0xac>
	const char *subsys;
	size_t pos = 0;

	if (dev->class)
		subsys = dev->class->name;
	else if (dev->bus)
    11cc:	f9404420 	ldr	x0, [x1,#136]
    11d0:	b5fff720 	cbnz	x0, 10b4 <dev_vprintk_emit+0x34>
		     const char *fmt, va_list args)
{
	char hdr[128];
	size_t hdrlen;

	hdrlen = create_syslog_header(dev, hdr, sizeof(hdr));
    11d4:	d2800003 	mov	x3, #0x0                   	// #0

	return vprintk_emit(0, level, hdrlen ? hdr : NULL, hdrlen, fmt, args);
    11d8:	d2800002 	mov	x2, #0x0                   	// #0
    11dc:	17ffffd8 	b	113c <dev_vprintk_emit+0xbc>
				c, MAJOR(dev->devt), MINOR(dev->devt));
	} else if (strcmp(subsys, "net") == 0) {
		struct net_device *net = to_net_dev(dev);

		pos++;
		pos += snprintf(hdr + pos, hdrlen - pos,
    11e0:	d110e320 	sub	x0, x25, #0x438
				"DEVICE=%c%u:%u",
				c, MAJOR(dev->devt), MINOR(dev->devt));
	} else if (strcmp(subsys, "net") == 0) {
		struct net_device *net = to_net_dev(dev);

		pos++;
    11e4:	910006b3 	add	x19, x21, #0x1
		pos += snprintf(hdr + pos, hdrlen - pos,
    11e8:	90000002 	adrp	x2, 0 <dev_attr_store>
			11e8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x1a8
    11ec:	d2800fe1 	mov	x1, #0x7f                  	// #127
    11f0:	91000042 	add	x2, x2, #0x0
			11f0: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x1a8
    11f4:	cb150021 	sub	x1, x1, x21
    11f8:	b9412003 	ldr	w3, [x0,#288]
    11fc:	8b130280 	add	x0, x20, x19
    1200:	94000000 	bl	0 <snprintf>
			1200: R_AARCH64_CALL26	snprintf
    1204:	8b20c263 	add	x3, x19, w0, sxtw
    1208:	17ffffc9 	b	112c <dev_vprintk_emit+0xac>
    120c:	f9400b24 	ldr	x4, [x25,#16]
    1210:	17ffffc2 	b	1118 <dev_vprintk_emit+0x98>

	/* dev->driver can change to NULL underneath us because of unbinding,
	 * so be careful about accessing it.  dev->bus and dev->class should
	 * never change once they are set, so they don't need special care.
	 */
	drv = ACCESS_ONCE(dev->driver);
    1214:	f9404b20 	ldr	x0, [x25,#144]
	return drv ? drv->name :
    1218:	b4000140 	cbz	x0, 1240 <dev_vprintk_emit+0x1c0>
    121c:	f9400000 	ldr	x0, [x0]
    1220:	f9402b22 	ldr	x2, [x25,#80]
    1224:	b4000142 	cbz	x2, 124c <dev_vprintk_emit+0x1cc>
		goto overflow;

	return pos;

overflow:
	dev_WARN(dev, "device/subsystem name too long");
    1228:	aa0003e1 	mov	x1, x0
    122c:	90000000 	adrp	x0, 0 <dev_attr_store>
			122c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x1c8
    1230:	91000000 	add	x0, x0, #0x0
			1230: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x1c8
    1234:	94000000 	bl	0 <printk>
			1234: R_AARCH64_CALL26	printk
    1238:	d4210000 	brk	#0x800
    123c:	17ffffe6 	b	11d4 <dev_vprintk_emit+0x154>
    1240:	aa1903e0 	mov	x0, x25
    1244:	97fffe55 	bl	b98 <dev_driver_string.part.12>
    1248:	17fffff6 	b	1220 <dev_vprintk_emit+0x1a0>
    124c:	f9400b22 	ldr	x2, [x25,#16]
    1250:	17fffff6 	b	1228 <dev_vprintk_emit+0x1a8>

0000000000001254 <dev_printk_emit>:
	return vprintk_emit(0, level, hdrlen ? hdr : NULL, hdrlen, fmt, args);
}
EXPORT_SYMBOL(dev_vprintk_emit);

int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...)
{
    1254:	a9b87bfd 	stp	x29, x30, [sp,#-128]!
    1258:	910003fd 	mov	x29, sp
	va_list args;
	int r;

	va_start(args, fmt);
    125c:	910203a8 	add	x8, x29, #0x80
    1260:	f9001ba8 	str	x8, [x29,#48]
    1264:	f9001fa8 	str	x8, [x29,#56]
    1268:	910143a8 	add	x8, x29, #0x50
    126c:	b9004fbf 	str	wzr, [x29,#76]
    1270:	f90023a8 	str	x8, [x29,#64]
    1274:	128004e8 	mov	w8, #0xffffffd8            	// #-40
    1278:	b9004ba8 	str	w8, [x29,#72]
	return vprintk_emit(0, level, hdrlen ? hdr : NULL, hdrlen, fmt, args);
}
EXPORT_SYMBOL(dev_vprintk_emit);

int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...)
{
    127c:	f90033a4 	str	x4, [x29,#96]
    1280:	f90037a5 	str	x5, [x29,#104]
	va_list args;
	int r;

	va_start(args, fmt);

	r = dev_vprintk_emit(level, dev, fmt, args);
    1284:	a94317a4 	ldp	x4, x5, [x29,#48]
    1288:	a90117a4 	stp	x4, x5, [x29,#16]
    128c:	a94417a4 	ldp	x4, x5, [x29,#64]
	return vprintk_emit(0, level, hdrlen ? hdr : NULL, hdrlen, fmt, args);
}
EXPORT_SYMBOL(dev_vprintk_emit);

int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...)
{
    1290:	f9002fa3 	str	x3, [x29,#88]
	va_list args;
	int r;

	va_start(args, fmt);

	r = dev_vprintk_emit(level, dev, fmt, args);
    1294:	910043a3 	add	x3, x29, #0x10
	return vprintk_emit(0, level, hdrlen ? hdr : NULL, hdrlen, fmt, args);
}
EXPORT_SYMBOL(dev_vprintk_emit);

int dev_printk_emit(int level, const struct device *dev, const char *fmt, ...)
{
    1298:	f9003ba6 	str	x6, [x29,#112]
    129c:	f9003fa7 	str	x7, [x29,#120]
	va_list args;
	int r;

	va_start(args, fmt);

	r = dev_vprintk_emit(level, dev, fmt, args);
    12a0:	a90217a4 	stp	x4, x5, [x29,#32]
    12a4:	94000000 	bl	1080 <dev_vprintk_emit>
			12a4: R_AARCH64_CALL26	dev_vprintk_emit

	va_end(args);

	return r;
}
    12a8:	a8c87bfd 	ldp	x29, x30, [sp],#128
    12ac:	d65f03c0 	ret

00000000000012b0 <__dev_printk>:
EXPORT_SYMBOL(dev_printk_emit);

static void __dev_printk(const char *level, const struct device *dev,
			struct va_format *vaf)
{
    12b0:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
    12b4:	aa0203e5 	mov	x5, x2
    12b8:	910003fd 	mov	x29, sp
    12bc:	f9000bf3 	str	x19, [sp,#16]
	if (dev)
    12c0:	b4000321 	cbz	x1, 1324 <__dev_printk+0x74>

	/* dev->driver can change to NULL underneath us because of unbinding,
	 * so be careful about accessing it.  dev->bus and dev->class should
	 * never change once they are set, so they don't need special care.
	 */
	drv = ACCESS_ONCE(dev->driver);
    12c4:	f9404823 	ldr	x3, [x1,#144]

static void __dev_printk(const char *level, const struct device *dev,
			struct va_format *vaf)
{
	if (dev)
		dev_printk_emit(level[1] - '0', dev, "%s %s: %pV",
    12c8:	39400413 	ldrb	w19, [x0,#1]
    12cc:	5100c273 	sub	w19, w19, #0x30
	/* dev->driver can change to NULL underneath us because of unbinding,
	 * so be careful about accessing it.  dev->bus and dev->class should
	 * never change once they are set, so they don't need special care.
	 */
	drv = ACCESS_ONCE(dev->driver);
	return drv ? drv->name :
    12d0:	b40001a3 	cbz	x3, 1304 <__dev_printk+0x54>
    12d4:	f9400063 	ldr	x3, [x3]
    12d8:	f9402824 	ldr	x4, [x1,#80]
    12dc:	b4000104 	cbz	x4, 12fc <__dev_printk+0x4c>

static void __dev_printk(const char *level, const struct device *dev,
			struct va_format *vaf)
{
	if (dev)
		dev_printk_emit(level[1] - '0', dev, "%s %s: %pV",
    12e0:	90000002 	adrp	x2, 0 <dev_attr_store>
			12e0: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x1f0
    12e4:	2a1303e0 	mov	w0, w19
    12e8:	91000042 	add	x2, x2, #0x0
			12e8: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x1f0
    12ec:	94000000 	bl	1254 <dev_printk_emit>
			12ec: R_AARCH64_CALL26	dev_printk_emit
				dev_driver_string(dev), dev_name(dev), vaf);
	else
		printk("%s(NULL device *): %pV", level, vaf);
}
    12f0:	f9400bf3 	ldr	x19, [sp,#16]
    12f4:	a8c37bfd 	ldp	x29, x30, [sp],#48
    12f8:	d65f03c0 	ret
    12fc:	f9400824 	ldr	x4, [x1,#16]
    1300:	17fffff8 	b	12e0 <__dev_printk+0x30>
    1304:	aa0103e0 	mov	x0, x1
    1308:	f90017a1 	str	x1, [x29,#40]
    130c:	f90013a2 	str	x2, [x29,#32]
    1310:	97fffe22 	bl	b98 <dev_driver_string.part.12>
    1314:	aa0003e3 	mov	x3, x0
    1318:	f94013a5 	ldr	x5, [x29,#32]
    131c:	f94017a1 	ldr	x1, [x29,#40]
    1320:	17ffffee 	b	12d8 <__dev_printk+0x28>
{
	if (dev)
		dev_printk_emit(level[1] - '0', dev, "%s %s: %pV",
				dev_driver_string(dev), dev_name(dev), vaf);
	else
		printk("%s(NULL device *): %pV", level, vaf);
    1324:	aa0003e1 	mov	x1, x0
    1328:	90000000 	adrp	x0, 0 <dev_attr_store>
			1328: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x200
    132c:	91000000 	add	x0, x0, #0x0
			132c: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x200
    1330:	94000000 	bl	0 <printk>
			1330: R_AARCH64_CALL26	printk
    1334:	17ffffef 	b	12f0 <__dev_printk+0x40>

0000000000001338 <dev_printk>:
}

void dev_printk(const char *level, const struct device *dev,
		const char *fmt, ...)
{
    1338:	a9b97bfd 	stp	x29, x30, [sp,#-112]!
    133c:	910003fd 	mov	x29, sp
    1340:	f90027a3 	str	x3, [x29,#72]
	struct va_format vaf;
	va_list args;

	va_start(args, fmt);
    1344:	9101c3a3 	add	x3, x29, #0x70
    1348:	f90013a3 	str	x3, [x29,#32]
    134c:	f90017a3 	str	x3, [x29,#40]
    1350:	910103a3 	add	x3, x29, #0x40
    1354:	f9001ba3 	str	x3, [x29,#48]
    1358:	128004e3 	mov	w3, #0xffffffd8            	// #-40

	vaf.fmt = fmt;
    135c:	f9000ba2 	str	x2, [x29,#16]
	vaf.va = &args;

	__dev_printk(level, dev, &vaf);
    1360:	910043a2 	add	x2, x29, #0x10
		const char *fmt, ...)
{
	struct va_format vaf;
	va_list args;

	va_start(args, fmt);
    1364:	b9003ba3 	str	w3, [x29,#56]

	vaf.fmt = fmt;
	vaf.va = &args;
    1368:	910083a3 	add	x3, x29, #0x20
		printk("%s(NULL device *): %pV", level, vaf);
}

void dev_printk(const char *level, const struct device *dev,
		const char *fmt, ...)
{
    136c:	f9002ba4 	str	x4, [x29,#80]
    1370:	f9002fa5 	str	x5, [x29,#88]
    1374:	f90033a6 	str	x6, [x29,#96]
    1378:	f90037a7 	str	x7, [x29,#104]
	va_list args;

	va_start(args, fmt);

	vaf.fmt = fmt;
	vaf.va = &args;
    137c:	f9000fa3 	str	x3, [x29,#24]
		const char *fmt, ...)
{
	struct va_format vaf;
	va_list args;

	va_start(args, fmt);
    1380:	b9003fbf 	str	wzr, [x29,#60]

	vaf.fmt = fmt;
	vaf.va = &args;

	__dev_printk(level, dev, &vaf);
    1384:	97ffffcb 	bl	12b0 <__dev_printk>

	va_end(args);
}
    1388:	a8c77bfd 	ldp	x29, x30, [sp],#112
    138c:	d65f03c0 	ret

0000000000001390 <dev_emerg>:
								\
	va_end(args);						\
}								\
EXPORT_SYMBOL(func);

define_dev_printk_level(dev_emerg, KERN_EMERG);
    1390:	a9b97bfd 	stp	x29, x30, [sp,#-112]!
    1394:	910003fd 	mov	x29, sp
    1398:	f90027a3 	str	x3, [x29,#72]
    139c:	9101c3a3 	add	x3, x29, #0x70
    13a0:	f90013a3 	str	x3, [x29,#32]
    13a4:	f90017a3 	str	x3, [x29,#40]
    13a8:	910103a3 	add	x3, x29, #0x40
    13ac:	f9000ba1 	str	x1, [x29,#16]
    13b0:	aa0003e1 	mov	x1, x0
    13b4:	f9001ba3 	str	x3, [x29,#48]
    13b8:	90000000 	adrp	x0, 0 <dev_attr_store>
			13b8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x218
    13bc:	128005e3 	mov	w3, #0xffffffd0            	// #-48
    13c0:	f90023a2 	str	x2, [x29,#64]
    13c4:	b9003ba3 	str	w3, [x29,#56]
    13c8:	910043a2 	add	x2, x29, #0x10
    13cc:	910083a3 	add	x3, x29, #0x20
    13d0:	91000000 	add	x0, x0, #0x0
			13d0: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x218
    13d4:	f9002ba4 	str	x4, [x29,#80]
    13d8:	f9002fa5 	str	x5, [x29,#88]
    13dc:	f90033a6 	str	x6, [x29,#96]
    13e0:	f90037a7 	str	x7, [x29,#104]
    13e4:	f9000fa3 	str	x3, [x29,#24]
    13e8:	b9003fbf 	str	wzr, [x29,#60]
    13ec:	97ffffb1 	bl	12b0 <__dev_printk>
    13f0:	a8c77bfd 	ldp	x29, x30, [sp],#112
    13f4:	d65f03c0 	ret

00000000000013f8 <dev_alert>:
define_dev_printk_level(dev_alert, KERN_ALERT);
    13f8:	a9b97bfd 	stp	x29, x30, [sp,#-112]!
    13fc:	910003fd 	mov	x29, sp
    1400:	f90027a3 	str	x3, [x29,#72]
    1404:	9101c3a3 	add	x3, x29, #0x70
    1408:	f90013a3 	str	x3, [x29,#32]
    140c:	f90017a3 	str	x3, [x29,#40]
    1410:	910103a3 	add	x3, x29, #0x40
    1414:	f9000ba1 	str	x1, [x29,#16]
    1418:	aa0003e1 	mov	x1, x0
    141c:	f9001ba3 	str	x3, [x29,#48]
    1420:	90000000 	adrp	x0, 0 <dev_attr_store>
			1420: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x220
    1424:	128005e3 	mov	w3, #0xffffffd0            	// #-48
    1428:	f90023a2 	str	x2, [x29,#64]
    142c:	b9003ba3 	str	w3, [x29,#56]
    1430:	910043a2 	add	x2, x29, #0x10
    1434:	910083a3 	add	x3, x29, #0x20
    1438:	91000000 	add	x0, x0, #0x0
			1438: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x220
    143c:	f9002ba4 	str	x4, [x29,#80]
    1440:	f9002fa5 	str	x5, [x29,#88]
    1444:	f90033a6 	str	x6, [x29,#96]
    1448:	f90037a7 	str	x7, [x29,#104]
    144c:	f9000fa3 	str	x3, [x29,#24]
    1450:	b9003fbf 	str	wzr, [x29,#60]
    1454:	97ffff97 	bl	12b0 <__dev_printk>
    1458:	a8c77bfd 	ldp	x29, x30, [sp],#112
    145c:	d65f03c0 	ret

0000000000001460 <dev_crit>:
define_dev_printk_level(dev_crit, KERN_CRIT);
    1460:	a9b97bfd 	stp	x29, x30, [sp,#-112]!
    1464:	910003fd 	mov	x29, sp
    1468:	f90027a3 	str	x3, [x29,#72]
    146c:	9101c3a3 	add	x3, x29, #0x70
    1470:	f90013a3 	str	x3, [x29,#32]
    1474:	f90017a3 	str	x3, [x29,#40]
    1478:	910103a3 	add	x3, x29, #0x40
    147c:	f9000ba1 	str	x1, [x29,#16]
    1480:	aa0003e1 	mov	x1, x0
    1484:	f9001ba3 	str	x3, [x29,#48]
    1488:	90000000 	adrp	x0, 0 <dev_attr_store>
			1488: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x228
    148c:	128005e3 	mov	w3, #0xffffffd0            	// #-48
    1490:	f90023a2 	str	x2, [x29,#64]
    1494:	b9003ba3 	str	w3, [x29,#56]
    1498:	910043a2 	add	x2, x29, #0x10
    149c:	910083a3 	add	x3, x29, #0x20
    14a0:	91000000 	add	x0, x0, #0x0
			14a0: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x228
    14a4:	f9002ba4 	str	x4, [x29,#80]
    14a8:	f9002fa5 	str	x5, [x29,#88]
    14ac:	f90033a6 	str	x6, [x29,#96]
    14b0:	f90037a7 	str	x7, [x29,#104]
    14b4:	f9000fa3 	str	x3, [x29,#24]
    14b8:	b9003fbf 	str	wzr, [x29,#60]
    14bc:	97ffff7d 	bl	12b0 <__dev_printk>
    14c0:	a8c77bfd 	ldp	x29, x30, [sp],#112
    14c4:	d65f03c0 	ret

00000000000014c8 <dev_err>:
define_dev_printk_level(dev_err, KERN_ERR);
    14c8:	a9b97bfd 	stp	x29, x30, [sp,#-112]!
    14cc:	910003fd 	mov	x29, sp
    14d0:	f90027a3 	str	x3, [x29,#72]
    14d4:	9101c3a3 	add	x3, x29, #0x70
    14d8:	f90013a3 	str	x3, [x29,#32]
    14dc:	f90017a3 	str	x3, [x29,#40]
    14e0:	910103a3 	add	x3, x29, #0x40
    14e4:	f9000ba1 	str	x1, [x29,#16]
    14e8:	aa0003e1 	mov	x1, x0
    14ec:	f9001ba3 	str	x3, [x29,#48]
    14f0:	90000000 	adrp	x0, 0 <dev_attr_store>
			14f0: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x230
    14f4:	128005e3 	mov	w3, #0xffffffd0            	// #-48
    14f8:	f90023a2 	str	x2, [x29,#64]
    14fc:	b9003ba3 	str	w3, [x29,#56]
    1500:	910043a2 	add	x2, x29, #0x10
    1504:	910083a3 	add	x3, x29, #0x20
    1508:	91000000 	add	x0, x0, #0x0
			1508: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x230
    150c:	f9002ba4 	str	x4, [x29,#80]
    1510:	f9002fa5 	str	x5, [x29,#88]
    1514:	f90033a6 	str	x6, [x29,#96]
    1518:	f90037a7 	str	x7, [x29,#104]
    151c:	f9000fa3 	str	x3, [x29,#24]
    1520:	b9003fbf 	str	wzr, [x29,#60]
    1524:	97ffff63 	bl	12b0 <__dev_printk>
    1528:	a8c77bfd 	ldp	x29, x30, [sp],#112
    152c:	d65f03c0 	ret

0000000000001530 <uevent_store>:
	return count;
}

static ssize_t uevent_store(struct device *dev, struct device_attribute *attr,
			    const char *buf, size_t count)
{
    1530:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
    1534:	aa0203e4 	mov	x4, x2
	enum kobject_action action;

	if (kobject_action_type(buf, count, &action) == 0)
    1538:	aa0303e1 	mov	x1, x3
	return count;
}

static ssize_t uevent_store(struct device *dev, struct device_attribute *attr,
			    const char *buf, size_t count)
{
    153c:	910003fd 	mov	x29, sp
    1540:	a90153f3 	stp	x19, x20, [sp,#16]
	enum kobject_action action;

	if (kobject_action_type(buf, count, &action) == 0)
    1544:	9100b3a2 	add	x2, x29, #0x2c
	return count;
}

static ssize_t uevent_store(struct device *dev, struct device_attribute *attr,
			    const char *buf, size_t count)
{
    1548:	aa0003f4 	mov	x20, x0
	enum kobject_action action;

	if (kobject_action_type(buf, count, &action) == 0)
    154c:	aa0403e0 	mov	x0, x4
	return count;
}

static ssize_t uevent_store(struct device *dev, struct device_attribute *attr,
			    const char *buf, size_t count)
{
    1550:	aa0303f3 	mov	x19, x3
	enum kobject_action action;

	if (kobject_action_type(buf, count, &action) == 0)
    1554:	94000000 	bl	0 <kobject_action_type>
			1554: R_AARCH64_CALL26	kobject_action_type
    1558:	34000120 	cbz	w0, 157c <uevent_store+0x4c>
		kobject_uevent(&dev->kobj, action);
	else
		dev_err(dev, "uevent: unknown action-string\n");
    155c:	90000001 	adrp	x1, 0 <dev_attr_store>
			155c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x238
    1560:	aa1403e0 	mov	x0, x20
    1564:	91000021 	add	x1, x1, #0x0
			1564: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x238
    1568:	94000000 	bl	14c8 <dev_err>
			1568: R_AARCH64_CALL26	dev_err
	return count;
}
    156c:	aa1303e0 	mov	x0, x19
    1570:	a94153f3 	ldp	x19, x20, [sp,#16]
    1574:	a8c37bfd 	ldp	x29, x30, [sp],#48
    1578:	d65f03c0 	ret
			    const char *buf, size_t count)
{
	enum kobject_action action;

	if (kobject_action_type(buf, count, &action) == 0)
		kobject_uevent(&dev->kobj, action);
    157c:	b9402fa1 	ldr	w1, [x29,#44]
    1580:	91004280 	add	x0, x20, #0x10
    1584:	94000000 	bl	0 <kobject_uevent>
			1584: R_AARCH64_CALL26	kobject_uevent
	else
		dev_err(dev, "uevent: unknown action-string\n");
	return count;
}
    1588:	aa1303e0 	mov	x0, x19
    158c:	a94153f3 	ldp	x19, x20, [sp,#16]
    1590:	a8c37bfd 	ldp	x29, x30, [sp],#48
    1594:	d65f03c0 	ret

0000000000001598 <dev_warn>:

define_dev_printk_level(dev_emerg, KERN_EMERG);
define_dev_printk_level(dev_alert, KERN_ALERT);
define_dev_printk_level(dev_crit, KERN_CRIT);
define_dev_printk_level(dev_err, KERN_ERR);
define_dev_printk_level(dev_warn, KERN_WARNING);
    1598:	a9b97bfd 	stp	x29, x30, [sp,#-112]!
    159c:	910003fd 	mov	x29, sp
    15a0:	f90027a3 	str	x3, [x29,#72]
    15a4:	9101c3a3 	add	x3, x29, #0x70
    15a8:	f90013a3 	str	x3, [x29,#32]
    15ac:	f90017a3 	str	x3, [x29,#40]
    15b0:	910103a3 	add	x3, x29, #0x40
    15b4:	f9000ba1 	str	x1, [x29,#16]
    15b8:	aa0003e1 	mov	x1, x0
    15bc:	f9001ba3 	str	x3, [x29,#48]
    15c0:	90000000 	adrp	x0, 0 <dev_attr_store>
			15c0: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x258
    15c4:	128005e3 	mov	w3, #0xffffffd0            	// #-48
    15c8:	f90023a2 	str	x2, [x29,#64]
    15cc:	b9003ba3 	str	w3, [x29,#56]
    15d0:	910043a2 	add	x2, x29, #0x10
    15d4:	910083a3 	add	x3, x29, #0x20
    15d8:	91000000 	add	x0, x0, #0x0
			15d8: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x258
    15dc:	f9002ba4 	str	x4, [x29,#80]
    15e0:	f9002fa5 	str	x5, [x29,#88]
    15e4:	f90033a6 	str	x6, [x29,#96]
    15e8:	f90037a7 	str	x7, [x29,#104]
    15ec:	f9000fa3 	str	x3, [x29,#24]
    15f0:	b9003fbf 	str	wzr, [x29,#60]
    15f4:	97ffff2f 	bl	12b0 <__dev_printk>
    15f8:	a8c77bfd 	ldp	x29, x30, [sp],#112
    15fc:	d65f03c0 	ret

0000000000001600 <dev_notice>:
define_dev_printk_level(dev_notice, KERN_NOTICE);
    1600:	a9b97bfd 	stp	x29, x30, [sp,#-112]!
    1604:	910003fd 	mov	x29, sp
    1608:	f90027a3 	str	x3, [x29,#72]
    160c:	9101c3a3 	add	x3, x29, #0x70
    1610:	f90013a3 	str	x3, [x29,#32]
    1614:	f90017a3 	str	x3, [x29,#40]
    1618:	910103a3 	add	x3, x29, #0x40
    161c:	f9000ba1 	str	x1, [x29,#16]
    1620:	aa0003e1 	mov	x1, x0
    1624:	f9001ba3 	str	x3, [x29,#48]
    1628:	90000000 	adrp	x0, 0 <dev_attr_store>
			1628: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x260
    162c:	128005e3 	mov	w3, #0xffffffd0            	// #-48
    1630:	f90023a2 	str	x2, [x29,#64]
    1634:	b9003ba3 	str	w3, [x29,#56]
    1638:	910043a2 	add	x2, x29, #0x10
    163c:	910083a3 	add	x3, x29, #0x20
    1640:	91000000 	add	x0, x0, #0x0
			1640: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x260
    1644:	f9002ba4 	str	x4, [x29,#80]
    1648:	f9002fa5 	str	x5, [x29,#88]
    164c:	f90033a6 	str	x6, [x29,#96]
    1650:	f90037a7 	str	x7, [x29,#104]
    1654:	f9000fa3 	str	x3, [x29,#24]
    1658:	b9003fbf 	str	wzr, [x29,#60]
    165c:	97ffff15 	bl	12b0 <__dev_printk>
    1660:	a8c77bfd 	ldp	x29, x30, [sp],#112
    1664:	d65f03c0 	ret

0000000000001668 <_dev_info>:
define_dev_printk_level(_dev_info, KERN_INFO);
    1668:	a9b97bfd 	stp	x29, x30, [sp,#-112]!
    166c:	910003fd 	mov	x29, sp
    1670:	f90027a3 	str	x3, [x29,#72]
    1674:	9101c3a3 	add	x3, x29, #0x70
    1678:	f90013a3 	str	x3, [x29,#32]
    167c:	f90017a3 	str	x3, [x29,#40]
    1680:	910103a3 	add	x3, x29, #0x40
    1684:	f9000ba1 	str	x1, [x29,#16]
    1688:	aa0003e1 	mov	x1, x0
    168c:	f9001ba3 	str	x3, [x29,#48]
    1690:	90000000 	adrp	x0, 0 <dev_attr_store>
			1690: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x268
    1694:	128005e3 	mov	w3, #0xffffffd0            	// #-48
    1698:	f90023a2 	str	x2, [x29,#64]
    169c:	b9003ba3 	str	w3, [x29,#56]
    16a0:	910043a2 	add	x2, x29, #0x10
    16a4:	910083a3 	add	x3, x29, #0x20
    16a8:	91000000 	add	x0, x0, #0x0
			16a8: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x268
    16ac:	f9002ba4 	str	x4, [x29,#80]
    16b0:	f9002fa5 	str	x5, [x29,#88]
    16b4:	f90033a6 	str	x6, [x29,#96]
    16b8:	f90037a7 	str	x7, [x29,#104]
    16bc:	f9000fa3 	str	x3, [x29,#24]
    16c0:	b9003fbf 	str	wzr, [x29,#60]
    16c4:	97fffefb 	bl	12b0 <__dev_printk>
    16c8:	a8c77bfd 	ldp	x29, x30, [sp],#112
    16cc:	d65f03c0 	ret

00000000000016d0 <lock_device_hotplug>:
struct kobject *sysfs_dev_block_kobj;

static DEFINE_MUTEX(device_hotplug_lock);

void lock_device_hotplug(void)
{
    16d0:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
	mutex_lock(&device_hotplug_lock);
    16d4:	90000000 	adrp	x0, 0 <dev_attr_store>
			16d4: R_AARCH64_ADR_PREL_PG_HI21	.data
    16d8:	91000000 	add	x0, x0, #0x0
			16d8: R_AARCH64_ADD_ABS_LO12_NC	.data
struct kobject *sysfs_dev_block_kobj;

static DEFINE_MUTEX(device_hotplug_lock);

void lock_device_hotplug(void)
{
    16dc:	910003fd 	mov	x29, sp
	mutex_lock(&device_hotplug_lock);
    16e0:	9102c000 	add	x0, x0, #0xb0
    16e4:	94000000 	bl	0 <mutex_lock>
			16e4: R_AARCH64_CALL26	mutex_lock
}
    16e8:	a8c17bfd 	ldp	x29, x30, [sp],#16
    16ec:	d65f03c0 	ret

00000000000016f0 <unlock_device_hotplug>:

void unlock_device_hotplug(void)
{
    16f0:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
	mutex_unlock(&device_hotplug_lock);
    16f4:	90000000 	adrp	x0, 0 <dev_attr_store>
			16f4: R_AARCH64_ADR_PREL_PG_HI21	.data
    16f8:	91000000 	add	x0, x0, #0x0
			16f8: R_AARCH64_ADD_ABS_LO12_NC	.data
{
	mutex_lock(&device_hotplug_lock);
}

void unlock_device_hotplug(void)
{
    16fc:	910003fd 	mov	x29, sp
	mutex_unlock(&device_hotplug_lock);
    1700:	9102c000 	add	x0, x0, #0xb0
    1704:	94000000 	bl	0 <mutex_unlock>
			1704: R_AARCH64_CALL26	mutex_unlock
}
    1708:	a8c17bfd 	ldp	x29, x30, [sp],#16
    170c:	d65f03c0 	ret

0000000000001710 <lock_device_hotplug_sysfs>:

int lock_device_hotplug_sysfs(void)
{
    1710:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
	if (mutex_trylock(&device_hotplug_lock))
    1714:	90000000 	adrp	x0, 0 <dev_attr_store>
			1714: R_AARCH64_ADR_PREL_PG_HI21	.data
    1718:	91000000 	add	x0, x0, #0x0
			1718: R_AARCH64_ADD_ABS_LO12_NC	.data
{
	mutex_unlock(&device_hotplug_lock);
}

int lock_device_hotplug_sysfs(void)
{
    171c:	910003fd 	mov	x29, sp
	if (mutex_trylock(&device_hotplug_lock))
    1720:	9102c000 	add	x0, x0, #0xb0
    1724:	94000000 	bl	0 <mutex_trylock>
			1724: R_AARCH64_CALL26	mutex_trylock
		return 0;
    1728:	52800001 	mov	w1, #0x0                   	// #0
	mutex_unlock(&device_hotplug_lock);
}

int lock_device_hotplug_sysfs(void)
{
	if (mutex_trylock(&device_hotplug_lock))
    172c:	34000080 	cbz	w0, 173c <lock_device_hotplug_sysfs+0x2c>
		return 0;

	/* Avoid busy looping (5 ms of sleep should do). */
	msleep(5);
	return restart_syscall();
}
    1730:	2a0103e0 	mov	w0, w1
    1734:	a8c17bfd 	ldp	x29, x30, [sp],#16
    1738:	d65f03c0 	ret
{
	if (mutex_trylock(&device_hotplug_lock))
		return 0;

	/* Avoid busy looping (5 ms of sleep should do). */
	msleep(5);
    173c:	528000a0 	mov	w0, #0x5                   	// #5
    1740:	94000000 	bl	0 <msleep>
			1740: R_AARCH64_CALL26	msleep
 */
static inline struct thread_info *current_thread_info(void)
{
	unsigned long sp_el0;

	asm ("mrs %0, sp_el0" : "=r" (sp_el0));
    1744:	d5384100 	mrs	x0, sp_el0
/* set thread flags in other task's structures
 * - see asm/thread_info.h for TIF_xxxx flags available
 */
static inline void set_tsk_thread_flag(struct task_struct *tsk, int flag)
{
	set_ti_thread_flag(task_thread_info(tsk), flag);
    1748:	f9400801 	ldr	x1, [x0,#16]
 * - pass TIF_xxxx constants to these functions
 */

static inline void set_ti_thread_flag(struct thread_info *ti, int flag)
{
	set_bit(flag, (unsigned long *)&ti->flags);
    174c:	52800000 	mov	w0, #0x0                   	// #0
    1750:	f9400421 	ldr	x1, [x1,#8]
    1754:	94000000 	bl	0 <set_bit>
			1754: R_AARCH64_CALL26	set_bit
    1758:	12804001 	mov	w1, #0xfffffdff            	// #-513
    175c:	17fffff5 	b	1730 <lock_device_hotplug_sysfs+0x20>

0000000000001760 <device_add_groups>:
	return ret < 0 ? ret : count;
}
static DEVICE_ATTR_RW(online);

int device_add_groups(struct device *dev, const struct attribute_group **groups)
{
    1760:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
	return sysfs_create_groups(&dev->kobj, groups);
    1764:	91004000 	add	x0, x0, #0x10
	return ret < 0 ? ret : count;
}
static DEVICE_ATTR_RW(online);

int device_add_groups(struct device *dev, const struct attribute_group **groups)
{
    1768:	910003fd 	mov	x29, sp
	return sysfs_create_groups(&dev->kobj, groups);
    176c:	94000000 	bl	0 <sysfs_create_groups>
			176c: R_AARCH64_CALL26	sysfs_create_groups
}
    1770:	a8c17bfd 	ldp	x29, x30, [sp],#16
    1774:	d65f03c0 	ret

0000000000001778 <device_remove_groups>:

void device_remove_groups(struct device *dev,
			  const struct attribute_group **groups)
{
    1778:	a9bf7bfd 	stp	x29, x30, [sp,#-16]!
	sysfs_remove_groups(&dev->kobj, groups);
    177c:	91004000 	add	x0, x0, #0x10
	return sysfs_create_groups(&dev->kobj, groups);
}

void device_remove_groups(struct device *dev,
			  const struct attribute_group **groups)
{
    1780:	910003fd 	mov	x29, sp
	sysfs_remove_groups(&dev->kobj, groups);
    1784:	94000000 	bl	0 <sysfs_remove_groups>
			1784: R_AARCH64_CALL26	sysfs_remove_groups
}
    1788:	a8c17bfd 	ldp	x29, x30, [sp],#16
    178c:	d65f03c0 	ret

0000000000001790 <devices_kset_move_last>:
/**
 * devices_kset_move_last - move the device to the end of devices_kset's list.
 * @dev: device to move
 */
void devices_kset_move_last(struct device *dev)
{
    1790:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
    1794:	910003fd 	mov	x29, sp
    1798:	a90153f3 	stp	x19, x20, [sp,#16]
	if (!devices_kset)
    179c:	90000014 	adrp	x20, 0 <dev_attr_store>
			179c: R_AARCH64_ADR_PREL_PG_HI21	.bss
    17a0:	f9400281 	ldr	x1, [x20]
			17a0: R_AARCH64_LDST64_ABS_LO12_NC	.bss
    17a4:	b40002c1 	cbz	x1, 17fc <devices_kset_move_last+0x6c>
    17a8:	aa0003f3 	mov	x19, x0
		return;
	pr_debug("devices_kset: Moving %s to end of list\n", dev_name(dev));
    17ac:	90000000 	adrp	x0, 0 <dev_attr_store>
			17ac: R_AARCH64_ADR_PREL_PG_HI21	__verbose
    17b0:	91000002 	add	x2, x0, #0x0
			17b0: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    17b4:	79413442 	ldrh	w2, [x2,#154]
    17b8:	37100282 	tbnz	w2, #2, 1808 <devices_kset_move_last+0x78>
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    17bc:	91004020 	add	x0, x1, #0x10
    17c0:	94000000 	bl	0 <_raw_spin_lock>
			17c0: R_AARCH64_CALL26	_raw_spin_lock
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    17c4:	f9400e63 	ldr	x3, [x19,#24]
	spin_lock(&devices_kset->list_lock);
	list_move_tail(&dev->kobj.entry, &devices_kset->list);
    17c8:	91006260 	add	x0, x19, #0x18
    17cc:	f9401262 	ldr	x2, [x19,#32]
    17d0:	f9400281 	ldr	x1, [x20]
			17d0: R_AARCH64_LDST64_ABS_LO12_NC	.bss
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    17d4:	f9000462 	str	x2, [x3,#8]
    17d8:	f9000043 	str	x3, [x2]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    17dc:	f9400422 	ldr	x2, [x1,#8]
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    17e0:	f9000420 	str	x0, [x1,#8]
	new->next = next;
    17e4:	f9000e61 	str	x1, [x19,#24]
	new->prev = prev;
    17e8:	f9001262 	str	x2, [x19,#32]
    17ec:	f9000040 	str	x0, [x2]
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static __always_inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    17f0:	f9400280 	ldr	x0, [x20]
			17f0: R_AARCH64_LDST64_ABS_LO12_NC	.bss
    17f4:	91004000 	add	x0, x0, #0x10
    17f8:	94000000 	bl	0 <_raw_spin_unlock>
			17f8: R_AARCH64_CALL26	_raw_spin_unlock
	spin_unlock(&devices_kset->list_lock);
}
    17fc:	a94153f3 	ldp	x19, x20, [sp,#16]
    1800:	a8c27bfd 	ldp	x29, x30, [sp],#32
    1804:	d65f03c0 	ret
    1808:	f9402a62 	ldr	x2, [x19,#80]
    180c:	b4000102 	cbz	x2, 182c <devices_kset_move_last+0x9c>
 */
void devices_kset_move_last(struct device *dev)
{
	if (!devices_kset)
		return;
	pr_debug("devices_kset: Moving %s to end of list\n", dev_name(dev));
    1810:	91000000 	add	x0, x0, #0x0
			1810: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    1814:	90000001 	adrp	x1, 0 <dev_attr_store>
			1814: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x270
    1818:	91000021 	add	x1, x1, #0x0
			1818: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x270
    181c:	9101e000 	add	x0, x0, #0x78
    1820:	94000000 	bl	0 <__dynamic_pr_debug>
			1820: R_AARCH64_CALL26	__dynamic_pr_debug
    1824:	f9400281 	ldr	x1, [x20]
			1824: R_AARCH64_LDST64_ABS_LO12_NC	.bss
    1828:	17ffffe5 	b	17bc <devices_kset_move_last+0x2c>
    182c:	f9400a62 	ldr	x2, [x19,#16]
    1830:	17fffff8 	b	1810 <devices_kset_move_last+0x80>

0000000000001834 <virtual_device_parent>:
#endif
}
EXPORT_SYMBOL_GPL(device_initialize);

struct kobject *virtual_device_parent(struct device *dev)
{
    1834:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
	static struct kobject *virtual_dir = NULL;

	if (!virtual_dir)
    1838:	90000001 	adrp	x1, 0 <dev_attr_store>
			1838: R_AARCH64_ADR_PREL_PG_HI21	.bss
#endif
}
EXPORT_SYMBOL_GPL(device_initialize);

struct kobject *virtual_device_parent(struct device *dev)
{
    183c:	910003fd 	mov	x29, sp
    1840:	f9000bf3 	str	x19, [sp,#16]
	static struct kobject *virtual_dir = NULL;

	if (!virtual_dir)
    1844:	91000033 	add	x19, x1, #0x0
			1844: R_AARCH64_ADD_ABS_LO12_NC	.bss
    1848:	f9400e60 	ldr	x0, [x19,#24]
    184c:	b4000080 	cbz	x0, 185c <virtual_device_parent+0x28>
		virtual_dir = kobject_create_and_add("virtual",
						     &devices_kset->kobj);

	return virtual_dir;
}
    1850:	f9400bf3 	ldr	x19, [sp,#16]
    1854:	a8c27bfd 	ldp	x29, x30, [sp],#32
    1858:	d65f03c0 	ret
struct kobject *virtual_device_parent(struct device *dev)
{
	static struct kobject *virtual_dir = NULL;

	if (!virtual_dir)
		virtual_dir = kobject_create_and_add("virtual",
    185c:	f9400021 	ldr	x1, [x1]
			185c: R_AARCH64_LDST64_ABS_LO12_NC	.bss
    1860:	90000000 	adrp	x0, 0 <dev_attr_store>
			1860: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x298
    1864:	91000000 	add	x0, x0, #0x0
			1864: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x298
    1868:	91006021 	add	x1, x1, #0x18
    186c:	94000000 	bl	0 <kobject_create_and_add>
			186c: R_AARCH64_CALL26	kobject_create_and_add
    1870:	f9000e60 	str	x0, [x19,#24]
						     &devices_kset->kobj);

	return virtual_dir;
}
    1874:	f9400bf3 	ldr	x19, [sp,#16]
    1878:	a8c27bfd 	ldp	x29, x30, [sp],#32
    187c:	d65f03c0 	ret

0000000000001880 <get_device_parent>:

static DEFINE_MUTEX(gdp_mutex);

static struct kobject *get_device_parent(struct device *dev,
					 struct device *parent)
{
    1880:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
    1884:	910003fd 	mov	x29, sp
    1888:	a9025bf5 	stp	x21, x22, [sp,#32]
    188c:	a90153f3 	stp	x19, x20, [sp,#16]
    1890:	aa0003f5 	mov	x21, x0
	if (dev->class) {
    1894:	f9414c02 	ldr	x2, [x0,#664]
    1898:	b40005c2 	cbz	x2, 1950 <get_device_parent+0xd0>
    189c:	aa0103f3 	mov	x19, x1
		/*
		 * If we have no parent, we live in "virtual".
		 * Class-devices with a non class-device as parent, live
		 * in a "glue" directory to prevent namespace collisions.
		 */
		if (parent == NULL)
    18a0:	b40009e1 	cbz	x1, 19dc <get_device_parent+0x15c>
			parent_kobj = virtual_device_parent(dev);
		else if (parent->class && !dev->class->ns_type)
    18a4:	f9414c20 	ldr	x0, [x1,#664]
    18a8:	b4000060 	cbz	x0, 18b4 <get_device_parent+0x34>
    18ac:	f9402c40 	ldr	x0, [x2,#88]
    18b0:	b4000520 	cbz	x0, 1954 <get_device_parent+0xd4>
			return &parent->kobj;
		else
			parent_kobj = &parent->kobj;
    18b4:	91004273 	add	x19, x19, #0x10

		mutex_lock(&gdp_mutex);
    18b8:	90000016 	adrp	x22, 0 <dev_attr_store>
			18b8: R_AARCH64_ADR_PREL_PG_HI21	.data
    18bc:	910002c0 	add	x0, x22, #0x0
			18bc: R_AARCH64_ADD_ABS_LO12_NC	.data
    18c0:	91012000 	add	x0, x0, #0x48
    18c4:	94000000 	bl	0 <mutex_lock>
			18c4: R_AARCH64_CALL26	mutex_lock

		/* find our class-directory at the parent and reference it */
		spin_lock(&dev->class->p->glue_dirs.list_lock);
    18c8:	f9414ea0 	ldr	x0, [x21,#664]
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    18cc:	f9403800 	ldr	x0, [x0,#112]
    18d0:	91052000 	add	x0, x0, #0x148
    18d4:	94000000 	bl	0 <_raw_spin_lock>
			18d4: R_AARCH64_CALL26	_raw_spin_lock
		list_for_each_entry(k, &dev->class->p->glue_dirs.list, entry)
    18d8:	f9414ea0 	ldr	x0, [x21,#664]
    18dc:	f9403803 	ldr	x3, [x0,#112]
    18e0:	9104e061 	add	x1, x3, #0x138
    18e4:	f9409c62 	ldr	x2, [x3,#312]
    18e8:	eb02003f 	cmp	x1, x2
    18ec:	d1002040 	sub	x0, x2, #0x8
    18f0:	540000c1 	b.ne	1908 <get_device_parent+0x88>
    18f4:	1400001e 	b	196c <get_device_parent+0xec>
    18f8:	f9400400 	ldr	x0, [x0,#8]
    18fc:	eb00003f 	cmp	x1, x0
    1900:	d1002000 	sub	x0, x0, #0x8
    1904:	54000340 	b.eq	196c <get_device_parent+0xec>
			if (k->parent == parent_kobj) {
    1908:	f9400c02 	ldr	x2, [x0,#24]
    190c:	eb13005f 	cmp	x2, x19
    1910:	54ffff41 	b.ne	18f8 <get_device_parent+0x78>
				kobj = kobject_get(k);
    1914:	94000000 	bl	0 <kobject_get>
			1914: R_AARCH64_CALL26	kobject_get
    1918:	aa0003f4 	mov	x20, x0
				break;
			}
		spin_unlock(&dev->class->p->glue_dirs.list_lock);
    191c:	f9414ea0 	ldr	x0, [x21,#664]
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static __always_inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    1920:	f9403800 	ldr	x0, [x0,#112]
    1924:	91052000 	add	x0, x0, #0x148
    1928:	94000000 	bl	0 <_raw_spin_unlock>
			1928: R_AARCH64_CALL26	_raw_spin_unlock
		if (kobj) {
    192c:	b4000254 	cbz	x20, 1974 <get_device_parent+0xf4>
		}

		/* or create a new class-directory at the parent device */
		k = class_dir_create_and_add(dev->class, parent_kobj);
		/* do not emit an uevent for this simple "glue" directory */
		mutex_unlock(&gdp_mutex);
    1930:	910002c0 	add	x0, x22, #0x0
			1930: R_AARCH64_ADD_ABS_LO12_NC	.data
    1934:	91012000 	add	x0, x0, #0x48
    1938:	94000000 	bl	0 <mutex_unlock>
			1938: R_AARCH64_CALL26	mutex_unlock
		return &dev->bus->dev_root->kobj;

	if (parent)
		return &parent->kobj;
	return NULL;
}
    193c:	aa1403e0 	mov	x0, x20
    1940:	a94153f3 	ldp	x19, x20, [sp,#16]
    1944:	a9425bf5 	ldp	x21, x22, [sp,#32]
    1948:	a8c37bfd 	ldp	x29, x30, [sp],#48
    194c:	d65f03c0 	ret
		mutex_unlock(&gdp_mutex);
		return k;
	}

	/* subsystems can specify a default root directory for their devices */
	if (!parent && dev->bus && dev->bus->dev_root)
    1950:	b40004c1 	cbz	x1, 19e8 <get_device_parent+0x168>
		 * in a "glue" directory to prevent namespace collisions.
		 */
		if (parent == NULL)
			parent_kobj = virtual_device_parent(dev);
		else if (parent->class && !dev->class->ns_type)
			return &parent->kobj;
    1954:	91004034 	add	x20, x1, #0x10
		return &dev->bus->dev_root->kobj;

	if (parent)
		return &parent->kobj;
	return NULL;
}
    1958:	aa1403e0 	mov	x0, x20
    195c:	a94153f3 	ldp	x19, x20, [sp,#16]
    1960:	a9425bf5 	ldp	x21, x22, [sp,#32]
    1964:	a8c37bfd 	ldp	x29, x30, [sp],#48
    1968:	d65f03c0 	ret
    196c:	91052060 	add	x0, x3, #0x148
    1970:	94000000 	bl	0 <_raw_spin_unlock>
			1970: R_AARCH64_CALL26	_raw_spin_unlock
    1974:	90000000 	adrp	x0, 0 <kmalloc_caches>
			1974: R_AARCH64_ADR_PREL_PG_HI21	kmalloc_caches+0x38
    1978:	52901801 	mov	w1, #0x80c0                	// #32960
    197c:	72a04801 	movk	w1, #0x240, lsl #16
			mutex_unlock(&gdp_mutex);
			return kobj;
		}

		/* or create a new class-directory at the parent device */
		k = class_dir_create_and_add(dev->class, parent_kobj);
    1980:	f9414eb5 	ldr	x21, [x21,#664]
    1984:	f9400000 	ldr	x0, [x0]
			1984: R_AARCH64_LDST64_ABS_LO12_NC	kmalloc_caches+0x38
    1988:	94000000 	bl	0 <kmem_cache_alloc>
			1988: R_AARCH64_CALL26	kmem_cache_alloc
    198c:	aa0003f4 	mov	x20, x0
{
	struct class_dir *dir;
	int retval;

	dir = kzalloc(sizeof(*dir), GFP_KERNEL);
	if (!dir)
    1990:	b40003a0 	cbz	x0, 1a04 <get_device_parent+0x184>
		return NULL;

	dir->class = class;
	kobject_init(&dir->kobj, &class_dir_ktype);
    1994:	910002c1 	add	x1, x22, #0x0
			1994: R_AARCH64_ADD_ABS_LO12_NC	.data

	dir = kzalloc(sizeof(*dir), GFP_KERNEL);
	if (!dir)
		return NULL;

	dir->class = class;
    1998:	f9002015 	str	x21, [x0,#64]
	kobject_init(&dir->kobj, &class_dir_ktype);
    199c:	91036021 	add	x1, x1, #0xd8
    19a0:	94000000 	bl	0 <kobject_init>
			19a0: R_AARCH64_CALL26	kobject_init

	dir->kobj.kset = &class->p->glue_dirs;
    19a4:	f9403aa0 	ldr	x0, [x21,#112]

	retval = kobject_add(&dir->kobj, parent_kobj, "%s", class->name);
    19a8:	90000002 	adrp	x2, 0 <dev_attr_store>
			19a8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x2a0
    19ac:	aa1303e1 	mov	x1, x19
    19b0:	91000042 	add	x2, x2, #0x0
			19b0: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x2a0
		return NULL;

	dir->class = class;
	kobject_init(&dir->kobj, &class_dir_ktype);

	dir->kobj.kset = &class->p->glue_dirs;
    19b4:	9104e000 	add	x0, x0, #0x138
    19b8:	f9001280 	str	x0, [x20,#32]

	retval = kobject_add(&dir->kobj, parent_kobj, "%s", class->name);
    19bc:	aa1403e0 	mov	x0, x20
    19c0:	f94002a3 	ldr	x3, [x21]
    19c4:	94000000 	bl	0 <kobject_add>
			19c4: R_AARCH64_CALL26	kobject_add
	if (retval < 0) {
    19c8:	36fffb40 	tbz	w0, #31, 1930 <get_device_parent+0xb0>
		kobject_put(&dir->kobj);
    19cc:	aa1403e0 	mov	x0, x20
		return NULL;
    19d0:	d2800014 	mov	x20, #0x0                   	// #0

	dir->kobj.kset = &class->p->glue_dirs;

	retval = kobject_add(&dir->kobj, parent_kobj, "%s", class->name);
	if (retval < 0) {
		kobject_put(&dir->kobj);
    19d4:	94000000 	bl	0 <kobject_put>
			19d4: R_AARCH64_CALL26	kobject_put
    19d8:	17ffffd6 	b	1930 <get_device_parent+0xb0>
		 * If we have no parent, we live in "virtual".
		 * Class-devices with a non class-device as parent, live
		 * in a "glue" directory to prevent namespace collisions.
		 */
		if (parent == NULL)
			parent_kobj = virtual_device_parent(dev);
    19dc:	94000000 	bl	1834 <virtual_device_parent>
			19dc: R_AARCH64_CALL26	virtual_device_parent
    19e0:	aa0003f3 	mov	x19, x0
    19e4:	17ffffb5 	b	18b8 <get_device_parent+0x38>
		mutex_unlock(&gdp_mutex);
		return k;
	}

	/* subsystems can specify a default root directory for their devices */
	if (!parent && dev->bus && dev->bus->dev_root)
    19e8:	f9404400 	ldr	x0, [x0,#136]
    19ec:	b4000100 	cbz	x0, 1a0c <get_device_parent+0x18c>
    19f0:	f9400800 	ldr	x0, [x0,#16]
		return &dev->bus->dev_root->kobj;
    19f4:	91004014 	add	x20, x0, #0x10
    19f8:	eb1f001f 	cmp	x0, xzr
    19fc:	9a9f1294 	csel	x20, x20, xzr, ne
    1a00:	17ffffcf 	b	193c <get_device_parent+0xbc>
	struct class_dir *dir;
	int retval;

	dir = kzalloc(sizeof(*dir), GFP_KERNEL);
	if (!dir)
		return NULL;
    1a04:	d2800014 	mov	x20, #0x0                   	// #0
    1a08:	17ffffca 	b	1930 <get_device_parent+0xb0>
	if (!parent && dev->bus && dev->bus->dev_root)
		return &dev->bus->dev_root->kobj;

	if (parent)
		return &parent->kobj;
	return NULL;
    1a0c:	d2800014 	mov	x20, #0x0                   	// #0
    1a10:	17ffffcb 	b	193c <get_device_parent+0xbc>

0000000000001a14 <device_move>:
 * @new_parent: the new parent of the device (can by NULL)
 * @dpm_order: how to reorder the dpm_list
 */
int device_move(struct device *dev, struct device *new_parent,
		enum dpm_order dpm_order)
{
    1a14:	a9b97bfd 	stp	x29, x30, [sp,#-112]!
    1a18:	910003fd 	mov	x29, sp
    1a1c:	a90153f3 	stp	x19, x20, [sp,#16]
    1a20:	a9025bf5 	stp	x21, x22, [sp,#32]
    1a24:	a90363f7 	stp	x23, x24, [sp,#48]
    1a28:	a9046bf9 	stp	x25, x26, [sp,#64]
    1a2c:	a90573fb 	stp	x27, x28, [sp,#80]
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
    1a30:	b4000920 	cbz	x0, 1b54 <device_move+0x140>
    1a34:	91004000 	add	x0, x0, #0x10
    1a38:	2a0203f6 	mov	w22, w2
    1a3c:	aa0103f4 	mov	x20, x1
    1a40:	94000000 	bl	0 <kobject_get>
			1a40: R_AARCH64_CALL26	kobject_get
	int error;
	struct device *old_parent;
	struct kobject *new_parent_kobj;

	dev = get_device(dev);
	if (!dev)
    1a44:	f1004017 	subs	x23, x0, #0x10
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
    1a48:	aa0003f3 	mov	x19, x0
	int error;
	struct device *old_parent;
	struct kobject *new_parent_kobj;

	dev = get_device(dev);
	if (!dev)
    1a4c:	54000840 	b.eq	1b54 <device_move+0x140>
		return -EINVAL;

	device_pm_lock();
    1a50:	94000000 	bl	0 <device_pm_lock>
			1a50: R_AARCH64_CALL26	device_pm_lock
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
    1a54:	b4000914 	cbz	x20, 1b74 <device_move+0x160>
    1a58:	91004280 	add	x0, x20, #0x10
    1a5c:	94000000 	bl	0 <kobject_get>
			1a5c: R_AARCH64_CALL26	kobject_get
	bool			offline:1;
};

static inline struct device *kobj_to_dev(struct kobject *kobj)
{
	return container_of(kobj, struct device, kobj);
    1a60:	d1004014 	sub	x20, x0, #0x10
	if (!dev)
		return -EINVAL;

	device_pm_lock();
	new_parent = get_device(new_parent);
	new_parent_kobj = get_device_parent(dev, new_parent);
    1a64:	aa1403e1 	mov	x1, x20
    1a68:	aa1703e0 	mov	x0, x23

	pr_debug("device: '%s': %s: moving to '%s'\n", dev_name(dev),
    1a6c:	9000001a 	adrp	x26, 0 <dev_attr_store>
			1a6c: R_AARCH64_ADR_PREL_PG_HI21	__verbose
	if (!dev)
		return -EINVAL;

	device_pm_lock();
	new_parent = get_device(new_parent);
	new_parent_kobj = get_device_parent(dev, new_parent);
    1a70:	97ffff84 	bl	1880 <get_device_parent>
    1a74:	aa0003f9 	mov	x25, x0

	pr_debug("device: '%s': %s: moving to '%s'\n", dev_name(dev),
    1a78:	91000340 	add	x0, x26, #0x0
			1a78: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    1a7c:	79418400 	ldrh	w0, [x0,#194]
    1a80:	37101460 	tbnz	w0, #2, 1d0c <device_move+0x2f8>
		 __func__, new_parent ? dev_name(new_parent) : "<NULL>");
	error = kobject_move(&dev->kobj, new_parent_kobj);
    1a84:	aa1903e1 	mov	x1, x25
    1a88:	aa1303e0 	mov	x0, x19
    1a8c:	94000000 	bl	0 <kobject_move>
			1a8c: R_AARCH64_CALL26	kobject_move
    1a90:	2a0003f5 	mov	w21, w0
	if (error) {
    1a94:	35000740 	cbnz	w0, 1b7c <device_move+0x168>
		cleanup_glue_dir(dev, new_parent_kobj);
		put_device(new_parent);
		goto out;
	}
	old_parent = dev->parent;
    1a98:	f85f0278 	ldr	x24, [x19,#-16]
	dev->parent = new_parent;
    1a9c:	f81f0274 	str	x20, [x19,#-16]
	if (old_parent)
    1aa0:	b4000098 	cbz	x24, 1ab0 <device_move+0x9c>
		klist_remove(&dev->p->knode_parent);
    1aa4:	f85f8260 	ldr	x0, [x19,#-8]
    1aa8:	9100a000 	add	x0, x0, #0x28
    1aac:	94000000 	bl	0 <klist_remove>
			1aac: R_AARCH64_CALL26	klist_remove
	if (new_parent) {
    1ab0:	b40000b4 	cbz	x20, 1ac4 <device_move+0xb0>
		klist_add_tail(&dev->p->knode_parent,
    1ab4:	f85f8260 	ldr	x0, [x19,#-8]
    1ab8:	f9400681 	ldr	x1, [x20,#8]
    1abc:	9100a000 	add	x0, x0, #0x28
    1ac0:	94000000 	bl	0 <klist_add_tail>
			1ac0: R_AARCH64_CALL26	klist_add_tail
			       &new_parent->p->klist_children);
		set_dev_node(dev, dev_to_node(new_parent));
	}

	if (dev->class) {
    1ac4:	f9414ee0 	ldr	x0, [x23,#664]
    1ac8:	b40001e0 	cbz	x0, 1b04 <device_move+0xf0>
				   struct device *old_parent,
				   struct device *new_parent)
{
	int error = 0;

	if (old_parent)
    1acc:	b40000b8 	cbz	x24, 1ae0 <device_move+0xcc>
		sysfs_remove_link(&dev->kobj, "device");
    1ad0:	90000001 	adrp	x1, 0 <dev_attr_store>
			1ad0: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x110
    1ad4:	aa1303e0 	mov	x0, x19
    1ad8:	91000021 	add	x1, x1, #0x0
			1ad8: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x110
    1adc:	94000000 	bl	0 <sysfs_remove_link>
			1adc: R_AARCH64_CALL26	sysfs_remove_link
	if (new_parent)
    1ae0:	b4000134 	cbz	x20, 1b04 <device_move+0xf0>
		error = sysfs_create_link(&dev->kobj, &new_parent->kobj,
    1ae4:	9000001b 	adrp	x27, 0 <dev_attr_store>
			1ae4: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x110
    1ae8:	9100429c 	add	x28, x20, #0x10
    1aec:	9100037b 	add	x27, x27, #0x0
			1aec: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x110
    1af0:	aa1c03e1 	mov	x1, x28
    1af4:	aa1b03e2 	mov	x2, x27
    1af8:	aa1303e0 	mov	x0, x19
    1afc:	94000000 	bl	0 <sysfs_create_link>
			1afc: R_AARCH64_CALL26	sysfs_create_link
		set_dev_node(dev, dev_to_node(new_parent));
	}

	if (dev->class) {
		error = device_move_class_links(dev, old_parent, new_parent);
		if (error) {
    1b00:	350004c0 	cbnz	w0, 1b98 <device_move+0x184>
			cleanup_glue_dir(dev, new_parent_kobj);
			put_device(new_parent);
			goto out;
		}
	}
	switch (dpm_order) {
    1b04:	71000adf 	cmp	w22, #0x2
    1b08:	54000900 	b.eq	1c28 <device_move+0x214>
    1b0c:	71000edf 	cmp	w22, #0x3
    1b10:	54000f40 	b.eq	1cf8 <device_move+0x2e4>
    1b14:	710006df 	cmp	w22, #0x1
    1b18:	54000bc0 	b.eq	1c90 <device_move+0x27c>
 * @dev: device in question.
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
    1b1c:	b4000078 	cbz	x24, 1b28 <device_move+0x114>
		kobject_put(&dev->kobj);
    1b20:	91004300 	add	x0, x24, #0x10
    1b24:	94000000 	bl	0 <kobject_put>
			1b24: R_AARCH64_CALL26	kobject_put
		break;
	}

	put_device(old_parent);
out:
	device_pm_unlock();
    1b28:	94000000 	bl	0 <device_pm_unlock>
			1b28: R_AARCH64_CALL26	device_pm_unlock
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
		kobject_put(&dev->kobj);
    1b2c:	aa1303e0 	mov	x0, x19
    1b30:	94000000 	bl	0 <kobject_put>
			1b30: R_AARCH64_CALL26	kobject_put
    1b34:	2a1503e0 	mov	w0, w21
	put_device(old_parent);
out:
	device_pm_unlock();
	put_device(dev);
	return error;
}
    1b38:	a94153f3 	ldp	x19, x20, [sp,#16]
    1b3c:	a9425bf5 	ldp	x21, x22, [sp,#32]
    1b40:	a94363f7 	ldp	x23, x24, [sp,#48]
    1b44:	a9446bf9 	ldp	x25, x26, [sp,#64]
    1b48:	a94573fb 	ldp	x27, x28, [sp,#80]
    1b4c:	a8c77bfd 	ldp	x29, x30, [sp],#112
    1b50:	d65f03c0 	ret
	struct device *old_parent;
	struct kobject *new_parent_kobj;

	dev = get_device(dev);
	if (!dev)
		return -EINVAL;
    1b54:	128002a0 	mov	w0, #0xffffffea            	// #-22
	put_device(old_parent);
out:
	device_pm_unlock();
	put_device(dev);
	return error;
}
    1b58:	a94153f3 	ldp	x19, x20, [sp,#16]
    1b5c:	a9425bf5 	ldp	x21, x22, [sp,#32]
    1b60:	a94363f7 	ldp	x23, x24, [sp,#48]
    1b64:	a9446bf9 	ldp	x25, x26, [sp,#64]
    1b68:	a94573fb 	ldp	x27, x28, [sp,#80]
    1b6c:	a8c77bfd 	ldp	x29, x30, [sp],#112
    1b70:	d65f03c0 	ret
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
    1b74:	d2800014 	mov	x20, #0x0                   	// #0
    1b78:	17ffffbb 	b	1a64 <device_move+0x50>

	pr_debug("device: '%s': %s: moving to '%s'\n", dev_name(dev),
		 __func__, new_parent ? dev_name(new_parent) : "<NULL>");
	error = kobject_move(&dev->kobj, new_parent_kobj);
	if (error) {
		cleanup_glue_dir(dev, new_parent_kobj);
    1b7c:	aa1903e1 	mov	x1, x25
    1b80:	910a2260 	add	x0, x19, #0x288
    1b84:	97fffc4f 	bl	cc0 <cleanup_glue_dir.isra.17>
 * @dev: device in question.
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
    1b88:	b4fffd14 	cbz	x20, 1b28 <device_move+0x114>
		kobject_put(&dev->kobj);
    1b8c:	91004280 	add	x0, x20, #0x10
    1b90:	94000000 	bl	0 <kobject_put>
			1b90: R_AARCH64_CALL26	kobject_put
    1b94:	17ffffe5 	b	1b28 <device_move+0x114>
    1b98:	b9006fa0 	str	w0, [x29,#108]
				   struct device *new_parent)
{
	int error = 0;

	if (old_parent)
		sysfs_remove_link(&dev->kobj, "device");
    1b9c:	aa1b03e1 	mov	x1, x27
    1ba0:	aa1303e0 	mov	x0, x19
    1ba4:	94000000 	bl	0 <sysfs_remove_link>
			1ba4: R_AARCH64_CALL26	sysfs_remove_link
	if (new_parent)
    1ba8:	b9406fa3 	ldr	w3, [x29,#108]
    1bac:	b9006fa3 	str	w3, [x29,#108]
    1bb0:	b4000cf8 	cbz	x24, 1d4c <device_move+0x338>
		error = sysfs_create_link(&dev->kobj, &new_parent->kobj,
    1bb4:	91004314 	add	x20, x24, #0x10
    1bb8:	aa1b03e2 	mov	x2, x27
    1bbc:	aa1403e1 	mov	x1, x20
    1bc0:	aa1303e0 	mov	x0, x19
    1bc4:	94000000 	bl	0 <sysfs_create_link>
			1bc4: R_AARCH64_CALL26	sysfs_create_link
	if (dev->class) {
		error = device_move_class_links(dev, old_parent, new_parent);
		if (error) {
			/* We ignore errors on cleanup since we're hosed anyway... */
			device_move_class_links(dev, new_parent, old_parent);
			if (!kobject_move(&dev->kobj, &old_parent->kobj)) {
    1bc8:	aa1403e1 	mov	x1, x20
    1bcc:	aa1303e0 	mov	x0, x19
    1bd0:	94000000 	bl	0 <kobject_move>
			1bd0: R_AARCH64_CALL26	kobject_move
    1bd4:	b9406fa3 	ldr	w3, [x29,#108]
    1bd8:	35000160 	cbnz	w0, 1c04 <device_move+0x1f0>
				if (new_parent)
					klist_remove(&dev->p->knode_parent);
    1bdc:	f85f8260 	ldr	x0, [x19,#-8]
    1be0:	b9006fa3 	str	w3, [x29,#108]
    1be4:	9100a000 	add	x0, x0, #0x28
    1be8:	94000000 	bl	0 <klist_remove>
			1be8: R_AARCH64_CALL26	klist_remove
				dev->parent = old_parent;
    1bec:	f81f0278 	str	x24, [x19,#-16]
				if (old_parent) {
					klist_add_tail(&dev->p->knode_parent,
    1bf0:	f85f8260 	ldr	x0, [x19,#-8]
    1bf4:	f9400701 	ldr	x1, [x24,#8]
    1bf8:	9100a000 	add	x0, x0, #0x28
    1bfc:	94000000 	bl	0 <klist_add_tail>
			1bfc: R_AARCH64_CALL26	klist_add_tail
    1c00:	b9406fa3 	ldr	w3, [x29,#108]
						       &old_parent->p->klist_children);
					set_dev_node(dev, dev_to_node(old_parent));
				}
			}
			cleanup_glue_dir(dev, new_parent_kobj);
    1c04:	910a2260 	add	x0, x19, #0x288
    1c08:	aa1903e1 	mov	x1, x25
    1c0c:	b9006fa3 	str	w3, [x29,#108]
    1c10:	97fffc2c 	bl	cc0 <cleanup_glue_dir.isra.17>
    1c14:	b9406fa3 	ldr	w3, [x29,#108]
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
		kobject_put(&dev->kobj);
    1c18:	aa1c03e0 	mov	x0, x28
    1c1c:	2a0303f5 	mov	w21, w3
    1c20:	94000000 	bl	0 <kobject_put>
			1c20: R_AARCH64_CALL26	kobject_put
    1c24:	17ffffc1 	b	1b28 <device_move+0x114>
	case DPM_ORDER_DEV_AFTER_PARENT:
		device_pm_move_after(dev, new_parent);
		devices_kset_move_after(dev, new_parent);
		break;
	case DPM_ORDER_PARENT_BEFORE_DEV:
		device_pm_move_before(new_parent, dev);
    1c28:	aa1403e0 	mov	x0, x20
 * @deva: Device to move.
 * @devb: Device @deva should come before.
 */
static void devices_kset_move_before(struct device *deva, struct device *devb)
{
	if (!devices_kset)
    1c2c:	90000016 	adrp	x22, 0 <dev_attr_store>
			1c2c: R_AARCH64_ADR_PREL_PG_HI21	.bss
	case DPM_ORDER_DEV_AFTER_PARENT:
		device_pm_move_after(dev, new_parent);
		devices_kset_move_after(dev, new_parent);
		break;
	case DPM_ORDER_PARENT_BEFORE_DEV:
		device_pm_move_before(new_parent, dev);
    1c30:	aa1703e1 	mov	x1, x23
    1c34:	94000000 	bl	0 <device_pm_move_before>
			1c34: R_AARCH64_CALL26	device_pm_move_before
 * @deva: Device to move.
 * @devb: Device @deva should come before.
 */
static void devices_kset_move_before(struct device *deva, struct device *devb)
{
	if (!devices_kset)
    1c38:	f94002c0 	ldr	x0, [x22]
			1c38: R_AARCH64_LDST64_ABS_LO12_NC	.bss
    1c3c:	b4fff700 	cbz	x0, 1b1c <device_move+0x108>
		return;
	pr_debug("devices_kset: Moving %s before %s\n",
    1c40:	91000341 	add	x1, x26, #0x0
			1c40: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    1c44:	79422421 	ldrh	w1, [x1,#274]
    1c48:	37100ba1 	tbnz	w1, #2, 1dbc <device_move+0x3a8>
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    1c4c:	91004000 	add	x0, x0, #0x10
    1c50:	94000000 	bl	0 <_raw_spin_lock>
			1c50: R_AARCH64_CALL26	_raw_spin_lock
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1c54:	f9400e83 	ldr	x3, [x20,#24]
		 dev_name(deva), dev_name(devb));
	spin_lock(&devices_kset->list_lock);
	list_move_tail(&deva->kobj.entry, &devb->kobj.entry);
    1c58:	91006281 	add	x1, x20, #0x18
    1c5c:	f9401282 	ldr	x2, [x20,#32]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    1c60:	91002260 	add	x0, x19, #0x8
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1c64:	f9000462 	str	x2, [x3,#8]
    1c68:	f9000043 	str	x3, [x2]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    1c6c:	f9400a62 	ldr	x2, [x19,#16]
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    1c70:	f9000a61 	str	x1, [x19,#16]
	new->next = next;
    1c74:	f9000e80 	str	x0, [x20,#24]
	new->prev = prev;
    1c78:	f9001282 	str	x2, [x20,#32]
    1c7c:	f9000041 	str	x1, [x2]
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static __always_inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    1c80:	f94002c0 	ldr	x0, [x22]
			1c80: R_AARCH64_LDST64_ABS_LO12_NC	.bss
    1c84:	91004000 	add	x0, x0, #0x10
    1c88:	94000000 	bl	0 <_raw_spin_unlock>
			1c88: R_AARCH64_CALL26	_raw_spin_unlock
    1c8c:	17ffffa4 	b	1b1c <device_move+0x108>
	}
	switch (dpm_order) {
	case DPM_ORDER_NONE:
		break;
	case DPM_ORDER_DEV_AFTER_PARENT:
		device_pm_move_after(dev, new_parent);
    1c90:	aa1703e0 	mov	x0, x23
 * @deva: Device to move
 * @devb: Device @deva should come after.
 */
static void devices_kset_move_after(struct device *deva, struct device *devb)
{
	if (!devices_kset)
    1c94:	90000016 	adrp	x22, 0 <dev_attr_store>
			1c94: R_AARCH64_ADR_PREL_PG_HI21	.bss
	}
	switch (dpm_order) {
	case DPM_ORDER_NONE:
		break;
	case DPM_ORDER_DEV_AFTER_PARENT:
		device_pm_move_after(dev, new_parent);
    1c98:	aa1403e1 	mov	x1, x20
    1c9c:	94000000 	bl	0 <device_pm_move_after>
			1c9c: R_AARCH64_CALL26	device_pm_move_after
 * @deva: Device to move
 * @devb: Device @deva should come after.
 */
static void devices_kset_move_after(struct device *deva, struct device *devb)
{
	if (!devices_kset)
    1ca0:	f94002c0 	ldr	x0, [x22]
			1ca0: R_AARCH64_LDST64_ABS_LO12_NC	.bss
    1ca4:	b4fff3c0 	cbz	x0, 1b1c <device_move+0x108>
		return;
	pr_debug("devices_kset: Moving %s after %s\n",
    1ca8:	91000341 	add	x1, x26, #0x0
			1ca8: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    1cac:	7941d421 	ldrh	w1, [x1,#234]
    1cb0:	37100701 	tbnz	w1, #2, 1d90 <device_move+0x37c>
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    1cb4:	91004000 	add	x0, x0, #0x10
    1cb8:	94000000 	bl	0 <_raw_spin_lock>
			1cb8: R_AARCH64_CALL26	_raw_spin_lock
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1cbc:	f9400662 	ldr	x2, [x19,#8]
		 dev_name(deva), dev_name(devb));
	spin_lock(&devices_kset->list_lock);
	list_move(&deva->kobj.entry, &devb->kobj.entry);
    1cc0:	91002261 	add	x1, x19, #0x8
    1cc4:	f9400a60 	ldr	x0, [x19,#16]
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void list_add(struct list_head *new, struct list_head *head)
{
	__list_add(new, head, head->next);
    1cc8:	91006283 	add	x3, x20, #0x18
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1ccc:	f9000440 	str	x0, [x2,#8]
    1cd0:	f9000002 	str	x2, [x0]
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void list_add(struct list_head *new, struct list_head *head)
{
	__list_add(new, head, head->next);
    1cd4:	f9400e82 	ldr	x2, [x20,#24]
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static __always_inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    1cd8:	f94002c0 	ldr	x0, [x22]
			1cd8: R_AARCH64_LDST64_ABS_LO12_NC	.bss
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    1cdc:	f9000441 	str	x1, [x2,#8]
    1ce0:	91004000 	add	x0, x0, #0x10
	new->next = next;
    1ce4:	f9000662 	str	x2, [x19,#8]
	new->prev = prev;
    1ce8:	f9000a63 	str	x3, [x19,#16]
    1cec:	f9000e81 	str	x1, [x20,#24]
    1cf0:	94000000 	bl	0 <_raw_spin_unlock>
			1cf0: R_AARCH64_CALL26	_raw_spin_unlock
    1cf4:	17ffff8a 	b	1b1c <device_move+0x108>
	case DPM_ORDER_PARENT_BEFORE_DEV:
		device_pm_move_before(new_parent, dev);
		devices_kset_move_before(new_parent, dev);
		break;
	case DPM_ORDER_DEV_LAST:
		device_pm_move_last(dev);
    1cf8:	aa1703e0 	mov	x0, x23
    1cfc:	94000000 	bl	0 <device_pm_move_last>
			1cfc: R_AARCH64_CALL26	device_pm_move_last
		devices_kset_move_last(dev);
    1d00:	aa1703e0 	mov	x0, x23
    1d04:	94000000 	bl	1790 <devices_kset_move_last>
			1d04: R_AARCH64_CALL26	devices_kset_move_last
		break;
    1d08:	17ffff85 	b	1b1c <device_move+0x108>
#include <linux/pm_wakeup.h>

static inline const char *dev_name(const struct device *dev)
{
	/* Use the init name until the kobject becomes available */
	if (dev->init_name)
    1d0c:	f9402ae2 	ldr	x2, [x23,#80]
    1d10:	b40001a2 	cbz	x2, 1d44 <device_move+0x330>

	device_pm_lock();
	new_parent = get_device(new_parent);
	new_parent_kobj = get_device_parent(dev, new_parent);

	pr_debug("device: '%s': %s: moving to '%s'\n", dev_name(dev),
    1d14:	b4000354 	cbz	x20, 1d7c <device_move+0x368>
    1d18:	f9402a84 	ldr	x4, [x20,#80]
    1d1c:	b4000364 	cbz	x4, 1d88 <device_move+0x374>
    1d20:	90000003 	adrp	x3, 0 <dev_attr_store>
			1d20: R_AARCH64_ADR_PREL_PG_HI21	.rodata
    1d24:	91000340 	add	x0, x26, #0x0
			1d24: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    1d28:	91000063 	add	x3, x3, #0x0
			1d28: R_AARCH64_ADD_ABS_LO12_NC	.rodata
    1d2c:	90000001 	adrp	x1, 0 <dev_attr_store>
			1d2c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x2b0
    1d30:	9100c063 	add	x3, x3, #0x30
    1d34:	91000021 	add	x1, x1, #0x0
			1d34: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x2b0
    1d38:	91028000 	add	x0, x0, #0xa0
    1d3c:	94000000 	bl	0 <__dynamic_pr_debug>
			1d3c: R_AARCH64_CALL26	__dynamic_pr_debug
    1d40:	17ffff51 	b	1a84 <device_move+0x70>
    1d44:	f9400262 	ldr	x2, [x19]
    1d48:	17fffff3 	b	1d14 <device_move+0x300>
	if (dev->class) {
		error = device_move_class_links(dev, old_parent, new_parent);
		if (error) {
			/* We ignore errors on cleanup since we're hosed anyway... */
			device_move_class_links(dev, new_parent, old_parent);
			if (!kobject_move(&dev->kobj, &old_parent->kobj)) {
    1d4c:	d2800201 	mov	x1, #0x10                  	// #16
    1d50:	aa1303e0 	mov	x0, x19
    1d54:	94000000 	bl	0 <kobject_move>
			1d54: R_AARCH64_CALL26	kobject_move
    1d58:	b9406fa3 	ldr	w3, [x29,#108]
    1d5c:	35fff540 	cbnz	w0, 1c04 <device_move+0x1f0>
				if (new_parent)
					klist_remove(&dev->p->knode_parent);
    1d60:	f85f8260 	ldr	x0, [x19,#-8]
    1d64:	b9006fa3 	str	w3, [x29,#108]
    1d68:	9100a000 	add	x0, x0, #0x28
    1d6c:	94000000 	bl	0 <klist_remove>
			1d6c: R_AARCH64_CALL26	klist_remove
				dev->parent = old_parent;
    1d70:	f81f027f 	str	xzr, [x19,#-16]
    1d74:	b9406fa3 	ldr	w3, [x29,#108]
    1d78:	17ffffa3 	b	1c04 <device_move+0x1f0>

	device_pm_lock();
	new_parent = get_device(new_parent);
	new_parent_kobj = get_device_parent(dev, new_parent);

	pr_debug("device: '%s': %s: moving to '%s'\n", dev_name(dev),
    1d7c:	90000004 	adrp	x4, 0 <dev_attr_store>
			1d7c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x2a8
    1d80:	91000084 	add	x4, x4, #0x0
			1d80: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x2a8
    1d84:	17ffffe7 	b	1d20 <device_move+0x30c>
    1d88:	f9400a84 	ldr	x4, [x20,#16]
    1d8c:	17ffffe5 	b	1d20 <device_move+0x30c>
    1d90:	f9402ae2 	ldr	x2, [x23,#80]
    1d94:	b40002e2 	cbz	x2, 1df0 <device_move+0x3dc>
    1d98:	f9402a83 	ldr	x3, [x20,#80]
    1d9c:	b4000263 	cbz	x3, 1de8 <device_move+0x3d4>
 */
static void devices_kset_move_after(struct device *deva, struct device *devb)
{
	if (!devices_kset)
		return;
	pr_debug("devices_kset: Moving %s after %s\n",
    1da0:	91000340 	add	x0, x26, #0x0
			1da0: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    1da4:	90000001 	adrp	x1, 0 <dev_attr_store>
			1da4: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x2d8
    1da8:	91032000 	add	x0, x0, #0xc8
    1dac:	91000021 	add	x1, x1, #0x0
			1dac: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x2d8
    1db0:	94000000 	bl	0 <__dynamic_pr_debug>
			1db0: R_AARCH64_CALL26	__dynamic_pr_debug
    1db4:	f94002c0 	ldr	x0, [x22]
			1db4: R_AARCH64_LDST64_ABS_LO12_NC	.bss
    1db8:	17ffffbf 	b	1cb4 <device_move+0x2a0>
    1dbc:	f9402a82 	ldr	x2, [x20,#80]
    1dc0:	b4000202 	cbz	x2, 1e00 <device_move+0x3ec>
    1dc4:	f9402ae3 	ldr	x3, [x23,#80]
    1dc8:	b4000183 	cbz	x3, 1df8 <device_move+0x3e4>
 */
static void devices_kset_move_before(struct device *deva, struct device *devb)
{
	if (!devices_kset)
		return;
	pr_debug("devices_kset: Moving %s before %s\n",
    1dcc:	91000340 	add	x0, x26, #0x0
			1dcc: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    1dd0:	90000001 	adrp	x1, 0 <dev_attr_store>
			1dd0: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x300
    1dd4:	9103c000 	add	x0, x0, #0xf0
    1dd8:	91000021 	add	x1, x1, #0x0
			1dd8: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x300
    1ddc:	94000000 	bl	0 <__dynamic_pr_debug>
			1ddc: R_AARCH64_CALL26	__dynamic_pr_debug
    1de0:	f94002c0 	ldr	x0, [x22]
			1de0: R_AARCH64_LDST64_ABS_LO12_NC	.bss
    1de4:	17ffff9a 	b	1c4c <device_move+0x238>
    1de8:	f9400a83 	ldr	x3, [x20,#16]
    1dec:	17ffffed 	b	1da0 <device_move+0x38c>
    1df0:	f9400262 	ldr	x2, [x19]
    1df4:	17ffffe9 	b	1d98 <device_move+0x384>
    1df8:	f9400263 	ldr	x3, [x19]
    1dfc:	17fffff4 	b	1dcc <device_move+0x3b8>
    1e00:	f9400a82 	ldr	x2, [x20,#16]
    1e04:	17fffff0 	b	1dc4 <device_move+0x3b0>

0000000000001e08 <device_private_init>:
		sysfs_remove_link(kobj, devt_str);
	}
}

int device_private_init(struct device *dev)
{
    1e08:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
    1e0c:	52901801 	mov	w1, #0x80c0                	// #32960
    1e10:	910003fd 	mov	x29, sp
    1e14:	f9000bf3 	str	x19, [sp,#16]
    1e18:	aa0003f3 	mov	x19, x0
    1e1c:	90000000 	adrp	x0, 0 <kmalloc_caches>
			1e1c: R_AARCH64_ADR_PREL_PG_HI21	kmalloc_caches+0x40
    1e20:	72a04801 	movk	w1, #0x240, lsl #16
    1e24:	f9400000 	ldr	x0, [x0]
			1e24: R_AARCH64_LDST64_ABS_LO12_NC	kmalloc_caches+0x40
    1e28:	94000000 	bl	0 <kmem_cache_alloc>
			1e28: R_AARCH64_CALL26	kmem_cache_alloc
	dev->p = kzalloc(sizeof(*dev->p), GFP_KERNEL);
    1e2c:	f9000660 	str	x0, [x19,#8]
	if (!dev->p)
    1e30:	b4000200 	cbz	x0, 1e70 <device_private_init+0x68>
		return -ENOMEM;
	dev->p->device = dev;
    1e34:	f9004c13 	str	x19, [x0,#152]
	klist_init(&dev->p->klist_children, klist_children_get,
    1e38:	90000002 	adrp	x2, 0 <dev_attr_store>
			1e38: R_AARCH64_ADR_PREL_PG_HI21	.text+0x820
    1e3c:	90000001 	adrp	x1, 0 <dev_attr_store>
			1e3c: R_AARCH64_ADR_PREL_PG_HI21	.text+0x7e4
    1e40:	91000042 	add	x2, x2, #0x0
			1e40: R_AARCH64_ADD_ABS_LO12_NC	.text+0x820
    1e44:	f9400660 	ldr	x0, [x19,#8]
    1e48:	91000021 	add	x1, x1, #0x0
			1e48: R_AARCH64_ADD_ABS_LO12_NC	.text+0x7e4
    1e4c:	94000000 	bl	0 <klist_init>
			1e4c: R_AARCH64_CALL26	klist_init
		   klist_children_put);
	INIT_LIST_HEAD(&dev->p->deferred_probe);
    1e50:	f9400662 	ldr	x2, [x19,#8]
	return 0;
    1e54:	52800000 	mov	w0, #0x0                   	// #0
	if (!dev->p)
		return -ENOMEM;
	dev->p->device = dev;
	klist_init(&dev->p->klist_children, klist_children_get,
		   klist_children_put);
	INIT_LIST_HEAD(&dev->p->deferred_probe);
    1e58:	91022041 	add	x1, x2, #0x88
    1e5c:	f9004441 	str	x1, [x2,#136]
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	WRITE_ONCE(list->next, list);
	list->prev = list;
    1e60:	f9000421 	str	x1, [x1,#8]
	return 0;
}
    1e64:	f9400bf3 	ldr	x19, [sp,#16]
    1e68:	a8c27bfd 	ldp	x29, x30, [sp],#32
    1e6c:	d65f03c0 	ret

int device_private_init(struct device *dev)
{
	dev->p = kzalloc(sizeof(*dev->p), GFP_KERNEL);
	if (!dev->p)
		return -ENOMEM;
    1e70:	12800160 	mov	w0, #0xfffffff4            	// #-12
    1e74:	17fffffc 	b	1e64 <device_private_init+0x5c>

0000000000001e78 <device_add>:
 * NOTE: _Never_ directly free @dev after calling this function, even
 * if it returned an error! Always use put_device() to give up your
 * reference instead.
 */
int device_add(struct device *dev)
{
    1e78:	a9ba7bfd 	stp	x29, x30, [sp,#-96]!
    1e7c:	910003fd 	mov	x29, sp
    1e80:	a90153f3 	stp	x19, x20, [sp,#16]
    1e84:	a9025bf5 	stp	x21, x22, [sp,#32]
    1e88:	a90363f7 	stp	x23, x24, [sp,#48]
    1e8c:	a9046bf9 	stp	x25, x26, [sp,#64]
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
    1e90:	b4001020 	cbz	x0, 2094 <device_add+0x21c>
    1e94:	91004000 	add	x0, x0, #0x10
    1e98:	94000000 	bl	0 <kobject_get>
			1e98: R_AARCH64_CALL26	kobject_get
	struct kobject *kobj;
	struct class_interface *class_intf;
	int error = -EINVAL;

	dev = get_device(dev);
	if (!dev)
    1e9c:	f1004014 	subs	x20, x0, #0x10
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
    1ea0:	aa0003f3 	mov	x19, x0
	struct kobject *kobj;
	struct class_interface *class_intf;
	int error = -EINVAL;

	dev = get_device(dev);
	if (!dev)
    1ea4:	54000f80 	b.eq	2094 <device_add+0x21c>
		goto done;

	if (!dev->p) {
    1ea8:	f85f8000 	ldr	x0, [x0,#-8]
    1eac:	b4001700 	cbz	x0, 218c <device_add+0x314>
	/*
	 * for statically allocated devices, which should all be converted
	 * some day, we need to initialize the name. We prevent reading back
	 * the name, and force the use of dev_name()
	 */
	if (dev->init_name) {
    1eb0:	f9402a82 	ldr	x2, [x20,#80]
    1eb4:	b40000c2 	cbz	x2, 1ecc <device_add+0x54>
		dev_set_name(dev, "%s", dev->init_name);
    1eb8:	90000001 	adrp	x1, 0 <dev_attr_store>
			1eb8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x2a0
    1ebc:	aa1403e0 	mov	x0, x20
    1ec0:	91000021 	add	x1, x1, #0x0
			1ec0: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x2a0
    1ec4:	94000000 	bl	5b8 <dev_set_name>
			1ec4: R_AARCH64_CALL26	dev_set_name
		dev->init_name = NULL;
    1ec8:	f9002a9f 	str	xzr, [x20,#80]
    1ecc:	f9400262 	ldr	x2, [x19]
	}

	/* subsystems can specify simple device enumeration */
	if (!dev_name(dev) && dev->bus && dev->bus->dev_name)
    1ed0:	b5000182 	cbnz	x2, 1f00 <device_add+0x88>
    1ed4:	f9404680 	ldr	x0, [x20,#136]
    1ed8:	b4000fe0 	cbz	x0, 20d4 <device_add+0x25c>
    1edc:	f9400402 	ldr	x2, [x0,#8]
    1ee0:	b4000fa2 	cbz	x2, 20d4 <device_add+0x25c>
		dev_set_name(dev, "%s%u", dev->bus->dev_name, dev->id);
    1ee4:	b9425e83 	ldr	w3, [x20,#604]
    1ee8:	90000001 	adrp	x1, 0 <dev_attr_store>
			1ee8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x328
    1eec:	91000021 	add	x1, x1, #0x0
			1eec: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x328
    1ef0:	aa1403e0 	mov	x0, x20
    1ef4:	94000000 	bl	5b8 <dev_set_name>
			1ef4: R_AARCH64_CALL26	dev_set_name
    1ef8:	f9402a82 	ldr	x2, [x20,#80]
    1efc:	b4000e82 	cbz	x2, 20cc <device_add+0x254>
	if (!dev_name(dev)) {
		error = -EINVAL;
		goto name_error;
	}

	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
    1f00:	90000000 	adrp	x0, 0 <dev_attr_store>
			1f00: R_AARCH64_ADR_PREL_PG_HI21	__verbose
    1f04:	91000001 	add	x1, x0, #0x0
			1f04: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    1f08:	79427421 	ldrh	w1, [x1,#314]
    1f0c:	37101281 	tbnz	w1, #2, 215c <device_add+0x2e4>

	parent = get_device(dev->parent);
    1f10:	f85f0276 	ldr	x22, [x19,#-16]
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
    1f14:	b4000096 	cbz	x22, 1f24 <device_add+0xac>
    1f18:	910042c0 	add	x0, x22, #0x10
    1f1c:	94000000 	bl	0 <kobject_get>
			1f1c: R_AARCH64_CALL26	kobject_get
	bool			offline:1;
};

static inline struct device *kobj_to_dev(struct kobject *kobj)
{
	return container_of(kobj, struct device, kobj);
    1f20:	d1004016 	sub	x22, x0, #0x10
	}

	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);

	parent = get_device(dev->parent);
	kobj = get_device_parent(dev, parent);
    1f24:	aa1603e1 	mov	x1, x22
    1f28:	aa1403e0 	mov	x0, x20
    1f2c:	97fffe55 	bl	1880 <get_device_parent>
	if (kobj)
    1f30:	b4000d60 	cbz	x0, 20dc <device_add+0x264>
		dev->kobj.parent = kobj;
    1f34:	f9001680 	str	x0, [x20,#40]
    1f38:	aa0003e1 	mov	x1, x0
	if (parent && (dev_to_node(dev) == NUMA_NO_NODE))
		set_dev_node(dev, dev_to_node(parent));

	/* first, register with generic layer. */
	/* we require the name to be set before, and pass NULL */
	error = kobject_add(&dev->kobj, dev->kobj.parent, NULL);
    1f3c:	d2800002 	mov	x2, #0x0                   	// #0
    1f40:	aa1303e0 	mov	x0, x19
    1f44:	94000000 	bl	0 <kobject_add>
			1f44: R_AARCH64_CALL26	kobject_add
    1f48:	2a0003f5 	mov	w21, w0
	if (error)
    1f4c:	35000260 	cbnz	w0, 1f98 <device_add+0x120>
		goto Error;

	/* notify platform of device entry */
	if (platform_notify)
    1f50:	90000018 	adrp	x24, 0 <dev_attr_store>
			1f50: R_AARCH64_ADR_PREL_PG_HI21	.bss
    1f54:	91000300 	add	x0, x24, #0x0
			1f54: R_AARCH64_ADD_ABS_LO12_NC	.bss
    1f58:	f9401001 	ldr	x1, [x0,#32]
    1f5c:	b4000061 	cbz	x1, 1f68 <device_add+0xf0>
		platform_notify(dev);
    1f60:	aa1403e0 	mov	x0, x20
    1f64:	d63f0020 	blr	x1

	error = device_create_file(dev, &dev_attr_uevent);
    1f68:	90000017 	adrp	x23, 0 <dev_attr_store>
			1f68: R_AARCH64_ADR_PREL_PG_HI21	.data
    1f6c:	aa1403e0 	mov	x0, x20
    1f70:	910002e1 	add	x1, x23, #0x0
			1f70: R_AARCH64_ADD_ABS_LO12_NC	.data
    1f74:	91024021 	add	x1, x1, #0x90
    1f78:	94000000 	bl	23c <device_create_file>
			1f78: R_AARCH64_CALL26	device_create_file
    1f7c:	2a0003f5 	mov	w21, w0
	if (error)
    1f80:	34000300 	cbz	w0, 1fe0 <device_add+0x168>
 AttrsError:
	device_remove_class_symlinks(dev);
 SymlinkError:
	device_remove_file(dev, &dev_attr_uevent);
 attrError:
	kobject_uevent(&dev->kobj, KOBJ_REMOVE);
    1f84:	52800021 	mov	w1, #0x1                   	// #1
    1f88:	aa1303e0 	mov	x0, x19
    1f8c:	94000000 	bl	0 <kobject_uevent>
			1f8c: R_AARCH64_CALL26	kobject_uevent
	kobject_del(&dev->kobj);
    1f90:	aa1303e0 	mov	x0, x19
    1f94:	94000000 	bl	0 <kobject_del>
			1f94: R_AARCH64_CALL26	kobject_del
	mutex_unlock(&gdp_mutex);
}

static void cleanup_device_parent(struct device *dev)
{
	cleanup_glue_dir(dev, dev->kobj.parent);
    1f98:	f9401681 	ldr	x1, [x20,#40]
    1f9c:	910a2260 	add	x0, x19, #0x288
    1fa0:	97fffb48 	bl	cc0 <cleanup_glue_dir.isra.17>
 * @dev: device in question.
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
    1fa4:	b4000076 	cbz	x22, 1fb0 <device_add+0x138>
		kobject_put(&dev->kobj);
    1fa8:	910042c0 	add	x0, x22, #0x10
    1fac:	94000000 	bl	0 <kobject_put>
			1fac: R_AARCH64_CALL26	kobject_put
	kobject_del(&dev->kobj);
 Error:
	cleanup_device_parent(dev);
	put_device(parent);
name_error:
	kfree(dev->p);
    1fb0:	f85f8260 	ldr	x0, [x19,#-8]
    1fb4:	94000000 	bl	0 <kfree>
			1fb4: R_AARCH64_CALL26	kfree
	dev->p = NULL;
    1fb8:	f81f827f 	str	xzr, [x19,#-8]
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
		kobject_put(&dev->kobj);
    1fbc:	aa1303e0 	mov	x0, x19
    1fc0:	94000000 	bl	0 <kobject_put>
			1fc0: R_AARCH64_CALL26	kobject_put
	put_device(parent);
name_error:
	kfree(dev->p);
	dev->p = NULL;
	goto done;
}
    1fc4:	2a1503e0 	mov	w0, w21
    1fc8:	a94153f3 	ldp	x19, x20, [sp,#16]
    1fcc:	a9425bf5 	ldp	x21, x22, [sp,#32]
    1fd0:	a94363f7 	ldp	x23, x24, [sp,#48]
    1fd4:	a9446bf9 	ldp	x25, x26, [sp,#64]
    1fd8:	a8c67bfd 	ldp	x29, x30, [sp],#96
    1fdc:	d65f03c0 	ret
    1fe0:	f9411e61 	ldr	x1, [x19,#568]
static int device_add_class_symlinks(struct device *dev)
{
	struct device_node *of_node = dev_of_node(dev);
	int error;

	if (of_node) {
    1fe4:	b40000e1 	cbz	x1, 2000 <device_add+0x188>
		error = sysfs_create_link(&dev->kobj, &of_node->kobj,"of_node");
    1fe8:	90000002 	adrp	x2, 0 <dev_attr_store>
			1fe8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x108
    1fec:	91016021 	add	x1, x1, #0x58
    1ff0:	91000042 	add	x2, x2, #0x0
			1ff0: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x108
    1ff4:	aa1303e0 	mov	x0, x19
    1ff8:	94000000 	bl	0 <sysfs_create_link>
			1ff8: R_AARCH64_CALL26	sysfs_create_link
		if (error)
    1ffc:	350005c0 	cbnz	w0, 20b4 <device_add+0x23c>
			dev_warn(dev, "Error %d creating of_node link\n",error);
		/* An error here doesn't warrant bringing down the device */
	}

	if (!dev->class)
    2000:	f9414e80 	ldr	x0, [x20,#664]
    2004:	b4000be0 	cbz	x0, 2180 <device_add+0x308>
		return 0;

	error = sysfs_create_link(&dev->kobj,
    2008:	f9403801 	ldr	x1, [x0,#112]
    200c:	90000019 	adrp	x25, 0 <dev_attr_store>
			200c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x118
    2010:	91000322 	add	x2, x25, #0x0
			2010: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x118
    2014:	aa1303e0 	mov	x0, x19
    2018:	91006021 	add	x1, x1, #0x18
    201c:	94000000 	bl	0 <sysfs_create_link>
			201c: R_AARCH64_CALL26	sysfs_create_link
    2020:	2a0003f5 	mov	w21, w0
				  &dev->class->p->subsys.kobj,
				  "subsystem");
	if (error)
    2024:	35000240 	cbnz	w0, 206c <device_add+0x1f4>
		goto out_devnode;

	if (dev->parent && device_is_not_partition(dev)) {
    2028:	f85f0261 	ldr	x1, [x19,#-16]
    202c:	b40005c1 	cbz	x1, 20e4 <device_add+0x26c>
    2030:	f9402662 	ldr	x2, [x19,#72]
    2034:	90000000 	adrp	x0, 0 <part_type>
			2034: R_AARCH64_ADR_PREL_PG_HI21	part_type
    2038:	91000000 	add	x0, x0, #0x0
			2038: R_AARCH64_ADD_ABS_LO12_NC	part_type
    203c:	eb00005f 	cmp	x2, x0
    2040:	54000520 	b.eq	20e4 <device_add+0x26c>
		error = sysfs_create_link(&dev->kobj, &dev->parent->kobj,
    2044:	90000002 	adrp	x2, 0 <dev_attr_store>
			2044: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x110
    2048:	91004021 	add	x1, x1, #0x10
    204c:	91000042 	add	x2, x2, #0x0
			204c: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x110
    2050:	aa1303e0 	mov	x0, x19
    2054:	94000000 	bl	0 <sysfs_create_link>
			2054: R_AARCH64_CALL26	sysfs_create_link
    2058:	2a0003f5 	mov	w21, w0
					  "device");
		if (error)
    205c:	34000440 	cbz	w0, 20e4 <device_add+0x26c>

out_device:
	sysfs_remove_link(&dev->kobj, "device");

out_subsys:
	sysfs_remove_link(&dev->kobj, "subsystem");
    2060:	91000321 	add	x1, x25, #0x0
			2060: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x118
    2064:	aa1303e0 	mov	x0, x19
    2068:	94000000 	bl	0 <sysfs_remove_link>
			2068: R_AARCH64_CALL26	sysfs_remove_link
out_devnode:
	sysfs_remove_link(&dev->kobj, "of_node");
    206c:	90000001 	adrp	x1, 0 <dev_attr_store>
			206c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x108
    2070:	aa1303e0 	mov	x0, x19
    2074:	91000021 	add	x1, x1, #0x0
			2074: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x108
    2078:	94000000 	bl	0 <sysfs_remove_link>
			2078: R_AARCH64_CALL26	sysfs_remove_link
    207c:	910002e1 	add	x1, x23, #0x0
			207c: R_AARCH64_ADD_ABS_LO12_NC	.data
    2080:	d2800002 	mov	x2, #0x0                   	// #0
    2084:	91024021 	add	x1, x1, #0x90
    2088:	aa1303e0 	mov	x0, x19
    208c:	94000000 	bl	0 <sysfs_remove_file_ns>
			208c: R_AARCH64_CALL26	sysfs_remove_file_ns
    2090:	17ffffbd 	b	1f84 <device_add+0x10c>
	sysfs_remove_groups(&dev->kobj, groups);
}

static int device_add_attrs(struct device *dev)
{
	struct class *class = dev->class;
    2094:	128002b5 	mov	w21, #0xffffffea            	// #-22
	put_device(parent);
name_error:
	kfree(dev->p);
	dev->p = NULL;
	goto done;
}
    2098:	2a1503e0 	mov	w0, w21
    209c:	a94153f3 	ldp	x19, x20, [sp,#16]
    20a0:	a9425bf5 	ldp	x21, x22, [sp,#32]
    20a4:	a94363f7 	ldp	x23, x24, [sp,#48]
    20a8:	a9446bf9 	ldp	x25, x26, [sp,#64]
    20ac:	a8c67bfd 	ldp	x29, x30, [sp],#96
    20b0:	d65f03c0 	ret
	int error;

	if (of_node) {
		error = sysfs_create_link(&dev->kobj, &of_node->kobj,"of_node");
		if (error)
			dev_warn(dev, "Error %d creating of_node link\n",error);
    20b4:	90000001 	adrp	x1, 0 <dev_attr_store>
			20b4: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x330
    20b8:	2a0003e2 	mov	w2, w0
    20bc:	91000021 	add	x1, x1, #0x0
			20bc: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x330
    20c0:	aa1403e0 	mov	x0, x20
    20c4:	94000000 	bl	1598 <dev_warn>
			20c4: R_AARCH64_CALL26	dev_warn
    20c8:	17ffffce 	b	2000 <device_add+0x188>
    20cc:	f9400262 	ldr	x2, [x19]

	/* subsystems can specify simple device enumeration */
	if (!dev_name(dev) && dev->bus && dev->bus->dev_name)
		dev_set_name(dev, "%s%u", dev->bus->dev_name, dev->id);

	if (!dev_name(dev)) {
    20d0:	b5fff182 	cbnz	x2, 1f00 <device_add+0x88>
		error = -EINVAL;
    20d4:	128002b5 	mov	w21, #0xffffffea            	// #-22
    20d8:	17ffffb6 	b	1fb0 <device_add+0x138>
    20dc:	f9401681 	ldr	x1, [x20,#40]
    20e0:	17ffff97 	b	1f3c <device_add+0xc4>
	if (sysfs_deprecated && dev->class == &block_class)
		return 0;
#endif

	/* link in the class directory pointing to the device */
	error = sysfs_create_link(&dev->class->p->subsys.kobj,
    20e4:	f9414e80 	ldr	x0, [x20,#664]
#include <linux/pm_wakeup.h>

static inline const char *dev_name(const struct device *dev)
{
	/* Use the init name until the kobject becomes available */
	if (dev->init_name)
    20e8:	f9402a82 	ldr	x2, [x20,#80]
    20ec:	f9403800 	ldr	x0, [x0,#112]
    20f0:	91006000 	add	x0, x0, #0x18
    20f4:	b4001562 	cbz	x2, 23a0 <device_add+0x528>
    20f8:	aa1303e1 	mov	x1, x19
    20fc:	94000000 	bl	0 <sysfs_create_link>
			20fc: R_AARCH64_CALL26	sysfs_create_link
    2100:	2a0003f5 	mov	w21, w0
				  &dev->kobj, dev_name(dev));
	if (error)
    2104:	35000600 	cbnz	w0, 21c4 <device_add+0x34c>
	sysfs_remove_groups(&dev->kobj, groups);
}

static int device_add_attrs(struct device *dev)
{
	struct class *class = dev->class;
    2108:	f9414e99 	ldr	x25, [x20,#664]
	const struct device_type *type = dev->type;
    210c:	f9402e9a 	ldr	x26, [x20,#88]
	int error;

	if (class) {
    2110:	b40000d9 	cbz	x25, 2128 <device_add+0x2b0>
}
static DEVICE_ATTR_RW(online);

int device_add_groups(struct device *dev, const struct attribute_group **groups)
{
	return sysfs_create_groups(&dev->kobj, groups);
    2114:	f9400f21 	ldr	x1, [x25,#24]
    2118:	aa1303e0 	mov	x0, x19
    211c:	94000000 	bl	0 <sysfs_create_groups>
			211c: R_AARCH64_CALL26	sysfs_create_groups
    2120:	2a0003f5 	mov	w21, w0
	const struct device_type *type = dev->type;
	int error;

	if (class) {
		error = device_add_groups(dev, class->dev_groups);
		if (error)
    2124:	35000160 	cbnz	w0, 2150 <device_add+0x2d8>
			return error;
	}

	if (type) {
    2128:	b400059a 	cbz	x26, 21d8 <device_add+0x360>
}
static DEVICE_ATTR_RW(online);

int device_add_groups(struct device *dev, const struct attribute_group **groups)
{
	return sysfs_create_groups(&dev->kobj, groups);
    212c:	f9400741 	ldr	x1, [x26,#8]
    2130:	aa1303e0 	mov	x0, x19
    2134:	94000000 	bl	0 <sysfs_create_groups>
			2134: R_AARCH64_CALL26	sysfs_create_groups
    2138:	2a0003f5 	mov	w21, w0
			return error;
	}

	if (type) {
		error = device_add_groups(dev, type->groups);
		if (error)
    213c:	34000320 	cbz	w0, 21a0 <device_add+0x328>
	device_remove_groups(dev, dev->groups);
 err_remove_type_groups:
	if (type)
		device_remove_groups(dev, type->groups);
 err_remove_class_groups:
	if (class)
    2140:	b4000099 	cbz	x25, 2150 <device_add+0x2d8>
}

void device_remove_groups(struct device *dev,
			  const struct attribute_group **groups)
{
	sysfs_remove_groups(&dev->kobj, groups);
    2144:	f9400f21 	ldr	x1, [x25,#24]
    2148:	aa1303e0 	mov	x0, x19
    214c:	94000000 	bl	0 <sysfs_remove_groups>
			214c: R_AARCH64_CALL26	sysfs_remove_groups
 DPMError:
	bus_remove_device(dev);
 BusError:
	device_remove_attrs(dev);
 AttrsError:
	device_remove_class_symlinks(dev);
    2150:	aa1403e0 	mov	x0, x20
    2154:	97fff9bb 	bl	840 <device_remove_class_symlinks>
    2158:	17ffffc9 	b	207c <device_add+0x204>
	if (!dev_name(dev)) {
		error = -EINVAL;
		goto name_error;
	}

	pr_debug("device: '%s': %s\n", dev_name(dev), __func__);
    215c:	90000003 	adrp	x3, 0 <dev_attr_store>
			215c: R_AARCH64_ADR_PREL_PG_HI21	.rodata
    2160:	91000000 	add	x0, x0, #0x0
			2160: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    2164:	91000063 	add	x3, x3, #0x0
			2164: R_AARCH64_ADD_ABS_LO12_NC	.rodata
    2168:	90000001 	adrp	x1, 0 <dev_attr_store>
			2168: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0xc8
    216c:	91010063 	add	x3, x3, #0x40
    2170:	91000021 	add	x1, x1, #0x0
			2170: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0xc8
    2174:	91046000 	add	x0, x0, #0x118
    2178:	94000000 	bl	0 <__dynamic_pr_debug>
			2178: R_AARCH64_CALL26	__dynamic_pr_debug
    217c:	17ffff65 	b	1f10 <device_add+0x98>
}

static int device_add_attrs(struct device *dev)
{
	struct class *class = dev->class;
	const struct device_type *type = dev->type;
    2180:	f9402e9a 	ldr	x26, [x20,#88]
	sysfs_remove_groups(&dev->kobj, groups);
}

static int device_add_attrs(struct device *dev)
{
	struct class *class = dev->class;
    2184:	d2800019 	mov	x25, #0x0                   	// #0
    2188:	17ffffe8 	b	2128 <device_add+0x2b0>
	dev = get_device(dev);
	if (!dev)
		goto done;

	if (!dev->p) {
		error = device_private_init(dev);
    218c:	aa1403e0 	mov	x0, x20
    2190:	94000000 	bl	1e08 <device_private_init>
			2190: R_AARCH64_CALL26	device_private_init
    2194:	2a0003f5 	mov	w21, w0
		if (error)
    2198:	35fff120 	cbnz	w0, 1fbc <device_add+0x144>
    219c:	17ffff45 	b	1eb0 <device_add+0x38>
}
static DEVICE_ATTR_RW(online);

int device_add_groups(struct device *dev, const struct attribute_group **groups)
{
	return sysfs_create_groups(&dev->kobj, groups);
    21a0:	f9415281 	ldr	x1, [x20,#672]
    21a4:	aa1303e0 	mov	x0, x19
    21a8:	94000000 	bl	0 <sysfs_create_groups>
			21a8: R_AARCH64_CALL26	sysfs_create_groups
    21ac:	2a0003f5 	mov	w21, w0
		if (error)
			goto err_remove_class_groups;
	}

	error = device_add_groups(dev, dev->groups);
	if (error)
    21b0:	340001e0 	cbz	w0, 21ec <device_add+0x374>
}

void device_remove_groups(struct device *dev,
			  const struct attribute_group **groups)
{
	sysfs_remove_groups(&dev->kobj, groups);
    21b4:	f9400741 	ldr	x1, [x26,#8]
    21b8:	aa1303e0 	mov	x0, x19
    21bc:	94000000 	bl	0 <sysfs_remove_groups>
			21bc: R_AARCH64_CALL26	sysfs_remove_groups
    21c0:	17ffffe0 	b	2140 <device_add+0x2c8>
		goto out_device;

	return 0;

out_device:
	sysfs_remove_link(&dev->kobj, "device");
    21c4:	90000001 	adrp	x1, 0 <dev_attr_store>
			21c4: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x110
    21c8:	aa1303e0 	mov	x0, x19
    21cc:	91000021 	add	x1, x1, #0x0
			21cc: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x110
    21d0:	94000000 	bl	0 <sysfs_remove_link>
			21d0: R_AARCH64_CALL26	sysfs_remove_link
    21d4:	17ffffa3 	b	2060 <device_add+0x1e8>
}
static DEVICE_ATTR_RW(online);

int device_add_groups(struct device *dev, const struct attribute_group **groups)
{
	return sysfs_create_groups(&dev->kobj, groups);
    21d8:	f9415281 	ldr	x1, [x20,#672]
    21dc:	aa1303e0 	mov	x0, x19
    21e0:	94000000 	bl	0 <sysfs_create_groups>
			21e0: R_AARCH64_CALL26	sysfs_create_groups
    21e4:	2a0003f5 	mov	w21, w0
		if (error)
			goto err_remove_class_groups;
	}

	error = device_add_groups(dev, dev->groups);
	if (error)
    21e8:	35fffac0 	cbnz	w0, 2140 <device_add+0x2c8>
    21ec:	f9403e60 	ldr	x0, [x19,#120]
				      umode_t *mode, kuid_t *uid, kgid_t *gid,
				      const char **tmp);

static inline bool device_supports_offline(struct device *dev)
{
	return dev->bus && dev->bus->offline && dev->bus->online;
    21f0:	b40000e0 	cbz	x0, 220c <device_add+0x394>
    21f4:	f9403401 	ldr	x1, [x0,#104]
    21f8:	b40000a1 	cbz	x1, 220c <device_add+0x394>
    21fc:	f9403000 	ldr	x0, [x0,#96]
    2200:	b4000060 	cbz	x0, 220c <device_add+0x394>
		goto err_remove_type_groups;

	if (device_supports_offline(dev) && !dev->offline_disabled) {
    2204:	394ae280 	ldrb	w0, [x20,#696]
    2208:	36000d00 	tbz	w0, #0, 23a8 <device_add+0x530>
	if (error)
		goto SymlinkError;
	error = device_add_attrs(dev);
	if (error)
		goto AttrsError;
	error = bus_add_device(dev);
    220c:	aa1403e0 	mov	x0, x20
    2210:	94000000 	bl	0 <bus_add_device>
			2210: R_AARCH64_CALL26	bus_add_device
    2214:	2a0003f5 	mov	w21, w0
	if (error)
    2218:	35000be0 	cbnz	w0, 2394 <device_add+0x51c>
		goto BusError;
	error = dpm_sysfs_add(dev);
    221c:	aa1403e0 	mov	x0, x20
    2220:	94000000 	bl	0 <dpm_sysfs_add>
			2220: R_AARCH64_CALL26	dpm_sysfs_add
    2224:	2a0003f5 	mov	w21, w0
	if (error)
    2228:	35000b20 	cbnz	w0, 238c <device_add+0x514>
		goto DPMError;
	device_pm_add(dev);
    222c:	aa1403e0 	mov	x0, x20
    2230:	94000000 	bl	0 <device_pm_add>
			2230: R_AARCH64_CALL26	device_pm_add

	if (MAJOR(dev->devt)) {
    2234:	b9425a80 	ldr	w0, [x20,#600]
    2238:	53147c00 	lsr	w0, w0, #20
    223c:	35000600 	cbnz	w0, 22fc <device_add+0x484>
	}

	/* Notify clients of device addition.  This call must come
	 * after dpm_sysfs_add() and before kobject_uevent().
	 */
	if (dev->bus)
    2240:	f9404680 	ldr	x0, [x20,#136]
    2244:	b40000c0 	cbz	x0, 225c <device_add+0x3e4>
		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
    2248:	f9404800 	ldr	x0, [x0,#144]
    224c:	aa1403e2 	mov	x2, x20
    2250:	d2800021 	mov	x1, #0x1                   	// #1
    2254:	9103e000 	add	x0, x0, #0xf8
    2258:	94000000 	bl	0 <blocking_notifier_call_chain>
			2258: R_AARCH64_CALL26	blocking_notifier_call_chain
					     BUS_NOTIFY_ADD_DEVICE, dev);

	kobject_uevent(&dev->kobj, KOBJ_ADD);
    225c:	52800001 	mov	w1, #0x0                   	// #0
    2260:	aa1303e0 	mov	x0, x19
    2264:	94000000 	bl	0 <kobject_uevent>
			2264: R_AARCH64_CALL26	kobject_uevent
	bus_probe_device(dev);
    2268:	aa1403e0 	mov	x0, x20
    226c:	94000000 	bl	0 <bus_probe_device>
			226c: R_AARCH64_CALL26	bus_probe_device
	if (parent)
    2270:	b40000b6 	cbz	x22, 2284 <device_add+0x40c>
		klist_add_tail(&dev->p->knode_parent,
    2274:	f85f8260 	ldr	x0, [x19,#-8]
    2278:	f94006c1 	ldr	x1, [x22,#8]
    227c:	9100a000 	add	x0, x0, #0x28
    2280:	94000000 	bl	0 <klist_add_tail>
			2280: R_AARCH64_CALL26	klist_add_tail
			       &parent->p->klist_children);

	if (dev->class) {
    2284:	f9414e80 	ldr	x0, [x20,#664]
    2288:	b4ffe9a0 	cbz	x0, 1fbc <device_add+0x144>
		mutex_lock(&dev->class->p->mutex);
    228c:	f9403800 	ldr	x0, [x0,#112]
    2290:	9101e000 	add	x0, x0, #0x78
    2294:	94000000 	bl	0 <mutex_lock>
			2294: R_AARCH64_CALL26	mutex_lock
		/* tie the class to the device */
		klist_add_tail(&dev->knode_class,
			       &dev->class->p->klist_devices);
    2298:	f9414e81 	ldr	x1, [x20,#664]
			       &parent->p->klist_children);

	if (dev->class) {
		mutex_lock(&dev->class->p->mutex);
		/* tie the class to the device */
		klist_add_tail(&dev->knode_class,
    229c:	9109a260 	add	x0, x19, #0x268
    22a0:	f9403821 	ldr	x1, [x1,#112]
    22a4:	9102a021 	add	x1, x1, #0xa8
    22a8:	94000000 	bl	0 <klist_add_tail>
			22a8: R_AARCH64_CALL26	klist_add_tail
			       &dev->class->p->klist_devices);

		/* notify any interfaces that the device is here */
		list_for_each_entry(class_intf,
    22ac:	f9414e80 	ldr	x0, [x20,#664]
    22b0:	f9403800 	ldr	x0, [x0,#112]
    22b4:	aa0003e1 	mov	x1, x0
    22b8:	f8468c36 	ldr	x22, [x1,#104]!
    22bc:	eb0102df 	cmp	x22, x1
    22c0:	54000180 	b.eq	22f0 <device_add+0x478>
				    &dev->class->p->interfaces, node)
			if (class_intf->add_dev)
    22c4:	f9400ec2 	ldr	x2, [x22,#24]
				class_intf->add_dev(dev, class_intf);
    22c8:	aa1603e1 	mov	x1, x22
    22cc:	aa1403e0 	mov	x0, x20
			       &dev->class->p->klist_devices);

		/* notify any interfaces that the device is here */
		list_for_each_entry(class_intf,
				    &dev->class->p->interfaces, node)
			if (class_intf->add_dev)
    22d0:	b4000042 	cbz	x2, 22d8 <device_add+0x460>
				class_intf->add_dev(dev, class_intf);
    22d4:	d63f0040 	blr	x2
		/* tie the class to the device */
		klist_add_tail(&dev->knode_class,
			       &dev->class->p->klist_devices);

		/* notify any interfaces that the device is here */
		list_for_each_entry(class_intf,
    22d8:	f9414e80 	ldr	x0, [x20,#664]
    22dc:	f94002d6 	ldr	x22, [x22]
    22e0:	f9403800 	ldr	x0, [x0,#112]
    22e4:	9101a001 	add	x1, x0, #0x68
    22e8:	eb0102df 	cmp	x22, x1
    22ec:	54fffec1 	b.ne	22c4 <device_add+0x44c>
				    &dev->class->p->interfaces, node)
			if (class_intf->add_dev)
				class_intf->add_dev(dev, class_intf);
		mutex_unlock(&dev->class->p->mutex);
    22f0:	9101e000 	add	x0, x0, #0x78
    22f4:	94000000 	bl	0 <mutex_unlock>
			22f4: R_AARCH64_CALL26	mutex_unlock
    22f8:	17ffff31 	b	1fbc <device_add+0x144>
	if (error)
		goto DPMError;
	device_pm_add(dev);

	if (MAJOR(dev->devt)) {
		error = device_create_file(dev, &dev_attr_dev);
    22fc:	910002e1 	add	x1, x23, #0x0
			22fc: R_AARCH64_ADD_ABS_LO12_NC	.data
    2300:	aa1403e0 	mov	x0, x20
    2304:	9101c021 	add	x1, x1, #0x70
    2308:	94000000 	bl	23c <device_create_file>
			2308: R_AARCH64_CALL26	device_create_file
    230c:	2a0003f9 	mov	w25, w0
		if (error)
    2310:	35000340 	cbnz	w0, 2378 <device_add+0x500>
    2314:	f9414660 	ldr	x0, [x19,#648]
 */
static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;

	if (dev->class)
    2318:	b4000640 	cbz	x0, 23e0 <device_add+0x568>
		kobj = dev->class->dev_kobj;
    231c:	f9401018 	ldr	x24, [x0,#32]
{
	struct kobject *kobj = device_to_dev_kobj(dev);
	int error = 0;
	char devt_str[15];

	if (kobj) {
    2320:	b40005b8 	cbz	x24, 23d4 <device_add+0x55c>
		format_dev_t(devt_str, dev->devt);
    2324:	b9425a82 	ldr	w2, [x20,#600]
    2328:	90000001 	adrp	x1, 0 <dev_attr_store>
			2328: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x168
    232c:	91000021 	add	x1, x1, #0x0
			232c: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x168
    2330:	910143a0 	add	x0, x29, #0x50
    2334:	12004c43 	and	w3, w2, #0xfffff
    2338:	53147c42 	lsr	w2, w2, #20
    233c:	94000000 	bl	0 <sprintf>
			233c: R_AARCH64_CALL26	sprintf
		error = sysfs_create_link(kobj, &dev->kobj, devt_str);
    2340:	910143a2 	add	x2, x29, #0x50
    2344:	aa1303e1 	mov	x1, x19
    2348:	aa1803e0 	mov	x0, x24
    234c:	94000000 	bl	0 <sysfs_create_link>
			234c: R_AARCH64_CALL26	sysfs_create_link
    2350:	2a0003f9 	mov	w25, w0
		error = device_create_file(dev, &dev_attr_dev);
		if (error)
			goto DevAttrError;

		error = device_create_sys_dev_entry(dev);
		if (error)
    2354:	34000400 	cbz	w0, 23d4 <device_add+0x55c>
	}
done:
	put_device(dev);
	return error;
 SysEntryError:
	if (MAJOR(dev->devt))
    2358:	b9425a80 	ldr	w0, [x20,#600]
    235c:	53147c00 	lsr	w0, w0, #20
    2360:	340000c0 	cbz	w0, 2378 <device_add+0x500>
    2364:	910002e1 	add	x1, x23, #0x0
			2364: R_AARCH64_ADD_ABS_LO12_NC	.data
    2368:	d2800002 	mov	x2, #0x0                   	// #0
    236c:	9101c021 	add	x1, x1, #0x70
    2370:	aa1303e0 	mov	x0, x19
    2374:	94000000 	bl	0 <sysfs_remove_file_ns>
			2374: R_AARCH64_CALL26	sysfs_remove_file_ns
		device_remove_file(dev, &dev_attr_dev);
 DevAttrError:
	device_pm_remove(dev);
    2378:	aa1403e0 	mov	x0, x20
	dpm_sysfs_remove(dev);
    237c:	2a1903f5 	mov	w21, w25
	return error;
 SysEntryError:
	if (MAJOR(dev->devt))
		device_remove_file(dev, &dev_attr_dev);
 DevAttrError:
	device_pm_remove(dev);
    2380:	94000000 	bl	0 <device_pm_remove>
			2380: R_AARCH64_CALL26	device_pm_remove
	dpm_sysfs_remove(dev);
    2384:	aa1403e0 	mov	x0, x20
    2388:	94000000 	bl	0 <dpm_sysfs_remove>
			2388: R_AARCH64_CALL26	dpm_sysfs_remove
 DPMError:
	bus_remove_device(dev);
    238c:	aa1403e0 	mov	x0, x20
    2390:	94000000 	bl	0 <bus_remove_device>
			2390: R_AARCH64_CALL26	bus_remove_device
 BusError:
	device_remove_attrs(dev);
    2394:	aa1403e0 	mov	x0, x20
    2398:	97fff7da 	bl	300 <device_remove_attrs>
    239c:	17ffff6d 	b	2150 <device_add+0x2d8>
    23a0:	f9400262 	ldr	x2, [x19]
    23a4:	17ffff55 	b	20f8 <device_add+0x280>
	error = device_add_groups(dev, dev->groups);
	if (error)
		goto err_remove_type_groups;

	if (device_supports_offline(dev) && !dev->offline_disabled) {
		error = device_create_file(dev, &dev_attr_online);
    23a8:	910002e1 	add	x1, x23, #0x0
			23a8: R_AARCH64_ADD_ABS_LO12_NC	.data
    23ac:	aa1403e0 	mov	x0, x20
    23b0:	9100a021 	add	x1, x1, #0x28
    23b4:	94000000 	bl	23c <device_create_file>
			23b4: R_AARCH64_CALL26	device_create_file
    23b8:	2a0003f5 	mov	w21, w0
		if (error)
    23bc:	34fff280 	cbz	w0, 220c <device_add+0x394>
}

void device_remove_groups(struct device *dev,
			  const struct attribute_group **groups)
{
	sysfs_remove_groups(&dev->kobj, groups);
    23c0:	f9415281 	ldr	x1, [x20,#672]
    23c4:	aa1303e0 	mov	x0, x19
    23c8:	94000000 	bl	0 <sysfs_remove_groups>
			23c8: R_AARCH64_CALL26	sysfs_remove_groups
	return 0;

 err_remove_dev_groups:
	device_remove_groups(dev, dev->groups);
 err_remove_type_groups:
	if (type)
    23cc:	b5ffef5a 	cbnz	x26, 21b4 <device_add+0x33c>
    23d0:	17ffff5c 	b	2140 <device_add+0x2c8>

		error = device_create_sys_dev_entry(dev);
		if (error)
			goto SysEntryError;

		devtmpfs_create_node(dev);
    23d4:	aa1403e0 	mov	x0, x20
    23d8:	94000000 	bl	0 <devtmpfs_create_node>
			23d8: R_AARCH64_CALL26	devtmpfs_create_node
    23dc:	17ffff99 	b	2240 <device_add+0x3c8>
	struct kobject *kobj;

	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;
    23e0:	91000318 	add	x24, x24, #0x0
			23e0: R_AARCH64_ADD_ABS_LO12_NC	.bss
    23e4:	f9400718 	ldr	x24, [x24,#8]
    23e8:	17ffffce 	b	2320 <device_add+0x4a8>

00000000000023ec <device_register>:
 * NOTE: _Never_ directly free @dev after calling this function, even
 * if it returned an error! Always use put_device() to give up the
 * reference initialized in this function instead.
 */
int device_register(struct device *dev)
{
    23ec:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
    23f0:	910003fd 	mov	x29, sp
    23f4:	f9000bf3 	str	x19, [sp,#16]
    23f8:	aa0003f3 	mov	x19, x0
	device_initialize(dev);
    23fc:	94000000 	bl	510 <device_initialize>
			23fc: R_AARCH64_CALL26	device_initialize
	return device_add(dev);
    2400:	aa1303e0 	mov	x0, x19
    2404:	94000000 	bl	1e78 <device_add>
			2404: R_AARCH64_CALL26	device_add
}
    2408:	f9400bf3 	ldr	x19, [sp,#16]
    240c:	a8c27bfd 	ldp	x29, x30, [sp],#32
    2410:	d65f03c0 	ret

0000000000002414 <__root_device_register>:
 * Returns &struct device pointer on success, or ERR_PTR() on error.
 *
 * Note: You probably want to use root_device_register().
 */
struct device *__root_device_register(const char *name, struct module *owner)
{
    2414:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
    2418:	52901803 	mov	w3, #0x80c0                	// #32960
    241c:	910003fd 	mov	x29, sp
    2420:	72a04803 	movk	w3, #0x240, lsl #16
    2424:	f90013f5 	str	x21, [sp,#32]
    2428:	aa0103f5 	mov	x21, x1
    242c:	2a0303e1 	mov	w1, w3
    2430:	90000003 	adrp	x3, 0 <kmalloc_caches>
			2430: R_AARCH64_ADR_PREL_PG_HI21	kmalloc_caches+0x50
    2434:	a90153f3 	stp	x19, x20, [sp,#16]
    2438:	aa0003f4 	mov	x20, x0
    243c:	f9400060 	ldr	x0, [x3]
			243c: R_AARCH64_LDST64_ABS_LO12_NC	kmalloc_caches+0x50
    2440:	94000000 	bl	0 <kmem_cache_alloc>
			2440: R_AARCH64_CALL26	kmem_cache_alloc
    2444:	aa0003f3 	mov	x19, x0
	struct root_device *root;
	int err = -ENOMEM;

	root = kzalloc(sizeof(struct root_device), GFP_KERNEL);
	if (!root)
    2448:	b40005a0 	cbz	x0, 24fc <__root_device_register+0xe8>
		return ERR_PTR(err);

	err = dev_set_name(&root->dev, "%s", name);
    244c:	90000001 	adrp	x1, 0 <dev_attr_store>
			244c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x2a0
    2450:	aa1403e2 	mov	x2, x20
    2454:	91000021 	add	x1, x1, #0x0
			2454: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x2a0
    2458:	94000000 	bl	5b8 <dev_set_name>
			2458: R_AARCH64_CALL26	dev_set_name
    245c:	2a0003e2 	mov	w2, w0
	if (err) {
		kfree(root);
    2460:	aa1303e0 	mov	x0, x19
	root = kzalloc(sizeof(struct root_device), GFP_KERNEL);
	if (!root)
		return ERR_PTR(err);

	err = dev_set_name(&root->dev, "%s", name);
	if (err) {
    2464:	35000222 	cbnz	w2, 24a8 <__root_device_register+0x94>
		kfree(root);
		return ERR_PTR(err);
	}

	root->dev.release = root_device_release;
    2468:	90000002 	adrp	x2, 0 <dev_attr_store>
			2468: R_AARCH64_ADR_PREL_PG_HI21	.text+0x48c
    246c:	91000042 	add	x2, x2, #0x0
			246c: R_AARCH64_ADD_ABS_LO12_NC	.text+0x48c
    2470:	f9015662 	str	x2, [x19,#680]
 * if it returned an error! Always use put_device() to give up the
 * reference initialized in this function instead.
 */
int device_register(struct device *dev)
{
	device_initialize(dev);
    2474:	94000000 	bl	510 <device_initialize>
			2474: R_AARCH64_CALL26	device_initialize
	return device_add(dev);
    2478:	aa1303e0 	mov	x0, x19
    247c:	94000000 	bl	1e78 <device_add>
			247c: R_AARCH64_CALL26	device_add
    2480:	2a0003e1 	mov	w1, w0
	}

	root->dev.release = root_device_release;

	err = device_register(&root->dev);
	if (err) {
    2484:	34000200 	cbz	w0, 24c4 <__root_device_register+0xb0>
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
		kobject_put(&dev->kobj);
    2488:	91004260 	add	x0, x19, #0x10
	root->dev.release = root_device_release;

	err = device_register(&root->dev);
	if (err) {
		put_device(&root->dev);
		return ERR_PTR(err);
    248c:	93407c33 	sxtw	x19, w1
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
		kobject_put(&dev->kobj);
    2490:	94000000 	bl	0 <kobject_put>
			2490: R_AARCH64_CALL26	kobject_put
		root->owner = owner;
	}
#endif

	return &root->dev;
}
    2494:	aa1303e0 	mov	x0, x19
    2498:	f94013f5 	ldr	x21, [sp,#32]
    249c:	a94153f3 	ldp	x19, x20, [sp,#16]
    24a0:	a8c37bfd 	ldp	x29, x30, [sp],#48
    24a4:	d65f03c0 	ret
		return ERR_PTR(err);

	err = dev_set_name(&root->dev, "%s", name);
	if (err) {
		kfree(root);
		return ERR_PTR(err);
    24a8:	93407c53 	sxtw	x19, w2
	if (!root)
		return ERR_PTR(err);

	err = dev_set_name(&root->dev, "%s", name);
	if (err) {
		kfree(root);
    24ac:	94000000 	bl	0 <kfree>
			24ac: R_AARCH64_CALL26	kfree
		root->owner = owner;
	}
#endif

	return &root->dev;
}
    24b0:	aa1303e0 	mov	x0, x19
    24b4:	f94013f5 	ldr	x21, [sp,#32]
    24b8:	a94153f3 	ldp	x19, x20, [sp,#16]
    24bc:	a8c37bfd 	ldp	x29, x30, [sp],#48
    24c0:	d65f03c0 	ret
		put_device(&root->dev);
		return ERR_PTR(err);
	}

#ifdef CONFIG_MODULES	/* gotta find a "cleaner" way to do this */
	if (owner) {
    24c4:	b4fffe95 	cbz	x21, 2494 <__root_device_register+0x80>
		struct module_kobject *mk = &owner->mkobj;

		err = sysfs_create_link(&root->dev.kobj, &mk->kobj, "module");
    24c8:	90000002 	adrp	x2, 0 <dev_attr_store>
			24c8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x170
    24cc:	910142a1 	add	x1, x21, #0x50
    24d0:	91000042 	add	x2, x2, #0x0
			24d0: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x170
    24d4:	91004260 	add	x0, x19, #0x10
    24d8:	94000000 	bl	0 <sysfs_create_link>
			24d8: R_AARCH64_CALL26	sysfs_create_link
    24dc:	2a0003e1 	mov	w1, w0
		if (err) {
    24e0:	350001a0 	cbnz	w0, 2514 <__root_device_register+0x100>
			device_unregister(&root->dev);
			return ERR_PTR(err);
		}
		root->owner = owner;
    24e4:	f9016275 	str	x21, [x19,#704]
	}
#endif

	return &root->dev;
}
    24e8:	aa1303e0 	mov	x0, x19
    24ec:	a94153f3 	ldp	x19, x20, [sp,#16]
    24f0:	f94013f5 	ldr	x21, [sp,#32]
    24f4:	a8c37bfd 	ldp	x29, x30, [sp],#48
    24f8:	d65f03c0 	ret
	struct root_device *root;
	int err = -ENOMEM;

	root = kzalloc(sizeof(struct root_device), GFP_KERNEL);
	if (!root)
		return ERR_PTR(err);
    24fc:	92800173 	mov	x19, #0xfffffffffffffff4    	// #-12
		root->owner = owner;
	}
#endif

	return &root->dev;
}
    2500:	f94013f5 	ldr	x21, [sp,#32]
    2504:	aa1303e0 	mov	x0, x19
    2508:	a94153f3 	ldp	x19, x20, [sp,#16]
    250c:	a8c37bfd 	ldp	x29, x30, [sp],#48
    2510:	d65f03c0 	ret
	if (owner) {
		struct module_kobject *mk = &owner->mkobj;

		err = sysfs_create_link(&root->dev.kobj, &mk->kobj, "module");
		if (err) {
			device_unregister(&root->dev);
    2514:	aa1303e0 	mov	x0, x19
			return ERR_PTR(err);
    2518:	93407c33 	sxtw	x19, w1
	if (owner) {
		struct module_kobject *mk = &owner->mkobj;

		err = sysfs_create_link(&root->dev.kobj, &mk->kobj, "module");
		if (err) {
			device_unregister(&root->dev);
    251c:	94000000 	bl	f2c <device_unregister>
			251c: R_AARCH64_CALL26	device_unregister
			return ERR_PTR(err);
    2520:	17ffffdd 	b	2494 <__root_device_register+0x80>

0000000000002524 <device_create_groups_vargs>:
static struct device *
device_create_groups_vargs(struct class *class, struct device *parent,
			   dev_t devt, void *drvdata,
			   const struct attribute_group **groups,
			   const char *fmt, va_list args)
{
    2524:	a9b87bfd 	stp	x29, x30, [sp,#-128]!
    2528:	910003fd 	mov	x29, sp
    252c:	a90153f3 	stp	x19, x20, [sp,#16]
    2530:	a9025bf5 	stp	x21, x22, [sp,#32]
    2534:	a90363f7 	stp	x23, x24, [sp,#48]
    2538:	a9046bf9 	stp	x25, x26, [sp,#64]
    253c:	f9002bfb 	str	x27, [sp,#80]
	struct device *dev = NULL;
	int retval = -ENODEV;

	if (class == NULL || IS_ERR(class))
    2540:	b40005e0 	cbz	x0, 25fc <device_create_groups_vargs+0xd8>
    2544:	b140041f 	cmn	x0, #0x1, lsl #12
    2548:	540005a8 	b.hi	25fc <device_create_groups_vargs+0xd8>
    254c:	aa0003f4 	mov	x20, x0
    2550:	90000000 	adrp	x0, 0 <kmalloc_caches>
			2550: R_AARCH64_ADR_PREL_PG_HI21	kmalloc_caches+0x50
    2554:	aa0103fa 	mov	x26, x1
    2558:	52901801 	mov	w1, #0x80c0                	// #32960
    255c:	72a04801 	movk	w1, #0x240, lsl #16
    2560:	aa0603f5 	mov	x21, x6
    2564:	f9400000 	ldr	x0, [x0]
			2564: R_AARCH64_LDST64_ABS_LO12_NC	kmalloc_caches+0x50
    2568:	aa0503f7 	mov	x23, x5
    256c:	aa0403f8 	mov	x24, x4
    2570:	aa0303f6 	mov	x22, x3
    2574:	2a0203f9 	mov	w25, w2
    2578:	94000000 	bl	0 <kmem_cache_alloc>
			2578: R_AARCH64_CALL26	kmem_cache_alloc
    257c:	aa0003f3 	mov	x19, x0
		goto error;

	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
	if (!dev) {
    2580:	b40004e0 	cbz	x0, 261c <device_create_groups_vargs+0xf8>
		retval = -ENOMEM;
		goto error;
	}

	device_initialize(dev);
    2584:	94000000 	bl	510 <device_initialize>
			2584: R_AARCH64_CALL26	device_initialize
	dev->parent = parent;
	dev->groups = groups;
	dev->release = device_create_release;
	dev_set_drvdata(dev, drvdata);

	retval = kobject_set_name_vargs(&dev->kobj, fmt, args);
    2588:	9100427b 	add	x27, x19, #0x10
    258c:	a9401ea6 	ldp	x6, x7, [x21]
    2590:	a94116a4 	ldp	x4, x5, [x21,#16]
	device_initialize(dev);
	dev->devt = devt;
	dev->class = class;
	dev->parent = parent;
	dev->groups = groups;
	dev->release = device_create_release;
    2594:	90000003 	adrp	x3, 0 <dev_attr_store>
			2594: R_AARCH64_ADR_PREL_PG_HI21	.text+0x4a0
		goto error;
	}

	device_initialize(dev);
	dev->devt = devt;
	dev->class = class;
    2598:	f9014e74 	str	x20, [x19,#664]
		retval = -ENOMEM;
		goto error;
	}

	device_initialize(dev);
	dev->devt = devt;
    259c:	b9025a79 	str	w25, [x19,#600]
	dev->class = class;
	dev->parent = parent;
	dev->groups = groups;
	dev->release = device_create_release;
    25a0:	91000063 	add	x3, x3, #0x0
			25a0: R_AARCH64_ADD_ABS_LO12_NC	.text+0x4a0
	}

	device_initialize(dev);
	dev->devt = devt;
	dev->class = class;
	dev->parent = parent;
    25a4:	f900027a 	str	x26, [x19]
	dev->groups = groups;
	dev->release = device_create_release;
	dev_set_drvdata(dev, drvdata);

	retval = kobject_set_name_vargs(&dev->kobj, fmt, args);
    25a8:	910183a2 	add	x2, x29, #0x60

	device_initialize(dev);
	dev->devt = devt;
	dev->class = class;
	dev->parent = parent;
	dev->groups = groups;
    25ac:	f9015278 	str	x24, [x19,#672]
	dev->release = device_create_release;
	dev_set_drvdata(dev, drvdata);

	retval = kobject_set_name_vargs(&dev->kobj, fmt, args);
    25b0:	aa1703e1 	mov	x1, x23
	device_initialize(dev);
	dev->devt = devt;
	dev->class = class;
	dev->parent = parent;
	dev->groups = groups;
	dev->release = device_create_release;
    25b4:	f9015663 	str	x3, [x19,#680]
	dev_set_drvdata(dev, drvdata);

	retval = kobject_set_name_vargs(&dev->kobj, fmt, args);
    25b8:	aa1b03e0 	mov	x0, x27
	return dev->driver_data;
}

static inline void dev_set_drvdata(struct device *dev, void *data)
{
	dev->driver_data = data;
    25bc:	f9005276 	str	x22, [x19,#160]
    25c0:	a9061fa6 	stp	x6, x7, [x29,#96]
    25c4:	a90717a4 	stp	x4, x5, [x29,#112]
    25c8:	94000000 	bl	0 <kobject_set_name_vargs>
			25c8: R_AARCH64_CALL26	kobject_set_name_vargs
    25cc:	2a0003f4 	mov	w20, w0
	if (retval)
    25d0:	34000360 	cbz	w0, 263c <device_create_groups_vargs+0x118>
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
		kobject_put(&dev->kobj);
    25d4:	aa1b03e0 	mov	x0, x27
    25d8:	94000000 	bl	0 <kobject_put>
			25d8: R_AARCH64_CALL26	kobject_put
    25dc:	93407e80 	sxtw	x0, w20
	return dev;

error:
	put_device(dev);
	return ERR_PTR(retval);
}
    25e0:	a94153f3 	ldp	x19, x20, [sp,#16]
    25e4:	a9425bf5 	ldp	x21, x22, [sp,#32]
    25e8:	a94363f7 	ldp	x23, x24, [sp,#48]
    25ec:	a9446bf9 	ldp	x25, x26, [sp,#64]
    25f0:	f9402bfb 	ldr	x27, [sp,#80]
    25f4:	a8c87bfd 	ldp	x29, x30, [sp],#128
    25f8:	d65f03c0 	ret
    25fc:	92800240 	mov	x0, #0xffffffffffffffed    	// #-19
    2600:	f9402bfb 	ldr	x27, [sp,#80]
    2604:	a94153f3 	ldp	x19, x20, [sp,#16]
    2608:	a9425bf5 	ldp	x21, x22, [sp,#32]
    260c:	a94363f7 	ldp	x23, x24, [sp,#48]
    2610:	a9446bf9 	ldp	x25, x26, [sp,#64]
    2614:	a8c87bfd 	ldp	x29, x30, [sp],#128
    2618:	d65f03c0 	ret
    261c:	92800160 	mov	x0, #0xfffffffffffffff4    	// #-12
    2620:	f9402bfb 	ldr	x27, [sp,#80]
    2624:	a94153f3 	ldp	x19, x20, [sp,#16]
    2628:	a9425bf5 	ldp	x21, x22, [sp,#32]
    262c:	a94363f7 	ldp	x23, x24, [sp,#48]
    2630:	a9446bf9 	ldp	x25, x26, [sp,#64]
    2634:	a8c87bfd 	ldp	x29, x30, [sp],#128
    2638:	d65f03c0 	ret

	retval = kobject_set_name_vargs(&dev->kobj, fmt, args);
	if (retval)
		goto error;

	retval = device_add(dev);
    263c:	aa1303e0 	mov	x0, x19
    2640:	94000000 	bl	1e78 <device_add>
			2640: R_AARCH64_CALL26	device_add
    2644:	2a0003f4 	mov	w20, w0
    2648:	aa1303e0 	mov	x0, x19
	if (retval)
    264c:	35fffc54 	cbnz	w20, 25d4 <device_create_groups_vargs+0xb0>
    2650:	17ffffe4 	b	25e0 <device_create_groups_vargs+0xbc>

0000000000002654 <device_create_vargs>:
 * been created with a call to class_create().
 */
struct device *device_create_vargs(struct class *class, struct device *parent,
				   dev_t devt, void *drvdata, const char *fmt,
				   va_list args)
{
    2654:	aa0503e7 	mov	x7, x5
	return device_create_groups_vargs(class, parent, devt, drvdata, NULL,
    2658:	aa0403e5 	mov	x5, x4
 * been created with a call to class_create().
 */
struct device *device_create_vargs(struct class *class, struct device *parent,
				   dev_t devt, void *drvdata, const char *fmt,
				   va_list args)
{
    265c:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
	return device_create_groups_vargs(class, parent, devt, drvdata, NULL,
    2660:	d2800004 	mov	x4, #0x0                   	// #0
 * been created with a call to class_create().
 */
struct device *device_create_vargs(struct class *class, struct device *parent,
				   dev_t devt, void *drvdata, const char *fmt,
				   va_list args)
{
    2664:	910003fd 	mov	x29, sp
	return device_create_groups_vargs(class, parent, devt, drvdata, NULL,
    2668:	a9402cea 	ldp	x10, x11, [x7]
    266c:	a94124e8 	ldp	x8, x9, [x7,#16]
    2670:	910043a6 	add	x6, x29, #0x10
    2674:	a9012faa 	stp	x10, x11, [x29,#16]
    2678:	a90227a8 	stp	x8, x9, [x29,#32]
    267c:	97ffffaa 	bl	2524 <device_create_groups_vargs>
					  fmt, args);
}
    2680:	a8c37bfd 	ldp	x29, x30, [sp],#48
    2684:	d65f03c0 	ret

0000000000002688 <device_create>:
 * Note: the struct class passed to this function must have previously
 * been created with a call to class_create().
 */
struct device *device_create(struct class *class, struct device *parent,
			     dev_t devt, void *drvdata, const char *fmt, ...)
{
    2688:	a9b77bfd 	stp	x29, x30, [sp,#-144]!
    268c:	910003fd 	mov	x29, sp
	va_list vargs;
	struct device *dev;

	va_start(vargs, fmt);
    2690:	910243a8 	add	x8, x29, #0x90
    2694:	f9001ba8 	str	x8, [x29,#48]
    2698:	f9001fa8 	str	x8, [x29,#56]
    269c:	9101c3a8 	add	x8, x29, #0x70
    26a0:	b9004fbf 	str	wzr, [x29,#76]
    26a4:	f90023a8 	str	x8, [x29,#64]
    26a8:	128002e8 	mov	w8, #0xffffffe8            	// #-24
    26ac:	b9004ba8 	str	w8, [x29,#72]
    26b0:	a9432faa 	ldp	x10, x11, [x29,#48]
    26b4:	a94427a8 	ldp	x8, x9, [x29,#64]
 * Note: the struct class passed to this function must have previously
 * been created with a call to class_create().
 */
struct device *device_create(struct class *class, struct device *parent,
			     dev_t devt, void *drvdata, const char *fmt, ...)
{
    26b8:	f9003fa5 	str	x5, [x29,#120]
 */
struct device *device_create_vargs(struct class *class, struct device *parent,
				   dev_t devt, void *drvdata, const char *fmt,
				   va_list args)
{
	return device_create_groups_vargs(class, parent, devt, drvdata, NULL,
    26bc:	aa0403e5 	mov	x5, x4
 * Note: the struct class passed to this function must have previously
 * been created with a call to class_create().
 */
struct device *device_create(struct class *class, struct device *parent,
			     dev_t devt, void *drvdata, const char *fmt, ...)
{
    26c0:	f90043a6 	str	x6, [x29,#128]
 */
struct device *device_create_vargs(struct class *class, struct device *parent,
				   dev_t devt, void *drvdata, const char *fmt,
				   va_list args)
{
	return device_create_groups_vargs(class, parent, devt, drvdata, NULL,
    26c4:	d2800004 	mov	x4, #0x0                   	// #0
    26c8:	910043a6 	add	x6, x29, #0x10
 * Note: the struct class passed to this function must have previously
 * been created with a call to class_create().
 */
struct device *device_create(struct class *class, struct device *parent,
			     dev_t devt, void *drvdata, const char *fmt, ...)
{
    26cc:	f90047a7 	str	x7, [x29,#136]
    26d0:	a9052faa 	stp	x10, x11, [x29,#80]
    26d4:	a90627a8 	stp	x8, x9, [x29,#96]
 */
struct device *device_create_vargs(struct class *class, struct device *parent,
				   dev_t devt, void *drvdata, const char *fmt,
				   va_list args)
{
	return device_create_groups_vargs(class, parent, devt, drvdata, NULL,
    26d8:	a9012faa 	stp	x10, x11, [x29,#16]
    26dc:	a90227a8 	stp	x8, x9, [x29,#32]
    26e0:	97ffff91 	bl	2524 <device_create_groups_vargs>

	va_start(vargs, fmt);
	dev = device_create_vargs(class, parent, devt, drvdata, fmt, vargs);
	va_end(vargs);
	return dev;
}
    26e4:	a8c97bfd 	ldp	x29, x30, [sp],#144
    26e8:	d65f03c0 	ret

00000000000026ec <device_create_with_groups>:
struct device *device_create_with_groups(struct class *class,
					 struct device *parent, dev_t devt,
					 void *drvdata,
					 const struct attribute_group **groups,
					 const char *fmt, ...)
{
    26ec:	a9ba7bfd 	stp	x29, x30, [sp,#-96]!
    26f0:	910003fd 	mov	x29, sp
	va_list vargs;
	struct device *dev;

	va_start(vargs, fmt);
    26f4:	910183a8 	add	x8, x29, #0x60
    26f8:	f9001ba8 	str	x8, [x29,#48]
    26fc:	f9001fa8 	str	x8, [x29,#56]
    2700:	910143a8 	add	x8, x29, #0x50
    2704:	b9004fbf 	str	wzr, [x29,#76]
    2708:	f90023a8 	str	x8, [x29,#64]
    270c:	128001e8 	mov	w8, #0xfffffff0            	// #-16
    2710:	b9004ba8 	str	w8, [x29,#72]
	dev = device_create_groups_vargs(class, parent, devt, drvdata, groups,
    2714:	a94327a8 	ldp	x8, x9, [x29,#48]
    2718:	a90127a8 	stp	x8, x9, [x29,#16]
    271c:	a94427a8 	ldp	x8, x9, [x29,#64]
struct device *device_create_with_groups(struct class *class,
					 struct device *parent, dev_t devt,
					 void *drvdata,
					 const struct attribute_group **groups,
					 const char *fmt, ...)
{
    2720:	f9002ba6 	str	x6, [x29,#80]
	va_list vargs;
	struct device *dev;

	va_start(vargs, fmt);
	dev = device_create_groups_vargs(class, parent, devt, drvdata, groups,
    2724:	910043a6 	add	x6, x29, #0x10
struct device *device_create_with_groups(struct class *class,
					 struct device *parent, dev_t devt,
					 void *drvdata,
					 const struct attribute_group **groups,
					 const char *fmt, ...)
{
    2728:	f9002fa7 	str	x7, [x29,#88]
	va_list vargs;
	struct device *dev;

	va_start(vargs, fmt);
	dev = device_create_groups_vargs(class, parent, devt, drvdata, groups,
    272c:	a90227a8 	stp	x8, x9, [x29,#32]
    2730:	97ffff7d 	bl	2524 <device_create_groups_vargs>
					 fmt, vargs);
	va_end(vargs);
	return dev;
}
    2734:	a8c67bfd 	ldp	x29, x30, [sp],#96
    2738:	d65f03c0 	ret

000000000000273c <device_get_devnode>:
 * freed by the caller.
 */
const char *device_get_devnode(struct device *dev,
			       umode_t *mode, kuid_t *uid, kgid_t *gid,
			       const char **tmp)
{
    273c:	a9bc7bfd 	stp	x29, x30, [sp,#-64]!
    2740:	910003fd 	mov	x29, sp
    2744:	a90153f3 	stp	x19, x20, [sp,#16]
    2748:	f90013f5 	str	x21, [sp,#32]
    274c:	aa0003f4 	mov	x20, x0
	char *s;

	*tmp = NULL;
    2750:	f900009f 	str	xzr, [x4]
 * freed by the caller.
 */
const char *device_get_devnode(struct device *dev,
			       umode_t *mode, kuid_t *uid, kgid_t *gid,
			       const char **tmp)
{
    2754:	aa0103f5 	mov	x21, x1
	char *s;

	*tmp = NULL;

	/* the device type may provide a specific name */
	if (dev->type && dev->type->devnode)
    2758:	f9402c05 	ldr	x5, [x0,#88]
    275c:	b40001c5 	cbz	x5, 2794 <device_get_devnode+0x58>
    2760:	f9400ca5 	ldr	x5, [x5,#24]
    2764:	b4000185 	cbz	x5, 2794 <device_get_devnode+0x58>
    2768:	f9001fa4 	str	x4, [x29,#56]
		*tmp = dev->type->devnode(dev, mode, uid, gid);
    276c:	d63f00a0 	blr	x5
    2770:	f9401fa4 	ldr	x4, [x29,#56]
    2774:	aa0003f3 	mov	x19, x0
    2778:	f9000080 	str	x0, [x4]
	if (*tmp)
    277c:	b40000c0 	cbz	x0, 2794 <device_get_devnode+0x58>
	s = kstrdup(dev_name(dev), GFP_KERNEL);
	if (!s)
		return NULL;
	strreplace(s, '!', '/');
	return *tmp = s;
}
    2780:	aa1303e0 	mov	x0, x19
    2784:	f94013f5 	ldr	x21, [sp,#32]
    2788:	a94153f3 	ldp	x19, x20, [sp,#16]
    278c:	a8c47bfd 	ldp	x29, x30, [sp],#64
    2790:	d65f03c0 	ret
		*tmp = dev->type->devnode(dev, mode, uid, gid);
	if (*tmp)
		return *tmp;

	/* the class may provide a specific name */
	if (dev->class && dev->class->devnode)
    2794:	f9414e80 	ldr	x0, [x20,#664]
    2798:	b4000160 	cbz	x0, 27c4 <device_get_devnode+0x88>
    279c:	f9401802 	ldr	x2, [x0,#48]
    27a0:	b4000122 	cbz	x2, 27c4 <device_get_devnode+0x88>
		*tmp = dev->class->devnode(dev, mode);
    27a4:	aa1503e1 	mov	x1, x21
    27a8:	aa1403e0 	mov	x0, x20
    27ac:	f9001fa4 	str	x4, [x29,#56]
    27b0:	d63f0040 	blr	x2
	if (*tmp)
    27b4:	aa0003f3 	mov	x19, x0
	if (*tmp)
		return *tmp;

	/* the class may provide a specific name */
	if (dev->class && dev->class->devnode)
		*tmp = dev->class->devnode(dev, mode);
    27b8:	f9401fa4 	ldr	x4, [x29,#56]
    27bc:	f9000080 	str	x0, [x4]
	if (*tmp)
    27c0:	b5fffe00 	cbnz	x0, 2780 <device_get_devnode+0x44>
#include <linux/pm_wakeup.h>

static inline const char *dev_name(const struct device *dev)
{
	/* Use the init name until the kobject becomes available */
	if (dev->init_name)
    27c4:	f9402a93 	ldr	x19, [x20,#80]
    27c8:	b40002b3 	cbz	x19, 281c <device_get_devnode+0xe0>
		return *tmp;

	/* return name without allocation, tmp == NULL */
	if (strchr(dev_name(dev), '!') == NULL)
    27cc:	52800421 	mov	w1, #0x21                  	// #33
    27d0:	aa1303e0 	mov	x0, x19
    27d4:	f9001fa4 	str	x4, [x29,#56]
    27d8:	94000000 	bl	0 <strchr>
			27d8: R_AARCH64_CALL26	strchr
    27dc:	f9401fa4 	ldr	x4, [x29,#56]
    27e0:	b4fffd00 	cbz	x0, 2780 <device_get_devnode+0x44>
		return dev_name(dev);

	/* replace '!' in the name with '/' */
	s = kstrdup(dev_name(dev), GFP_KERNEL);
    27e4:	52801801 	mov	w1, #0xc0                  	// #192
    27e8:	aa1303e0 	mov	x0, x19
    27ec:	72a04801 	movk	w1, #0x240, lsl #16
    27f0:	f9001fa4 	str	x4, [x29,#56]
    27f4:	94000000 	bl	0 <kstrdup>
			27f4: R_AARCH64_CALL26	kstrdup
    27f8:	aa0003f4 	mov	x20, x0
	if (!s)
    27fc:	b4000200 	cbz	x0, 283c <device_get_devnode+0x100>
		return NULL;
	strreplace(s, '!', '/');
    2800:	528005e2 	mov	w2, #0x2f                  	// #47
    2804:	52800421 	mov	w1, #0x21                  	// #33
	return *tmp = s;
    2808:	aa0003f3 	mov	x19, x0

	/* replace '!' in the name with '/' */
	s = kstrdup(dev_name(dev), GFP_KERNEL);
	if (!s)
		return NULL;
	strreplace(s, '!', '/');
    280c:	94000000 	bl	0 <strreplace>
			280c: R_AARCH64_CALL26	strreplace
	return *tmp = s;
    2810:	f9401fa4 	ldr	x4, [x29,#56]
    2814:	f9000094 	str	x20, [x4]
    2818:	17ffffda 	b	2780 <device_get_devnode+0x44>
    281c:	f9400a93 	ldr	x19, [x20,#16]
		*tmp = dev->class->devnode(dev, mode);
	if (*tmp)
		return *tmp;

	/* return name without allocation, tmp == NULL */
	if (strchr(dev_name(dev), '!') == NULL)
    2820:	52800421 	mov	w1, #0x21                  	// #33
    2824:	f9001fa4 	str	x4, [x29,#56]
    2828:	aa1303e0 	mov	x0, x19
    282c:	94000000 	bl	0 <strchr>
			282c: R_AARCH64_CALL26	strchr
    2830:	b4fffa80 	cbz	x0, 2780 <device_get_devnode+0x44>
		return dev->init_name;

	return kobject_name(&dev->kobj);
    2834:	f9401fa4 	ldr	x4, [x29,#56]
    2838:	17ffffeb 	b	27e4 <device_get_devnode+0xa8>
		return dev_name(dev);

	/* replace '!' in the name with '/' */
	s = kstrdup(dev_name(dev), GFP_KERNEL);
	if (!s)
		return NULL;
    283c:	d2800013 	mov	x19, #0x0                   	// #0
    2840:	17ffffd0 	b	2780 <device_get_devnode+0x44>

0000000000002844 <dev_uevent>:
	return NULL;
}

static int dev_uevent(struct kset *kset, struct kobject *kobj,
		      struct kobj_uevent_env *env)
{
    2844:	a9bb7bfd 	stp	x29, x30, [sp,#-80]!
    2848:	910003fd 	mov	x29, sp
    284c:	a90153f3 	stp	x19, x20, [sp,#16]
	bool			offline:1;
};

static inline struct device *kobj_to_dev(struct kobject *kobj)
{
	return container_of(kobj, struct device, kobj);
    2850:	d1004033 	sub	x19, x1, #0x10
    2854:	aa0203f4 	mov	x20, x2
    2858:	a9025bf5 	stp	x21, x22, [sp,#32]
    285c:	aa0103f6 	mov	x22, x1
	struct device *dev = kobj_to_dev(kobj);
	int retval = 0;

	/* add device node properties if present */
	if (MAJOR(dev->devt)) {
    2860:	b9425a62 	ldr	w2, [x19,#600]
    2864:	53147c42 	lsr	w2, w2, #20
    2868:	35000b02 	cbnz	w2, 29c8 <dev_uevent+0x184>
				add_uevent_var(env, "DEVGID=%u", from_kgid(&init_user_ns, gid));
			kfree(tmp);
		}
	}

	if (dev->type && dev->type->name)
    286c:	f9402e60 	ldr	x0, [x19,#88]
    2870:	b40000e0 	cbz	x0, 288c <dev_uevent+0x48>
    2874:	f9400002 	ldr	x2, [x0]
    2878:	b40000a2 	cbz	x2, 288c <dev_uevent+0x48>
		add_uevent_var(env, "DEVTYPE=%s", dev->type->name);
    287c:	90000001 	adrp	x1, 0 <dev_attr_store>
			287c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x3b0
    2880:	aa1403e0 	mov	x0, x20
    2884:	91000021 	add	x1, x1, #0x0
			2884: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x3b0
    2888:	94000000 	bl	0 <add_uevent_var>
			2888: R_AARCH64_CALL26	add_uevent_var

	if (dev->driver)
    288c:	f9404a60 	ldr	x0, [x19,#144]
    2890:	b40000c0 	cbz	x0, 28a8 <dev_uevent+0x64>
		add_uevent_var(env, "DRIVER=%s", dev->driver->name);
    2894:	f9400002 	ldr	x2, [x0]
    2898:	90000001 	adrp	x1, 0 <dev_attr_store>
			2898: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x3c0
    289c:	91000021 	add	x1, x1, #0x0
			289c: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x3c0
    28a0:	aa1403e0 	mov	x0, x20
    28a4:	94000000 	bl	0 <add_uevent_var>
			28a4: R_AARCH64_CALL26	add_uevent_var

	/* Add common DT information about the device */
	of_device_uevent(dev, env);
    28a8:	aa1303e0 	mov	x0, x19
    28ac:	aa1403e1 	mov	x1, x20
    28b0:	94000000 	bl	0 <of_device_uevent>
			28b0: R_AARCH64_CALL26	of_device_uevent

	/* have the bus specific function add its stuff */
	if (dev->bus && dev->bus->uevent) {
    28b4:	f9404660 	ldr	x0, [x19,#136]
    28b8:	b4000100 	cbz	x0, 28d8 <dev_uevent+0x94>
    28bc:	f9402002 	ldr	x2, [x0,#64]
    28c0:	b40000c2 	cbz	x2, 28d8 <dev_uevent+0x94>
		retval = dev->bus->uevent(dev, env);
    28c4:	aa1403e1 	mov	x1, x20
    28c8:	aa1303e0 	mov	x0, x19
    28cc:	d63f0040 	blr	x2
    28d0:	2a0003f5 	mov	w21, w0
		if (retval)
    28d4:	350005a0 	cbnz	w0, 2988 <dev_uevent+0x144>

static int dev_uevent(struct kset *kset, struct kobject *kobj,
		      struct kobj_uevent_env *env)
{
	struct device *dev = kobj_to_dev(kobj);
	int retval = 0;
    28d8:	52800015 	mov	w21, #0x0                   	// #0
			pr_debug("device: '%s': %s: bus uevent() returned %d\n",
				 dev_name(dev), __func__, retval);
	}

	/* have the class specific function add its stuff */
	if (dev->class && dev->class->dev_uevent) {
    28dc:	f9414e60 	ldr	x0, [x19,#664]
    28e0:	b4000100 	cbz	x0, 2900 <dev_uevent+0xbc>
    28e4:	f9401402 	ldr	x2, [x0,#40]
    28e8:	b40000c2 	cbz	x2, 2900 <dev_uevent+0xbc>
		retval = dev->class->dev_uevent(dev, env);
    28ec:	aa1403e1 	mov	x1, x20
    28f0:	aa1303e0 	mov	x0, x19
    28f4:	d63f0040 	blr	x2
    28f8:	2a0003f5 	mov	w21, w0
		if (retval)
    28fc:	35000260 	cbnz	w0, 2948 <dev_uevent+0x104>
				 "returned %d\n", dev_name(dev),
				 __func__, retval);
	}

	/* have the device type specific function add its stuff */
	if (dev->type && dev->type->uevent) {
    2900:	f9402e60 	ldr	x0, [x19,#88]
    2904:	b4000180 	cbz	x0, 2934 <dev_uevent+0xf0>
    2908:	f9400802 	ldr	x2, [x0,#16]
    290c:	b4000142 	cbz	x2, 2934 <dev_uevent+0xf0>
		retval = dev->type->uevent(dev, env);
    2910:	aa1403e1 	mov	x1, x20
    2914:	aa1303e0 	mov	x0, x19
    2918:	d63f0040 	blr	x2
    291c:	2a0003f5 	mov	w21, w0
		if (retval)
    2920:	340000a0 	cbz	w0, 2934 <dev_uevent+0xf0>
			pr_debug("device: '%s': %s: dev_type uevent() "
    2924:	90000000 	adrp	x0, 0 <dev_attr_store>
			2924: R_AARCH64_ADR_PREL_PG_HI21	__verbose
    2928:	91000001 	add	x1, x0, #0x0
			2928: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    292c:	79436421 	ldrh	w1, [x1,#434]
    2930:	37100b01 	tbnz	w1, #2, 2a90 <dev_uevent+0x24c>
				 "returned %d\n", dev_name(dev),
				 __func__, retval);
	}

	return retval;
}
    2934:	2a1503e0 	mov	w0, w21
    2938:	a94153f3 	ldp	x19, x20, [sp,#16]
    293c:	a9425bf5 	ldp	x21, x22, [sp,#32]
    2940:	a8c57bfd 	ldp	x29, x30, [sp],#80
    2944:	d65f03c0 	ret

	/* have the class specific function add its stuff */
	if (dev->class && dev->class->dev_uevent) {
		retval = dev->class->dev_uevent(dev, env);
		if (retval)
			pr_debug("device: '%s': %s: class uevent() "
    2948:	90000000 	adrp	x0, 0 <dev_attr_store>
			2948: R_AARCH64_ADR_PREL_PG_HI21	__verbose
    294c:	91000001 	add	x1, x0, #0x0
			294c: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    2950:	79431421 	ldrh	w1, [x1,#394]
    2954:	3617fd61 	tbz	w1, #2, 2900 <dev_uevent+0xbc>
#include <linux/pm_wakeup.h>

static inline const char *dev_name(const struct device *dev)
{
	/* Use the init name until the kobject becomes available */
	if (dev->init_name)
    2958:	f9402a62 	ldr	x2, [x19,#80]
    295c:	b4000b62 	cbz	x2, 2ac8 <dev_uevent+0x284>
    2960:	90000003 	adrp	x3, 0 <dev_attr_store>
			2960: R_AARCH64_ADR_PREL_PG_HI21	.rodata
    2964:	91000000 	add	x0, x0, #0x0
			2964: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    2968:	91000063 	add	x3, x3, #0x0
			2968: R_AARCH64_ADD_ABS_LO12_NC	.rodata
    296c:	90000001 	adrp	x1, 0 <dev_attr_store>
			296c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x400
    2970:	2a1503e4 	mov	w4, w21
    2974:	91014063 	add	x3, x3, #0x50
    2978:	91000021 	add	x1, x1, #0x0
			2978: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x400
    297c:	9105a000 	add	x0, x0, #0x168
    2980:	94000000 	bl	0 <__dynamic_pr_debug>
			2980: R_AARCH64_CALL26	__dynamic_pr_debug
    2984:	17ffffdf 	b	2900 <dev_uevent+0xbc>

	/* have the bus specific function add its stuff */
	if (dev->bus && dev->bus->uevent) {
		retval = dev->bus->uevent(dev, env);
		if (retval)
			pr_debug("device: '%s': %s: bus uevent() returned %d\n",
    2988:	90000000 	adrp	x0, 0 <dev_attr_store>
			2988: R_AARCH64_ADR_PREL_PG_HI21	__verbose
    298c:	91000001 	add	x1, x0, #0x0
			298c: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    2990:	7942c421 	ldrh	w1, [x1,#354]
    2994:	3617fa41 	tbz	w1, #2, 28dc <dev_uevent+0x98>
    2998:	f9402a62 	ldr	x2, [x19,#80]
    299c:	b40009a2 	cbz	x2, 2ad0 <dev_uevent+0x28c>
    29a0:	90000003 	adrp	x3, 0 <dev_attr_store>
			29a0: R_AARCH64_ADR_PREL_PG_HI21	.rodata
    29a4:	91000000 	add	x0, x0, #0x0
			29a4: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    29a8:	91000063 	add	x3, x3, #0x0
			29a8: R_AARCH64_ADD_ABS_LO12_NC	.rodata
    29ac:	90000001 	adrp	x1, 0 <dev_attr_store>
			29ac: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x3d0
    29b0:	2a1503e4 	mov	w4, w21
    29b4:	91014063 	add	x3, x3, #0x50
    29b8:	91000021 	add	x1, x1, #0x0
			29b8: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x3d0
    29bc:	91050000 	add	x0, x0, #0x140
    29c0:	94000000 	bl	0 <__dynamic_pr_debug>
			29c0: R_AARCH64_CALL26	__dynamic_pr_debug
    29c4:	17ffffc6 	b	28dc <dev_uevent+0x98>
		const char *name;
		umode_t mode = 0;
		kuid_t uid = GLOBAL_ROOT_UID;
		kgid_t gid = GLOBAL_ROOT_GID;

		add_uevent_var(env, "MAJOR=%u", MAJOR(dev->devt));
    29c8:	90000001 	adrp	x1, 0 <dev_attr_store>
			29c8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x350
    29cc:	aa1403e0 	mov	x0, x20
    29d0:	91000021 	add	x1, x1, #0x0
			29d0: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x350

	/* add device node properties if present */
	if (MAJOR(dev->devt)) {
		const char *tmp;
		const char *name;
		umode_t mode = 0;
    29d4:	79006fbf 	strh	wzr, [x29,#54]
		kuid_t uid = GLOBAL_ROOT_UID;
    29d8:	b9003bbf 	str	wzr, [x29,#56]
		kgid_t gid = GLOBAL_ROOT_GID;
    29dc:	b90043bf 	str	wzr, [x29,#64]

		add_uevent_var(env, "MAJOR=%u", MAJOR(dev->devt));
    29e0:	94000000 	bl	0 <add_uevent_var>
			29e0: R_AARCH64_CALL26	add_uevent_var
		add_uevent_var(env, "MINOR=%u", MINOR(dev->devt));
    29e4:	b9425a62 	ldr	w2, [x19,#600]
    29e8:	90000001 	adrp	x1, 0 <dev_attr_store>
			29e8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x360
    29ec:	91000021 	add	x1, x1, #0x0
			29ec: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x360
    29f0:	aa1403e0 	mov	x0, x20
    29f4:	12004c42 	and	w2, w2, #0xfffff
    29f8:	94000000 	bl	0 <add_uevent_var>
			29f8: R_AARCH64_CALL26	add_uevent_var
		name = device_get_devnode(dev, &mode, &uid, &gid, &tmp);
    29fc:	910123a4 	add	x4, x29, #0x48
    2a00:	910103a3 	add	x3, x29, #0x40
    2a04:	9100e3a2 	add	x2, x29, #0x38
    2a08:	9100dba1 	add	x1, x29, #0x36
    2a0c:	aa1303e0 	mov	x0, x19
    2a10:	94000000 	bl	273c <device_get_devnode>
			2a10: R_AARCH64_CALL26	device_get_devnode
		if (name) {
    2a14:	b4fff2c0 	cbz	x0, 286c <dev_uevent+0x28>
			add_uevent_var(env, "DEVNAME=%s", name);
    2a18:	90000001 	adrp	x1, 0 <dev_attr_store>
			2a18: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x370
    2a1c:	aa0003e2 	mov	x2, x0
    2a20:	91000021 	add	x1, x1, #0x0
			2a20: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x370
    2a24:	aa1403e0 	mov	x0, x20
    2a28:	94000000 	bl	0 <add_uevent_var>
			2a28: R_AARCH64_CALL26	add_uevent_var
			if (mode)
    2a2c:	79406fa2 	ldrh	w2, [x29,#54]
    2a30:	35000242 	cbnz	w2, 2a78 <dev_uevent+0x234>
    2a34:	b9403ba2 	ldr	w2, [x29,#56]
				add_uevent_var(env, "DEVMODE=%#o", mode & 0777);
			if (!uid_eq(uid, GLOBAL_ROOT_UID))
    2a38:	35000162 	cbnz	w2, 2a64 <dev_uevent+0x220>
    2a3c:	b94043a2 	ldr	w2, [x29,#64]
				add_uevent_var(env, "DEVUID=%u", from_kuid(&init_user_ns, uid));
			if (!gid_eq(gid, GLOBAL_ROOT_GID))
    2a40:	35000082 	cbnz	w2, 2a50 <dev_uevent+0x20c>
				add_uevent_var(env, "DEVGID=%u", from_kgid(&init_user_ns, gid));
			kfree(tmp);
    2a44:	f94027a0 	ldr	x0, [x29,#72]
    2a48:	94000000 	bl	0 <kfree>
			2a48: R_AARCH64_CALL26	kfree
    2a4c:	17ffff88 	b	286c <dev_uevent+0x28>
			if (mode)
				add_uevent_var(env, "DEVMODE=%#o", mode & 0777);
			if (!uid_eq(uid, GLOBAL_ROOT_UID))
				add_uevent_var(env, "DEVUID=%u", from_kuid(&init_user_ns, uid));
			if (!gid_eq(gid, GLOBAL_ROOT_GID))
				add_uevent_var(env, "DEVGID=%u", from_kgid(&init_user_ns, gid));
    2a50:	90000001 	adrp	x1, 0 <dev_attr_store>
			2a50: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x3a0
    2a54:	aa1403e0 	mov	x0, x20
    2a58:	91000021 	add	x1, x1, #0x0
			2a58: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x3a0
    2a5c:	94000000 	bl	0 <add_uevent_var>
			2a5c: R_AARCH64_CALL26	add_uevent_var
    2a60:	17fffff9 	b	2a44 <dev_uevent+0x200>
		if (name) {
			add_uevent_var(env, "DEVNAME=%s", name);
			if (mode)
				add_uevent_var(env, "DEVMODE=%#o", mode & 0777);
			if (!uid_eq(uid, GLOBAL_ROOT_UID))
				add_uevent_var(env, "DEVUID=%u", from_kuid(&init_user_ns, uid));
    2a64:	90000001 	adrp	x1, 0 <dev_attr_store>
			2a64: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x390
    2a68:	aa1403e0 	mov	x0, x20
    2a6c:	91000021 	add	x1, x1, #0x0
			2a6c: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x390
    2a70:	94000000 	bl	0 <add_uevent_var>
			2a70: R_AARCH64_CALL26	add_uevent_var
    2a74:	17fffff2 	b	2a3c <dev_uevent+0x1f8>
		add_uevent_var(env, "MINOR=%u", MINOR(dev->devt));
		name = device_get_devnode(dev, &mode, &uid, &gid, &tmp);
		if (name) {
			add_uevent_var(env, "DEVNAME=%s", name);
			if (mode)
				add_uevent_var(env, "DEVMODE=%#o", mode & 0777);
    2a78:	90000001 	adrp	x1, 0 <dev_attr_store>
			2a78: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x380
    2a7c:	12002042 	and	w2, w2, #0x1ff
    2a80:	91000021 	add	x1, x1, #0x0
			2a80: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x380
    2a84:	aa1403e0 	mov	x0, x20
    2a88:	94000000 	bl	0 <add_uevent_var>
			2a88: R_AARCH64_CALL26	add_uevent_var
    2a8c:	17ffffea 	b	2a34 <dev_uevent+0x1f0>
    2a90:	f9402a62 	ldr	x2, [x19,#80]
    2a94:	b4000162 	cbz	x2, 2ac0 <dev_uevent+0x27c>

	/* have the device type specific function add its stuff */
	if (dev->type && dev->type->uevent) {
		retval = dev->type->uevent(dev, env);
		if (retval)
			pr_debug("device: '%s': %s: dev_type uevent() "
    2a98:	90000003 	adrp	x3, 0 <dev_attr_store>
			2a98: R_AARCH64_ADR_PREL_PG_HI21	.rodata
    2a9c:	91000000 	add	x0, x0, #0x0
			2a9c: R_AARCH64_ADD_ABS_LO12_NC	__verbose
    2aa0:	91000063 	add	x3, x3, #0x0
			2aa0: R_AARCH64_ADD_ABS_LO12_NC	.rodata
    2aa4:	90000001 	adrp	x1, 0 <dev_attr_store>
			2aa4: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x430
    2aa8:	2a1503e4 	mov	w4, w21
    2aac:	91014063 	add	x3, x3, #0x50
    2ab0:	91000021 	add	x1, x1, #0x0
			2ab0: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x430
    2ab4:	91064000 	add	x0, x0, #0x190
    2ab8:	94000000 	bl	0 <__dynamic_pr_debug>
			2ab8: R_AARCH64_CALL26	__dynamic_pr_debug
    2abc:	17ffff9e 	b	2934 <dev_uevent+0xf0>
    2ac0:	f94002c2 	ldr	x2, [x22]
    2ac4:	17fffff5 	b	2a98 <dev_uevent+0x254>
    2ac8:	f94002c2 	ldr	x2, [x22]
    2acc:	17ffffa5 	b	2960 <dev_uevent+0x11c>
    2ad0:	f94002c2 	ldr	x2, [x22]
    2ad4:	17ffffb3 	b	29a0 <dev_uevent+0x15c>

0000000000002ad8 <device_offline>:
 * is executed.
 *
 * Call under device_hotplug_lock.
 */
int device_offline(struct device *dev)
{
    2ad8:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
    2adc:	910003fd 	mov	x29, sp
    2ae0:	a90153f3 	stp	x19, x20, [sp,#16]
    2ae4:	f90013f5 	str	x21, [sp,#32]
	int ret;

	if (dev->offline_disabled)
    2ae8:	394ae002 	ldrb	w2, [x0,#696]
    2aec:	37000542 	tbnz	w2, #0, 2b94 <device_offline+0xbc>
		return -EPERM;

	ret = device_for_each_child(dev, NULL, device_check_offline);
    2af0:	90000002 	adrp	x2, 0 <dev_attr_store>
			2af0: R_AARCH64_ADR_PREL_PG_HI21	.text+0x1024
    2af4:	d2800001 	mov	x1, #0x0                   	// #0
    2af8:	91000042 	add	x2, x2, #0x0
			2af8: R_AARCH64_ADD_ABS_LO12_NC	.text+0x1024
    2afc:	aa0003f4 	mov	x20, x0
    2b00:	94000000 	bl	8e0 <device_for_each_child>
			2b00: R_AARCH64_CALL26	device_for_each_child
    2b04:	2a0003f3 	mov	w19, w0
	if (ret)
    2b08:	340000b3 	cbz	w19, 2b1c <device_offline+0x44>
		}
	}
	device_unlock(dev);

	return ret;
}
    2b0c:	a94153f3 	ldp	x19, x20, [sp,#16]
    2b10:	f94013f5 	ldr	x21, [sp,#32]
    2b14:	a8c37bfd 	ldp	x29, x30, [sp],#48
    2b18:	d65f03c0 	ret
#endif
}

static inline void device_lock(struct device *dev)
{
	mutex_lock(&dev->mutex);
    2b1c:	91018295 	add	x21, x20, #0x60
    2b20:	aa1503e0 	mov	x0, x21
    2b24:	94000000 	bl	0 <mutex_lock>
			2b24: R_AARCH64_CALL26	mutex_lock
    2b28:	f9404681 	ldr	x1, [x20,#136]
				      umode_t *mode, kuid_t *uid, kgid_t *gid,
				      const char **tmp);

static inline bool device_supports_offline(struct device *dev)
{
	return dev->bus && dev->bus->offline && dev->bus->online;
    2b2c:	b4000101 	cbz	x1, 2b4c <device_offline+0x74>
    2b30:	f9403422 	ldr	x2, [x1,#104]
    2b34:	b40000c2 	cbz	x2, 2b4c <device_offline+0x74>
    2b38:	f9403020 	ldr	x0, [x1,#96]
    2b3c:	b4000080 	cbz	x0, 2b4c <device_offline+0x74>
	if (ret)
		return ret;

	device_lock(dev);
	if (device_supports_offline(dev)) {
		if (dev->offline) {
    2b40:	394ae280 	ldrb	w0, [x20,#696]
			ret = 1;
    2b44:	52800033 	mov	w19, #0x1                   	// #1
	if (ret)
		return ret;

	device_lock(dev);
	if (device_supports_offline(dev)) {
		if (dev->offline) {
    2b48:	36080100 	tbz	w0, #1, 2b68 <device_offline+0x90>
	return mutex_trylock(&dev->mutex);
}

static inline void device_unlock(struct device *dev)
{
	mutex_unlock(&dev->mutex);
    2b4c:	aa1503e0 	mov	x0, x21
    2b50:	94000000 	bl	0 <mutex_unlock>
			2b50: R_AARCH64_CALL26	mutex_unlock
		}
	}
	device_unlock(dev);

	return ret;
}
    2b54:	f94013f5 	ldr	x21, [sp,#32]
			}
		}
	}
	device_unlock(dev);

	return ret;
    2b58:	2a1303e0 	mov	w0, w19
}
    2b5c:	a94153f3 	ldp	x19, x20, [sp,#16]
    2b60:	a8c37bfd 	ldp	x29, x30, [sp],#48
    2b64:	d65f03c0 	ret
	device_lock(dev);
	if (device_supports_offline(dev)) {
		if (dev->offline) {
			ret = 1;
		} else {
			ret = dev->bus->offline(dev);
    2b68:	aa1403e0 	mov	x0, x20
    2b6c:	d63f0040 	blr	x2
    2b70:	2a0003f3 	mov	w19, w0
			if (!ret) {
    2b74:	35fffec0 	cbnz	w0, 2b4c <device_offline+0x74>
				kobject_uevent(&dev->kobj, KOBJ_OFFLINE);
    2b78:	528000a1 	mov	w1, #0x5                   	// #5
    2b7c:	91004280 	add	x0, x20, #0x10
    2b80:	94000000 	bl	0 <kobject_uevent>
			2b80: R_AARCH64_CALL26	kobject_uevent
				dev->offline = true;
    2b84:	394ae280 	ldrb	w0, [x20,#696]
    2b88:	321f0000 	orr	w0, w0, #0x2
    2b8c:	390ae280 	strb	w0, [x20,#696]
    2b90:	17ffffef 	b	2b4c <device_offline+0x74>
int device_offline(struct device *dev)
{
	int ret;

	if (dev->offline_disabled)
		return -EPERM;
    2b94:	12800000 	mov	w0, #0xffffffff            	// #-1
    2b98:	17ffffdd 	b	2b0c <device_offline+0x34>

0000000000002b9c <device_online>:
 * to indicate that the device can be used again.
 *
 * Call under device_hotplug_lock.
 */
int device_online(struct device *dev)
{
    2b9c:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
    2ba0:	910003fd 	mov	x29, sp
    2ba4:	a90153f3 	stp	x19, x20, [sp,#16]
#endif
}

static inline void device_lock(struct device *dev)
{
	mutex_lock(&dev->mutex);
    2ba8:	91018014 	add	x20, x0, #0x60
    2bac:	aa0003f3 	mov	x19, x0
    2bb0:	aa1403e0 	mov	x0, x20
    2bb4:	f90013f5 	str	x21, [sp,#32]
    2bb8:	94000000 	bl	0 <mutex_lock>
			2bb8: R_AARCH64_CALL26	mutex_lock
    2bbc:	f9404661 	ldr	x1, [x19,#136]
				      umode_t *mode, kuid_t *uid, kgid_t *gid,
				      const char **tmp);

static inline bool device_supports_offline(struct device *dev)
{
	return dev->bus && dev->bus->offline && dev->bus->online;
    2bc0:	b4000341 	cbz	x1, 2c28 <device_online+0x8c>
    2bc4:	f9403420 	ldr	x0, [x1,#104]
    2bc8:	b4000300 	cbz	x0, 2c28 <device_online+0x8c>
    2bcc:	f9403021 	ldr	x1, [x1,#96]
    2bd0:	b40002c1 	cbz	x1, 2c28 <device_online+0x8c>
	int ret = 0;

	device_lock(dev);
	if (device_supports_offline(dev)) {
		if (dev->offline) {
    2bd4:	394ae260 	ldrb	w0, [x19,#696]
    2bd8:	37080120 	tbnz	w0, #1, 2bfc <device_online+0x60>
			if (!ret) {
				kobject_uevent(&dev->kobj, KOBJ_ONLINE);
				dev->offline = false;
			}
		} else {
			ret = 1;
    2bdc:	52800035 	mov	w21, #0x1                   	// #1
	return mutex_trylock(&dev->mutex);
}

static inline void device_unlock(struct device *dev)
{
	mutex_unlock(&dev->mutex);
    2be0:	aa1403e0 	mov	x0, x20
    2be4:	94000000 	bl	0 <mutex_unlock>
			2be4: R_AARCH64_CALL26	mutex_unlock
		}
	}
	device_unlock(dev);

	return ret;
}
    2be8:	2a1503e0 	mov	w0, w21
    2bec:	f94013f5 	ldr	x21, [sp,#32]
    2bf0:	a94153f3 	ldp	x19, x20, [sp,#16]
    2bf4:	a8c37bfd 	ldp	x29, x30, [sp],#48
    2bf8:	d65f03c0 	ret
	int ret = 0;

	device_lock(dev);
	if (device_supports_offline(dev)) {
		if (dev->offline) {
			ret = dev->bus->online(dev);
    2bfc:	aa1303e0 	mov	x0, x19
    2c00:	d63f0020 	blr	x1
    2c04:	2a0003f5 	mov	w21, w0
			if (!ret) {
    2c08:	35fffec0 	cbnz	w0, 2be0 <device_online+0x44>
				kobject_uevent(&dev->kobj, KOBJ_ONLINE);
    2c0c:	52800081 	mov	w1, #0x4                   	// #4
    2c10:	91004260 	add	x0, x19, #0x10
    2c14:	94000000 	bl	0 <kobject_uevent>
			2c14: R_AARCH64_CALL26	kobject_uevent
				dev->offline = false;
    2c18:	394ae260 	ldrb	w0, [x19,#696]
    2c1c:	121e7800 	and	w0, w0, #0xfffffffd
    2c20:	390ae260 	strb	w0, [x19,#696]
    2c24:	17ffffef 	b	2be0 <device_online+0x44>
    2c28:	aa1403e0 	mov	x0, x20
 *
 * Call under device_hotplug_lock.
 */
int device_online(struct device *dev)
{
	int ret = 0;
    2c2c:	52800015 	mov	w21, #0x0                   	// #0
    2c30:	94000000 	bl	0 <mutex_unlock>
			2c30: R_AARCH64_CALL26	mutex_unlock
		}
	}
	device_unlock(dev);

	return ret;
}
    2c34:	2a1503e0 	mov	w0, w21
    2c38:	f94013f5 	ldr	x21, [sp,#32]
    2c3c:	a94153f3 	ldp	x19, x20, [sp,#16]
    2c40:	a8c37bfd 	ldp	x29, x30, [sp],#48
    2c44:	d65f03c0 	ret

0000000000002c48 <online_store>:
	return sprintf(buf, "%u\n", val);
}

static ssize_t online_store(struct device *dev, struct device_attribute *attr,
			    const char *buf, size_t count)
{
    2c48:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
    2c4c:	910003fd 	mov	x29, sp
    2c50:	a90153f3 	stp	x19, x20, [sp,#16]
	bool val;
	int ret;

	ret = strtobool(buf, &val);
    2c54:	9100bfa1 	add	x1, x29, #0x2f
	return sprintf(buf, "%u\n", val);
}

static ssize_t online_store(struct device *dev, struct device_attribute *attr,
			    const char *buf, size_t count)
{
    2c58:	aa0003f4 	mov	x20, x0
	bool val;
	int ret;

	ret = strtobool(buf, &val);
    2c5c:	aa0203e0 	mov	x0, x2
	return sprintf(buf, "%u\n", val);
}

static ssize_t online_store(struct device *dev, struct device_attribute *attr,
			    const char *buf, size_t count)
{
    2c60:	aa0303f3 	mov	x19, x3
	bool val;
	int ret;

	ret = strtobool(buf, &val);
    2c64:	94000000 	bl	0 <strtobool>
			2c64: R_AARCH64_CALL26	strtobool
	if (ret < 0)
    2c68:	37f80240 	tbnz	w0, #31, 2cb0 <online_store+0x68>
		return ret;

	ret = lock_device_hotplug_sysfs();
    2c6c:	94000000 	bl	1710 <lock_device_hotplug_sysfs>
			2c6c: R_AARCH64_CALL26	lock_device_hotplug_sysfs
	if (ret)
    2c70:	35000200 	cbnz	w0, 2cb0 <online_store+0x68>
		return ret;

	ret = val ? device_online(dev) : device_offline(dev);
    2c74:	3940bfa0 	ldrb	w0, [x29,#47]
    2c78:	35000240 	cbnz	w0, 2cc0 <online_store+0x78>
    2c7c:	aa1403e0 	mov	x0, x20
    2c80:	94000000 	bl	2ad8 <device_offline>
			2c80: R_AARCH64_CALL26	device_offline
    2c84:	2a0003f4 	mov	w20, w0
	mutex_lock(&device_hotplug_lock);
}

void unlock_device_hotplug(void)
{
	mutex_unlock(&device_hotplug_lock);
    2c88:	90000002 	adrp	x2, 0 <dev_attr_store>
			2c88: R_AARCH64_ADR_PREL_PG_HI21	.data
    2c8c:	91000040 	add	x0, x2, #0x0
			2c8c: R_AARCH64_ADD_ABS_LO12_NC	.data
    2c90:	9102c000 	add	x0, x0, #0xb0
    2c94:	94000000 	bl	0 <mutex_unlock>
			2c94: R_AARCH64_CALL26	mutex_unlock
	if (ret)
		return ret;

	ret = val ? device_online(dev) : device_offline(dev);
	unlock_device_hotplug();
	return ret < 0 ? ret : count;
    2c98:	93407e81 	sxtw	x1, w20
    2c9c:	6b1f029f 	cmp	w20, wzr
    2ca0:	9a93b020 	csel	x0, x1, x19, lt
}
    2ca4:	a94153f3 	ldp	x19, x20, [sp,#16]
    2ca8:	a8c37bfd 	ldp	x29, x30, [sp],#48
    2cac:	d65f03c0 	ret
	if (ret < 0)
		return ret;

	ret = lock_device_hotplug_sysfs();
	if (ret)
		return ret;
    2cb0:	93407c00 	sxtw	x0, w0

	ret = val ? device_online(dev) : device_offline(dev);
	unlock_device_hotplug();
	return ret < 0 ? ret : count;
}
    2cb4:	a94153f3 	ldp	x19, x20, [sp,#16]
    2cb8:	a8c37bfd 	ldp	x29, x30, [sp],#48
    2cbc:	d65f03c0 	ret

	ret = lock_device_hotplug_sysfs();
	if (ret)
		return ret;

	ret = val ? device_online(dev) : device_offline(dev);
    2cc0:	aa1403e0 	mov	x0, x20
    2cc4:	94000000 	bl	2b9c <device_online>
			2cc4: R_AARCH64_CALL26	device_online
    2cc8:	2a0003f4 	mov	w20, w0
    2ccc:	17ffffef 	b	2c88 <online_store+0x40>

0000000000002cd0 <device_shutdown>:

/**
 * device_shutdown - call ->shutdown() on each device to shutdown.
 */
void device_shutdown(void)
{
    2cd0:	a9bb7bfd 	stp	x29, x30, [sp,#-80]!
    2cd4:	910003fd 	mov	x29, sp
    2cd8:	a9025bf5 	stp	x21, x22, [sp,#32]
	struct device *dev, *parent;

	spin_lock(&devices_kset->list_lock);
    2cdc:	90000016 	adrp	x22, 0 <dev_attr_store>
			2cdc: R_AARCH64_ADR_PREL_PG_HI21	.bss

/**
 * device_shutdown - call ->shutdown() on each device to shutdown.
 */
void device_shutdown(void)
{
    2ce0:	f90023f9 	str	x25, [sp,#64]
    2ce4:	a90153f3 	stp	x19, x20, [sp,#16]
    2ce8:	a90363f7 	stp	x23, x24, [sp,#48]
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    2cec:	f94002c0 	ldr	x0, [x22]
			2cec: R_AARCH64_LDST64_ABS_LO12_NC	.bss
    2cf0:	91004000 	add	x0, x0, #0x10
    2cf4:	94000000 	bl	0 <_raw_spin_lock>
			2cf4: R_AARCH64_CALL26	_raw_spin_lock
	/*
	 * Walk the devices list backward, shutting down each in turn.
	 * Beware that device unplug events may also start pulling
	 * devices offline, even as the system is shutting down.
	 */
	while (!list_empty(&devices_kset->list)) {
    2cf8:	f94002c0 	ldr	x0, [x22]
			2cf8: R_AARCH64_LDST64_ABS_LO12_NC	.bss
})

static __always_inline
void __read_once_size(const volatile void *p, void *res, int size)
{
	__READ_ONCE_SIZE;
    2cfc:	f9400001 	ldr	x1, [x0]
    2d00:	eb01001f 	cmp	x0, x1
    2d04:	540007e0 	b.eq	2e00 <device_shutdown+0x130>
		if (dev->bus && dev->bus->shutdown) {
			if (initcall_debug)
				dev_info(dev, "shutdown\n");
			dev->bus->shutdown(dev);
		} else if (dev->driver && dev->driver->shutdown) {
			if (initcall_debug)
    2d08:	90000018 	adrp	x24, 0 <initcall_debug>
			2d08: R_AARCH64_ADR_PREL_PG_HI21	initcall_debug
				dev_info(dev, "shutdown\n");
    2d0c:	90000019 	adrp	x25, 0 <dev_attr_store>
			2d0c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x480
		if (dev->bus && dev->bus->shutdown) {
			if (initcall_debug)
				dev_info(dev, "shutdown\n");
			dev->bus->shutdown(dev);
		} else if (dev->driver && dev->driver->shutdown) {
			if (initcall_debug)
    2d10:	91000318 	add	x24, x24, #0x0
			2d10: R_AARCH64_ADD_ABS_LO12_NC	initcall_debug
				dev_info(dev, "shutdown\n");
    2d14:	91000339 	add	x25, x25, #0x0
			2d14: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x480
	 * Walk the devices list backward, shutting down each in turn.
	 * Beware that device unplug events may also start pulling
	 * devices offline, even as the system is shutting down.
	 */
	while (!list_empty(&devices_kset->list)) {
		dev = list_entry(devices_kset->list.prev, struct device,
    2d18:	f9400413 	ldr	x19, [x0,#8]
    2d1c:	d1006274 	sub	x20, x19, #0x18
		/*
		 * hold reference count of device's parent to
		 * prevent it from being freed because parent's
		 * lock is to be held
		 */
		parent = get_device(dev->parent);
    2d20:	f85e8275 	ldr	x21, [x19,#-24]
 * we do take care to provide for the case that we get a NULL
 * pointer passed in.
 */
struct device *get_device(struct device *dev)
{
	return dev ? kobj_to_dev(kobject_get(&dev->kobj)) : NULL;
    2d24:	b4000095 	cbz	x21, 2d34 <device_shutdown+0x64>
    2d28:	910042a0 	add	x0, x21, #0x10
    2d2c:	94000000 	bl	0 <kobject_get>
			2d2c: R_AARCH64_CALL26	kobject_get
	bool			offline:1;
};

static inline struct device *kobj_to_dev(struct kobject *kobj)
{
	return container_of(kobj, struct device, kobj);
    2d30:	d1004015 	sub	x21, x0, #0x10
    2d34:	b4000074 	cbz	x20, 2d40 <device_shutdown+0x70>
    2d38:	91004280 	add	x0, x20, #0x10
    2d3c:	94000000 	bl	0 <kobject_get>
			2d3c: R_AARCH64_CALL26	kobject_get
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2d40:	f9400262 	ldr	x2, [x19]
    2d44:	f9400660 	ldr	x0, [x19,#8]
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    2d48:	f9000440 	str	x0, [x2,#8]
{
	switch (size) {
	case 1: *(volatile __u8 *)p = *(__u8 *)res; break;
	case 2: *(volatile __u16 *)p = *(__u16 *)res; break;
	case 4: *(volatile __u32 *)p = *(__u32 *)res; break;
	case 8: *(volatile __u64 *)p = *(__u64 *)res; break;
    2d4c:	f9000002 	str	x2, [x0]
    2d50:	f9000273 	str	x19, [x19]
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	WRITE_ONCE(list->next, list);
	list->prev = list;
    2d54:	f9000673 	str	x19, [x19,#8]
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static __always_inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    2d58:	f94002c0 	ldr	x0, [x22]
			2d58: R_AARCH64_LDST64_ABS_LO12_NC	.bss
    2d5c:	91004000 	add	x0, x0, #0x10
    2d60:	94000000 	bl	0 <_raw_spin_unlock>
			2d60: R_AARCH64_CALL26	_raw_spin_unlock
		 */
		list_del_init(&dev->kobj.entry);
		spin_unlock(&devices_kset->list_lock);

		/* hold lock to avoid race with probe/release */
		if (parent)
    2d64:	b4000075 	cbz	x21, 2d70 <device_shutdown+0xa0>
#endif
}

static inline void device_lock(struct device *dev)
{
	mutex_lock(&dev->mutex);
    2d68:	910182a0 	add	x0, x21, #0x60
    2d6c:	94000000 	bl	0 <mutex_lock>
			2d6c: R_AARCH64_CALL26	mutex_lock
    2d70:	91012277 	add	x23, x19, #0x48
    2d74:	aa1703e0 	mov	x0, x23
    2d78:	94000000 	bl	0 <mutex_lock>
			2d78: R_AARCH64_CALL26	mutex_lock
	ATOMIC_OPS(__VA_ARGS__)						\
	ATOMIC_OP_RETURN(_relaxed,        ,  ,  ,         , __VA_ARGS__)\
	ATOMIC_OP_RETURN(_acquire,        , a,  , "memory", __VA_ARGS__)\
	ATOMIC_OP_RETURN(_release,        ,  , l, "memory", __VA_ARGS__)

ATOMIC_OPS_RLX(add, add)
    2d7c:	91056262 	add	x2, x19, #0x158
    2d80:	f9800051 	prfm	pstl1strm, [x2]
    2d84:	885f7c40 	ldxr	w0, [x2]
    2d88:	11000400 	add	w0, w0, #0x1
    2d8c:	88017c40 	stxr	w1, w0, [x2]
    2d90:	35ffffa1 	cbnz	w1, 2d84 <device_shutdown+0xb4>
			device_lock(parent);
		device_lock(dev);

		/* Don't allow any more runtime suspends */
		pm_runtime_get_noresume(dev);
		pm_runtime_barrier(dev);
    2d94:	aa1403e0 	mov	x0, x20
    2d98:	94000000 	bl	0 <pm_runtime_barrier>
			2d98: R_AARCH64_CALL26	pm_runtime_barrier

		if (dev->bus && dev->bus->shutdown) {
    2d9c:	f9404680 	ldr	x0, [x20,#136]
    2da0:	b4000480 	cbz	x0, 2e30 <device_shutdown+0x160>
    2da4:	f9402c01 	ldr	x1, [x0,#88]
    2da8:	b4000441 	cbz	x1, 2e30 <device_shutdown+0x160>
			if (initcall_debug)
    2dac:	39400300 	ldrb	w0, [x24]
    2db0:	35000580 	cbnz	w0, 2e60 <device_shutdown+0x190>
				dev_info(dev, "shutdown\n");
			dev->bus->shutdown(dev);
		} else if (dev->driver && dev->driver->shutdown) {
			if (initcall_debug)
				dev_info(dev, "shutdown\n");
			dev->driver->shutdown(dev);
    2db4:	aa1403e0 	mov	x0, x20
    2db8:	d63f0020 	blr	x1
	return mutex_trylock(&dev->mutex);
}

static inline void device_unlock(struct device *dev)
{
	mutex_unlock(&dev->mutex);
    2dbc:	aa1703e0 	mov	x0, x23
    2dc0:	94000000 	bl	0 <mutex_unlock>
			2dc0: R_AARCH64_CALL26	mutex_unlock
		}

		device_unlock(dev);
		if (parent)
    2dc4:	b40002f5 	cbz	x21, 2e20 <device_shutdown+0x150>
    2dc8:	910182a0 	add	x0, x21, #0x60
    2dcc:	94000000 	bl	0 <mutex_unlock>
			2dcc: R_AARCH64_CALL26	mutex_unlock
 * @dev: device in question.
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
    2dd0:	b4000074 	cbz	x20, 2ddc <device_shutdown+0x10c>
		kobject_put(&dev->kobj);
    2dd4:	91004280 	add	x0, x20, #0x10
    2dd8:	94000000 	bl	0 <kobject_put>
			2dd8: R_AARCH64_CALL26	kobject_put
    2ddc:	910042a0 	add	x0, x21, #0x10
    2de0:	94000000 	bl	0 <kobject_put>
			2de0: R_AARCH64_CALL26	kobject_put
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    2de4:	f94002c0 	ldr	x0, [x22]
			2de4: R_AARCH64_LDST64_ABS_LO12_NC	.bss
    2de8:	91004000 	add	x0, x0, #0x10
    2dec:	94000000 	bl	0 <_raw_spin_lock>
			2dec: R_AARCH64_CALL26	_raw_spin_lock
	/*
	 * Walk the devices list backward, shutting down each in turn.
	 * Beware that device unplug events may also start pulling
	 * devices offline, even as the system is shutting down.
	 */
	while (!list_empty(&devices_kset->list)) {
    2df0:	f94002c0 	ldr	x0, [x22]
			2df0: R_AARCH64_LDST64_ABS_LO12_NC	.bss
})

static __always_inline
void __read_once_size(const volatile void *p, void *res, int size)
{
	__READ_ONCE_SIZE;
    2df4:	f9400001 	ldr	x1, [x0]
    2df8:	eb01001f 	cmp	x0, x1
    2dfc:	54fff8e1 	b.ne	2d18 <device_shutdown+0x48>
	raw_spin_lock_irqsave_nested(spinlock_check(lock), flags, subclass); \
} while (0)

static __always_inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
    2e00:	91004000 	add	x0, x0, #0x10
    2e04:	94000000 	bl	0 <_raw_spin_unlock>
			2e04: R_AARCH64_CALL26	_raw_spin_unlock
		put_device(parent);

		spin_lock(&devices_kset->list_lock);
	}
	spin_unlock(&devices_kset->list_lock);
}
    2e08:	f94023f9 	ldr	x25, [sp,#64]
    2e0c:	a94153f3 	ldp	x19, x20, [sp,#16]
    2e10:	a9425bf5 	ldp	x21, x22, [sp,#32]
    2e14:	a94363f7 	ldp	x23, x24, [sp,#48]
    2e18:	a8c57bfd 	ldp	x29, x30, [sp],#80
    2e1c:	d65f03c0 	ret
 * @dev: device in question.
 */
void put_device(struct device *dev)
{
	/* might_sleep(); */
	if (dev)
    2e20:	b4fffe34 	cbz	x20, 2de4 <device_shutdown+0x114>
		kobject_put(&dev->kobj);
    2e24:	91004280 	add	x0, x20, #0x10
    2e28:	94000000 	bl	0 <kobject_put>
			2e28: R_AARCH64_CALL26	kobject_put
    2e2c:	17ffffee 	b	2de4 <device_shutdown+0x114>

		if (dev->bus && dev->bus->shutdown) {
			if (initcall_debug)
				dev_info(dev, "shutdown\n");
			dev->bus->shutdown(dev);
		} else if (dev->driver && dev->driver->shutdown) {
    2e30:	f9404a80 	ldr	x0, [x20,#144]
    2e34:	b4fffc40 	cbz	x0, 2dbc <device_shutdown+0xec>
    2e38:	f9402401 	ldr	x1, [x0,#72]
    2e3c:	b4fffc01 	cbz	x1, 2dbc <device_shutdown+0xec>
			if (initcall_debug)
    2e40:	39400300 	ldrb	w0, [x24]
    2e44:	34fffb80 	cbz	w0, 2db4 <device_shutdown+0xe4>
				dev_info(dev, "shutdown\n");
    2e48:	aa1903e1 	mov	x1, x25
    2e4c:	aa1403e0 	mov	x0, x20
    2e50:	94000000 	bl	1668 <_dev_info>
			2e50: R_AARCH64_CALL26	_dev_info
    2e54:	f9404a80 	ldr	x0, [x20,#144]
    2e58:	f9402401 	ldr	x1, [x0,#72]
    2e5c:	17ffffd6 	b	2db4 <device_shutdown+0xe4>
		pm_runtime_get_noresume(dev);
		pm_runtime_barrier(dev);

		if (dev->bus && dev->bus->shutdown) {
			if (initcall_debug)
				dev_info(dev, "shutdown\n");
    2e60:	aa1903e1 	mov	x1, x25
    2e64:	aa1403e0 	mov	x0, x20
    2e68:	94000000 	bl	1668 <_dev_info>
			2e68: R_AARCH64_CALL26	_dev_info
    2e6c:	f9404680 	ldr	x0, [x20,#136]
    2e70:	f9402c01 	ldr	x1, [x0,#88]
    2e74:	17ffffd0 	b	2db4 <device_shutdown+0xe4>

0000000000002e78 <set_secondary_fwnode>:
 * pointer to @fwnode.  Otherwise, set the device's firmware node pointer to
 * @fwnode.
 */
void set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode)
{
	if (fwnode)
    2e78:	b4000061 	cbz	x1, 2e84 <set_secondary_fwnode+0xc>
		fwnode->secondary = ERR_PTR(-ENODEV);
    2e7c:	92800242 	mov	x2, #0xffffffffffffffed    	// #-19
    2e80:	f9000422 	str	x2, [x1,#8]

	if (fwnode_is_primary(dev->fwnode))
    2e84:	f9412802 	ldr	x2, [x0,#592]

#endif

static inline bool fwnode_is_primary(struct fwnode_handle *fwnode)
{
	return fwnode && !IS_ERR(fwnode->secondary);
    2e88:	b40000c2 	cbz	x2, 2ea0 <set_secondary_fwnode+0x28>
    2e8c:	f9400443 	ldr	x3, [x2,#8]
    2e90:	b140047f 	cmn	x3, #0x1, lsl #12
    2e94:	54000068 	b.hi	2ea0 <set_secondary_fwnode+0x28>
{
	if (fwnode)
		fwnode->secondary = ERR_PTR(-ENODEV);

	if (fwnode_is_primary(dev->fwnode))
		dev->fwnode->secondary = fwnode;
    2e98:	f9000441 	str	x1, [x2,#8]
	else
		dev->fwnode = fwnode;
}
    2e9c:	d65f03c0 	ret
		fwnode->secondary = ERR_PTR(-ENODEV);

	if (fwnode_is_primary(dev->fwnode))
		dev->fwnode->secondary = fwnode;
	else
		dev->fwnode = fwnode;
    2ea0:	f9012801 	str	x1, [x0,#592]
}
    2ea4:	d65f03c0 	ret

Disassembly of section .init.text:

0000000000000000 <devices_init>:
	return child;
}
EXPORT_SYMBOL_GPL(device_find_child);

int __init devices_init(void)
{
   0:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
	devices_kset = kset_create_and_add("devices", &device_uevent_ops, NULL);
   4:	90000001 	adrp	x1, 0 <devices_init>
			4: R_AARCH64_ADR_PREL_PG_HI21	.rodata
   8:	90000000 	adrp	x0, 0 <devices_init>
			8: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x468
   c:	91000021 	add	x1, x1, #0x0
			c: R_AARCH64_ADD_ABS_LO12_NC	.rodata
	return child;
}
EXPORT_SYMBOL_GPL(device_find_child);

int __init devices_init(void)
{
  10:	910003fd 	mov	x29, sp
	devices_kset = kset_create_and_add("devices", &device_uevent_ops, NULL);
  14:	d2800002 	mov	x2, #0x0                   	// #0
  18:	91018021 	add	x1, x1, #0x60
  1c:	91000000 	add	x0, x0, #0x0
			1c: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x468
	return child;
}
EXPORT_SYMBOL_GPL(device_find_child);

int __init devices_init(void)
{
  20:	a90153f3 	stp	x19, x20, [sp,#16]
	devices_kset = kset_create_and_add("devices", &device_uevent_ops, NULL);
  24:	94000000 	bl	0 <kset_create_and_add>
			24: R_AARCH64_CALL26	kset_create_and_add
  28:	90000001 	adrp	x1, 0 <devices_init>
			28: R_AARCH64_ADR_PREL_PG_HI21	.bss
	if (!devices_kset)
		return -ENOMEM;
  2c:	12800162 	mov	w2, #0xfffffff4            	// #-12
}
EXPORT_SYMBOL_GPL(device_find_child);

int __init devices_init(void)
{
	devices_kset = kset_create_and_add("devices", &device_uevent_ops, NULL);
  30:	91000033 	add	x19, x1, #0x0
			30: R_AARCH64_ADD_ABS_LO12_NC	.bss
  34:	aa0103f4 	mov	x20, x1
  38:	f9000020 	str	x0, [x1]
			38: R_AARCH64_LDST64_ABS_LO12_NC	.bss
	if (!devices_kset)
  3c:	b4000380 	cbz	x0, ac <devices_init+0xac>
		return -ENOMEM;
	dev_kobj = kobject_create_and_add("dev", NULL);
  40:	90000000 	adrp	x0, 0 <devices_init>
			40: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x470
  44:	d2800001 	mov	x1, #0x0                   	// #0
  48:	91000000 	add	x0, x0, #0x0
			48: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x470
  4c:	94000000 	bl	0 <kobject_create_and_add>
			4c: R_AARCH64_CALL26	kobject_create_and_add
  50:	f9001660 	str	x0, [x19,#40]
	if (!dev_kobj)
  54:	b4000260 	cbz	x0, a0 <devices_init+0xa0>
		goto dev_kobj_err;
	sysfs_dev_block_kobj = kobject_create_and_add("block", dev_kobj);
  58:	aa0003e1 	mov	x1, x0
  5c:	90000000 	adrp	x0, 0 <devices_init>
			5c: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x188
  60:	91000000 	add	x0, x0, #0x0
			60: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x188
  64:	94000000 	bl	0 <kobject_create_and_add>
			64: R_AARCH64_CALL26	kobject_create_and_add
  68:	f9001a60 	str	x0, [x19,#48]
	if (!sysfs_dev_block_kobj)
  6c:	b4000140 	cbz	x0, 94 <devices_init+0x94>
		goto block_kobj_err;
	sysfs_dev_char_kobj = kobject_create_and_add("char", dev_kobj);
  70:	f9401661 	ldr	x1, [x19,#40]
  74:	90000000 	adrp	x0, 0 <devices_init>
			74: R_AARCH64_ADR_PREL_PG_HI21	.rodata.str1.8+0x478
  78:	91000000 	add	x0, x0, #0x0
			78: R_AARCH64_ADD_ABS_LO12_NC	.rodata.str1.8+0x478
  7c:	94000000 	bl	0 <kobject_create_and_add>
			7c: R_AARCH64_CALL26	kobject_create_and_add
  80:	f9000660 	str	x0, [x19,#8]
	if (!sysfs_dev_char_kobj)
		goto char_kobj_err;

	return 0;
  84:	52800002 	mov	w2, #0x0                   	// #0
		goto dev_kobj_err;
	sysfs_dev_block_kobj = kobject_create_and_add("block", dev_kobj);
	if (!sysfs_dev_block_kobj)
		goto block_kobj_err;
	sysfs_dev_char_kobj = kobject_create_and_add("char", dev_kobj);
	if (!sysfs_dev_char_kobj)
  88:	b5000120 	cbnz	x0, ac <devices_init+0xac>
		goto char_kobj_err;

	return 0;

 char_kobj_err:
	kobject_put(sysfs_dev_block_kobj);
  8c:	f9401a60 	ldr	x0, [x19,#48]
  90:	94000000 	bl	0 <kobject_put>
			90: R_AARCH64_CALL26	kobject_put
 block_kobj_err:
	kobject_put(dev_kobj);
  94:	91000280 	add	x0, x20, #0x0
			94: R_AARCH64_ADD_ABS_LO12_NC	.bss
  98:	f9401400 	ldr	x0, [x0,#40]
  9c:	94000000 	bl	0 <kobject_put>
			9c: R_AARCH64_CALL26	kobject_put
 dev_kobj_err:
	kset_unregister(devices_kset);
  a0:	f9400280 	ldr	x0, [x20]
			a0: R_AARCH64_LDST64_ABS_LO12_NC	.bss
  a4:	94000000 	bl	0 <kset_unregister>
			a4: R_AARCH64_CALL26	kset_unregister
	return -ENOMEM;
  a8:	12800162 	mov	w2, #0xfffffff4            	// #-12
}
  ac:	2a0203e0 	mov	w0, w2
  b0:	a94153f3 	ldp	x19, x20, [sp,#16]
  b4:	a8c27bfd 	ldp	x29, x30, [sp],#32
  b8:	d65f03c0 	ret
